from model import PythonDB

def add_or_update_predefined_prompt(prompt, response):
    try:
        # Verificar si el prompt ya existe
        existing_entry = PythonDB.get_by_prompt(prompt)
        if existing_entry:
            # Si el prompt existe, actualizar la respuesta
            existing_entry.response = response
            existing_entry.save()
            print(f"Prompt existente actualizado: {prompt} -> {response}")
        else:
            # Si el prompt no existe, crear una nueva entrada
            new_entry = PythonDB(prompt=prompt, response=response)
            new_entry.save()
            print(f"Nuevo prompt predefinido agregado: {prompt} -> {response}")
    except Exception as e:
        print(f"Error al agregar o actualizar el prompt predefinido: {e}")

if __name__ == "__main__":
    # Ejemplo de uso
    prompt = "¬øQu√© es una base de datos?"
    response = "Una base de datos es una colecci√≥n organizada de datos, generalmente almacenados y accesibles electr√≥nicamente desde un sistema inform√°tico."

    add_or_update_predefined_prompt(prompt, response)
    
    # Agregar m√°s prompts predefinidos seg√∫n sea necesario
    prompts_responses = [

        (
            "ejercicio1",
            "# Ejercicio de python \n\n"
            "### Contador de palabras en una frase  \n\n"
            "Escribe un programa en `Python` que solicite al usuario una frase y devuelva el n√∫mero de palabras que contiene.  \n"
            "\n"
            "**Requisitos:**  \n"
            "1. Solicitar al usuario que ingrese una frase.  \n"
            "2. Contar cu√°ntas palabras tiene la frase.  \n"
            "3. Imprimir el resultado en pantalla.  \n"
            "4. Ignorar espacios en blanco extra al inicio o al final de la frase.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "Ingrese una frase: Hola, este es un ejercicio de Python.\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "La frase tiene 7 palabras.\n"
            "```\n"
            "\n"
            "### Soluci√≥n:\n"
            "```\n\n"
            "# Solicitar al usuario que ingrese una frase\n\n"
            "frase = input('Ingrese una frase: ').strip()\n"
            "\n"
            "# Dividir la frase en palabras usando split() y contar la cantidad de palabras\n\n"
            "num_palabras = len(frase.split())\n"
            "\n"
            "# Mostrar el resultado\n\n"
            "print(f'La frase tiene {num_palabras} palabras.')\n"
            "```\n"
            "\n"
            "Este ejercicio te ayuda a practicar el uso de `input()`, manipulaci√≥n de cadenas y la funci√≥n `split()`. üöÄ  \n"
            "\n"
            "Si quieres seguir con mas ejercicios el siguiente es ejercicio2. Un Saludo üòä\n"
        ),


        (

            "ejercicio2",
            "# Ejercicio: N√∫meros faltantes en una lista  \n\n"
            "Dada una lista de n√∫meros enteros del 1 al N en orden aleatorio, donde falta exactamente un n√∫mero, escribe un programa en Python que encuentre el n√∫mero faltante.  \n"
            "\n"
            "### Requisitos:\n"
            "1. La lista contendr√° n√∫meros √∫nicos dentro del rango de 1 a N.  \n"
            "2. El programa debe identificar cu√°l n√∫mero falta.  \n"
            "3. La soluci√≥n debe ser eficiente en t√©rminos de tiempo de ejecuci√≥n.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 4, 5]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "El n√∫mero faltante es: 3\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "```\n\n"
            "def encontrar_faltante(numeros):\n\n"
            "    n = len(numeros) + 1  # Como falta un n√∫mero, el total debe ser len(numeros) + 1\n\n"
            "    suma_esperada = n * (n + 1) // 2  # Suma de los primeros N n√∫meros (f√≥rmula matem√°tica)\n\n"
            "    suma_actual = sum(numeros)  # Suma de los n√∫meros en la lista\n\n"
            "    return suma_esperada - suma_actual  # El n√∫mero que falta\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 4, 5]\n\n"
            "faltante = encontrar_faltante(numeros)\n\n"
            "print(f'El n√∫mero faltante es: {faltante}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "- Se usa la f√≥rmula de la **suma de los primeros N n√∫meros**:  \n\n"
            "```\n\n"
            "                       N x ( N + 1)     \n"
            " Suma =       ---------------------------------\n"
            "                             2\n"
            "```\n"
            "\n"
            "- Restamos la suma de la lista dada de la suma esperada, obteniendo as√≠ el n√∫mero faltante.  \n\n"
            "- Esta soluci√≥n tiene una `complejidad O(n)`, lo que la hace eficiente.  \n"
            "\n"
            "Este tipo de ejercicios son muy comunes en pruebas t√©cnicas. Si necesitas m√°s variaciones o dificultad extra, sigue con ejercicio3 =) üöÄ\n"
        ),

        (
            "ejercicio3",
            "# Ejercicio: Primer car√°cter no repetido en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el primer car√°cter que no se repite y devuelve su √≠ndice. Si todos los caracteres se repiten, devuelve `-1`.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. El programa debe recibir una cadena de caracteres.  \n"
            "2. Debe encontrar el primer car√°cter √∫nico (que aparece solo una vez).  \n"
            "3. Debe devolver el √≠ndice de ese car√°cter o `-1` si no hay caracteres √∫nicos.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'abacabad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            'El primer car√°cter no repetido es "c" en el √≠ndice 3.\n'
            "```\n"
            "\n"
            "**Ejemplo con todos repetidos:**  \n"
            "```\n\n"
            "texto = 'aabbcc'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "No hay caracteres √∫nicos.\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def primer_no_repetido(texto):\n\n"
            "    conteo = {}  # Diccionario para contar la frecuencia de cada car√°cter\n"
            "\n"
            "    # Contar ocurrencias de cada car√°cter\n\n"
            "    for letra in texto:\n\n"
            "        conteo[letra] = conteo.get(letra, 0) + 1\n"
            "\n"
            "    # Buscar el primer car√°cter con una sola ocurrencia\n\n"
            "    for i, letra in enumerate(texto):\n\n"
            "        if conteo[letra] == 1:\n\n"
            "            return i  # Retorna el √≠ndice del primer car√°cter √∫nico\n"
            "    \n"
            "    return -1  # Si no hay caracteres √∫nicos\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'abacabad'\n\n"
            "indice = primer_no_repetido(texto)\n"
            "\n"
            "if indice != -1:\n\n"
            "    print(f'El primer car√°cter no repetido es '{texto[indice]}' en el √≠ndice {indice}.')\n\n"
            "else:\n\n"
            "    print('No hay caracteres √∫nicos.')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Primer paso:** Se usa un diccionario (`conteo`) para contar la frecuencia de cada letra en la cadena.  \n\n"
            "2. **Segundo paso:** Se recorre nuevamente la cadena y se devuelve el √≠ndice del primer car√°cter que aparece solo una vez.  \n\n"
            "3. **Complejidad:** Esta soluci√≥n tiene **O(n)** de complejidad, ya que se recorren los datos dos veces como m√°ximo.  \n"
            "\n"
            "Este ejercicio es √∫til para evaluar habilidades en manipulaci√≥n de cadenas y estructuras de datos como diccionarios.  \n"
            "\n"
            "Si quieres otra variante o m√°s desaf√≠os, sigue con ejercicio4 üöÄ\n"
        ),

        (
            "ejercicio4",
            "# Ejercicio: Rotar una lista a la derecha  \n"
            "\n"
            "Dada una lista de n√∫meros enteros y un n√∫mero `k`, escribe un programa en Python que rote la lista `k` posiciones a la derecha.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros y un n√∫mero `k`.  \n"
            "2. Mover los elementos `k` posiciones hacia la derecha.  \n"
            "3. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [4, 5, 1, 2, 3]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista est√° vac√≠a, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tama√±o de la lista\n\n"
            "    return lista[-k:] + lista[:-k]  # Tomar los √∫ltimos k elementos y colocarlos al inicio\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Controlamos el caso de una lista vac√≠a** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Dividimos la lista en dos partes**:  \n\n"
            "   - `lista[-k:]` obtiene los √∫ltimos `k` elementos.  \n\n"
            "   - `lista[:-k]` obtiene los elementos restantes.  \n\n"
            "   - Se concatenan para formar la nueva lista rotada.  \n\n"
            "4. **Eficiencia:**  \n\n"
            "   - Esta soluci√≥n tiene una complejidad de **O(n)**, ya que solo se realizan operaciones de divisi√≥n y concatenaci√≥n en la lista.  \n"
            "\n"
            "Este tipo de ejercicio es √∫til para evaluar la manipulaci√≥n de listas y la optimizaci√≥n de algoritmos.  \n"
            "\n"
            "¬øQuieres otro m√°s diferente o con m√°s dificultad? si no recuerdas comandos pon `help`üöÄ\n"
        ),

        (
            "ejercicio5",
            "# Ejercicio: Rotar una lista en ambas direcciones  \n"
            "\n"
            "Dada una lista de n√∫meros enteros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`), escribe un programa en Python que rote la lista `k` posiciones en la direcci√≥n indicada.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`).\n"
            "2. Mover los elementos `k` posiciones en la direcci√≥n especificada.\n"
            "3. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`.\n"
            "4. Si la direcci√≥n no es v√°lida, mostrar un mensaje de error.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista est√° vac√≠a, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tama√±o de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        return lista[-k:] + lista[:-k]  # Mover k posiciones a la derecha\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        return lista[k:] + lista[:k]  # Mover k posiciones a la izquierda\n\n"
            "    else:\n\n"
            "        raise ValueError('Direcci√≥n inv√°lida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k, direccion)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Manejamos listas vac√≠as** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Rotamos seg√∫n la direcci√≥n:**  \n\n"
            "   - Si es `'derecha'`, usamos `lista[-k:] + lista[:-k]`.  \n\n"
            "   - Si es `'izquierda'`, usamos `lista[k:] + lista[:k]`.  \n\n"
            "4. **Agregamos manejo de errores** con `raise ValueError` para evitar direcciones inv√°lidas.  \n\n"
            "5. **Eficiencia:**  \n\n"
            "   - La soluci√≥n sigue siendo **O(n)**, lo cual es √≥ptimo para este problema.  \n"
            "\n"
            "Este nivel de dificultad eval√∫a la capacidad del candidato para manejar par√°metros adicionales, excepciones y l√≥gica condicional.  \n"
            "\n"
            "¬øQuieres complicarlo a√∫n m√°s? Podemos hacerlo **en tiempo constante O(1)** usando una estrategia diferente. üöÄ\n"
            "\n"
            "`Te espero en el siguiente =)`"
        ), 

        (
            "ejercicio6",
            "# Ejercicio: Rotar una lista en O(1) sin modificarla**  \n"
            "\n"
            "Dada una lista de n√∫meros enteros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`), escribe un programa en Python que realice la rotaci√≥n sin modificar la lista original y en tiempo **O(1)** de acceso.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`).\n"
            "2. Lograr la rotaci√≥n sin crear una copia completa de la lista ni usar operaciones costosas de slicing.\n"
            "3. La soluci√≥n debe permitir iterar sobre la lista rotada en tiempo **O(1)**.\n"
            "4. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def iterador_rotado(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return iter([])  # Devolver un iterador vac√≠o si la lista est√° vac√≠a\n"
            "\n"
            "    n = len(lista)\n\n"
            "    k = k % n  # Asegurar que k no sea mayor que el tama√±o de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        inicio = n - k\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        inicio = k\n\n"
            "    else:\n\n"
            "        raise ValueError('Direcci√≥n inv√°lida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "    return (lista[(inicio + i) % n] for i in range(n))  # Generador en O(1)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {list(iterador_rotado(numeros, k, direccion))}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **No modificamos la lista original** ni hacemos slicing.  \n\n"
            "2. **Usamos √≠ndices calculados** para acceder a los elementos en el nuevo orden sin copiar la lista.  \n\n"
            "3. **Manejamos `k > len(lista)`** con `k % n`.  \n\n"
            "4. **La rotaci√≥n se logra con un generador**, permitiendo iterar sobre la lista en **O(1)** sin ocupar m√°s memoria.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo de acceso O(1)** porque solo cambiamos los √≠ndices.  \n\n"
            "‚úÖ **Espacio O(1)** porque usamos un generador en lugar de copiar la lista.  \n"
            "\n"
            "Este tipo de problema es √∫til en pruebas t√©cnicas cuando se eval√∫a eficiencia y manipulaci√≥n de iteradores. üöÄ  \n"
            "\n"
            "Si quieres un desaf√≠o a√∫n m√°s complicado, dime. üî•\n"
        ),

        (
            "ejercicio7",
            '# Ejercicio: Subarray de suma m√°xima (Kadane"s Algorithm)  \n'
            "\n"
            "Dada una lista de n√∫meros enteros (positivos y negativos), encuentra el **subarray contiguo** con la **suma m√°s alta** y devuelve esa suma.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros enteros.  \n"
            "2. Identificar el subarray contiguo cuya suma es la m√°xima posible.\n"
            "3. La soluci√≥n debe ser **O(n)** (lineal) en tiempo de ejecuci√≥n.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Suma m√°xima del subarray: 6  # (Subarray: [4, -1, 2, 1])\n"
            "```\n"
            "\n"
            '### Soluci√≥n (Kadane"s Algorithm - O(n))  \n'
            "\n"
            "```\n\n"
            "def max_subarray_suma(nums):\n\n"
            "    if not nums:\n\n"
            "        return 0  # Si la lista est√° vac√≠a, la suma es 0\n"
            "    \n"
            "    max_actual = max_global = nums[0]  # Inicializamos con el primer elemento\n"
            "\n"
            "    for num in nums[1:]:\n\n"
            "        max_actual = max(num, max_actual + num)  # M√°ximo entre el n√∫mero actual y seguir el subarray\n\n"
            "        max_global = max(max_global, max_actual)  # Guardamos el m√°ximo global encontrado\n"
            "    \n"
            "    return max_global\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n"
            "print(f'Suma m√°xima del subarray: {max_subarray_suma(numeros)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n"
            "1. **Se usa una estrategia de programaci√≥n din√°mica:**  \n"
            "   - `max_actual` almacena la mejor suma encontrada hasta el momento.  \n"
            "   - `max_global` almacena la mejor suma global de cualquier subarray encontrado.  \n\n"
            "2. **En cada iteraci√≥n:**  \n\n"
            "   - `max_actual` decide si continuar con la suma actual o reiniciar con el n√∫mero actual.\n"
            "   - `max_global` se actualiza si `max_actual` es mayor.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n)**: Se recorre la lista una sola vez.  \n"
            "   - **Espacio O(1)**: Solo usamos variables auxiliares, sin estructuras extra.  \n"
            "\n"
            "Este ejercicio es un cl√°sico en pruebas t√©cnicas para evaluar comprensi√≥n de **programaci√≥n din√°mica** y optimizaci√≥n de algoritmos.  \n"

        ),

        (
            "ejercicio8",
            "# Ejercicio: Pal√≠ndromo m√°s largo en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el **substring palindr√≥mico m√°s largo** dentro de ella.  \n"
            "\n"
            "### Requisitos:\n"
            "1. Recibir una cadena de texto.  \n"
            "2. Identificar el substring m√°s largo que sea un pal√≠ndromo.  \n"
            "3. La soluci√≥n debe ser **eficiente (O(n¬≤) o mejor si es posible).**  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'babad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Pal√≠ndromo m√°s largo: 'bab'  # o 'aba'\n"
            "```\n"
            "\n"
            "### Soluci√≥n (Expandiendo desde el centro - O(n¬≤))  \n"
            "\n"
            "```\n\n"
            "def palindromo_mas_largo(s):\n\n"
            "    if not s:\n\n"
            "        return ''\n"
            "\n"
            "    def expandir_desde_centro(izq, der):\n\n"
            "        while izq >= 0 and der < len(s) and s[izq] == s[der]:\n\n"
            "            izq -= 1\n\n"
            "            der += 1\n\n"
            "        return s[izq + 1:der]  # Devolvemos la subcadena palindr√≥mica encontrada\n"
            "\n"
            "    mejor_palindromo = ''\n"
            "\n"
            "    for i in range(len(s)):\n\n"
            "        # Expandir para pal√≠ndromos de longitud impar (ej. 'aba')\n\n"
            "        palindromo1 = expandir_desde_centro(i, i)\n\n"
            "        # Expandir para pal√≠ndromos de longitud par (ej. 'abba')\n\n"
            "        palindromo2 = expandir_desde_centro(i, i + 1)\n"
            "\n"
            "        # Guardar el m√°s largo encontrado hasta ahora\n\n"
            "        if len(palindromo1) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo1\n\n"
            "        if len(palindromo2) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo2\n"
            "\n"
            "    return mejor_palindromo\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'babad'\n\n"
            "print(f'Pal√≠ndromo m√°s largo: {palindromo_mas_largo(texto)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n"
            "1. **Expansi√≥n desde el centro:**  \n"
            "   - Tomamos cada letra como un centro potencial.  \n"
            "   - Expandimos a la izquierda y derecha mientras los caracteres sean iguales.  \n"
            "   - Verificamos tanto para **longitudes impares ('aba')** como **pares ('abba')**.  \n\n"
            "2. **Guardamos el m√°s largo encontrado:**  \n"
            "   - Se comparan los resultados de cada expansi√≥n.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n¬≤)**: Revisamos `n` posiciones y expandimos en `n` en el peor caso.  \n"
            "   - **Espacio O(1)**: No usamos estructuras adicionales.  \n"

        ),

        (
            "ejercicio9",
            "# Ejercicio: FizzBuzz Modificado  \n"
            "\n"
            "El cl√°sico problema de **FizzBuzz** se usa mucho en pruebas t√©cnicas, pero vamos a darle un giro m√°s interesante:  \n"
            "\n"
            "### Instrucciones:  \n"
            "Escribe un programa que recorra los n√∫meros del 1 al `N` e imprima:\n"
            "- `'Fizz'` si el n√∫mero es m√∫ltiplo de 3.\n"
            "- `'Buzz'` si el n√∫mero es m√∫ltiplo de 5. \n"
            "- `'FizzBuzz'` si el n√∫mero es m√∫ltiplo de 3 y 5.\n"
            "- **Si el n√∫mero es primo**, imprimir `'Prime'`, independientemente de si es m√∫ltiplo de 3 o 5. \n"
            "- En cualquier otro caso, imprimir el n√∫mero. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "N = 20\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "1\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "8\n\n"
            "Fizz\n\n"
            "Buzz\n\n"
            "11\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "14\n\n"
            "FizzBuzz\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def es_primo(num):\n\n"
            "    if num < 2:\n\n"
            "        return False\n\n"
            "    for i in range(2, int(num ** 0.5) + 1):  # Verificar divisibilidad hasta la ra√≠z cuadrada\n\n"
            "        if num % i == 0:\n\n"
            "            return False\n\n"
            "    return True\n"
            "\n"
            "def fizzbuzz_modificado(N):\n\n"
            "    for i in range(1, N + 1):  \n\n"
            "        if es_primo(i):  # Si es primo, lo imprimimos directamente\n\n"
            "            print('Prime')\n\n"
            "        elif i % 3 == 0 and i % 5 == 0:\n\n"
            "            print('FizzBuzz')\n\n"
            "        elif i % 3 == 0:\n\n"
            "            print('Fizz')\n\n"
            "        elif i % 5 == 0:\n\n"
            "            print('Buzz')\n\n"
            "        else:\n\n"
            "            print(i)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "N = 20\n\n"
            "fizzbuzz_modificado(N)\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Usamos un `for` para recorrer los n√∫meros de 1 a `N`**.  \n\n"
            "2. **Creamos una funci√≥n `es_primo(num)`**:  \n\n"
            "   - Verifica si un n√∫mero es primo comprobando divisibilidad hasta `‚àönum`.  \n\n"
            "3. **Estructura condicional dentro del `for`**:  \n\n"
            "   - Primero comprobamos si es primo.  \n\n"
            "   - Luego aplicamos las reglas de FizzBuzz.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo O(N‚àöN)** por la verificaci√≥n de primos (mejorable con la criba de Erat√≥stenes).  \n\n"
            "‚úÖ **Uso de `for` de manera clara y estructurada**.  \n"
            "\n"
            "`As√≠ se hace crack !`  üöÄüî•\n"
        ),

        (
            "ejercicio10",
            "# Ejercicio: Anagramas  \n"
            "\n"
            "Dadas dos cadenas de texto, escribe una funci√≥n en Python que determine si son **anagramas**.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Dos palabras son **anagramas** si tienen las mismas letras en distinta posici√≥n.  \n"
            "2. La comparaci√≥n **no debe ser sensible a may√∫sculas/min√∫sculas**.  \n"
            "3. Ignorar los espacios y caracteres especiales.  \n"
            "4. La soluci√≥n debe ser **eficiente (O(n))**.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "Otro ejemplo:  \n"
            "```\n\n"
            "cadena1 = 'Hello'\n\n"
            "cadena2 = 'Olelh'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "### Soluci√≥n (O(n))  \n"
            "\n"
            "```\n\n"
            "from collections import Counter\n\n"
            "import re\n"
            "\n"
            "def son_anagramas(cadena1, cadena2):\n\n"
            "    # Normalizar: convertir a min√∫sculas y eliminar caracteres que no sean letras\n\n"
            '    cadena1 = re.sub(r"[^a-z]", "", cadena1.lower())\n\n'
            '    cadena2 = re.sub(r"[^a-z]", "", cadena2.lower())\n'
            "\n"
            "    # Comparar las frecuencias de letras usando Counter\n\n"
            "    return Counter(cadena1) == Counter(cadena2)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n\n"
            "print(f'Son anagramas: {son_anagramas(cadena1, cadena2)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:** \n"
            "1. **Normalizaci√≥n de cadenas:**  \n"
            "   - Convertimos a min√∫sculas (`lower()`).  \n"
            '   - Eliminamos espacios y caracteres especiales usando `re.sub(r"[^a-z]", "", texto)`.  \n\n'
            "2. **Comparaci√≥n eficiente con `Counter` de `collections`**:  \n"
            "   - Cuenta la frecuencia de cada letra en ambas cadenas.  \n"
            "   - Si los `Counter` son iguales, las palabras son anagramas.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo O(n)** (un solo recorrido para limpiar y otro para contar letras).  \n\n"
            "‚úÖ **Espacio O(1)** (uso m√≠nimo de memoria adicional).  \n"
            "\n"
            "Este ejercicio es muy com√∫n en pruebas t√©cnicas para evaluar **manejo de cadenas, estructuras de datos y optimizaci√≥n**.  \n"
        ),      

        (
            "ejercicio11",
            "# Ejercicio: An√°lisis de Ventas\n"
            "**Escribe un programa en Python que:**\n"

            "üìö Lea un archivo CSV con datos de ventas (cada fila tiene: nombre del producto, cantidad vendida y precio unitario).\n"
            "üìö Calcule el total de ingresos por producto.\n"
            "üìö Muestre el producto con mayores ventas en cantidad y en ingresos.\n"
            "üìö Guarde los resultados en un nuevo archivo CSV.\n\n"
            "**Datos de ejemplo (ventas.csv)**\n"
            "Producto   |  Cantidad   |   Precio  \n\n"
            "Laptop     |     5       |     700\n"
            "Teclado    |     10      |     20\n"
            "Mouse      |     8       |     15\n"
            "Monitor    |     4       |     150\n"
            "Laptop     |     2       |     700 \n"
            "Teclado    |     5       |     20 \n"
            "\n"
            "### Objetivos del ejercicio: \n\n"
            "‚úÖManejo de archivos (lectura/escritura de CSV)\n"
            "‚úÖ Uso de diccionarios para acumular datos\n"
            "‚úÖ Operaciones con listas y cadenas\n"
            "‚úÖ Iteraciones y condiciones\n"
            "\n"
            "### Soluci√≥n :"
            "**Paso 1: Importar las librer√≠as necesarias**  \n\n"
            "Python tiene una librer√≠a llamada `csv` que facilita la lectura y escritura de archivos CSV.  \n"
            "\n"
            "```\n\n"
            "import csv\n\n"
            "from collections import defaultdict\n"
            "```\n"
            "\n"
            "- `csv`: Nos permite manejar archivos CSV de manera sencilla.  \n\n"
            "- `defaultdict`: Nos ayuda a almacenar datos sin necesidad de inicializar manualmente valores por defecto.  \n"
            "\n"
            "**Paso 2: Leer el archivo CSV y procesar los datos**  \n\n"
            "Vamos a leer el archivo `ventas.csv` y almacenar los datos en un diccionario.  \n"
            "\n"
            "```\n\n"
            "ventas = defaultdict(lambda: {'cantidad': 0, 'ingresos': 0})  \n"
            "\n"
            "with open('ventas.csv', newline='', encoding='utf-8') as archivo:\n\n"
            "    lector_csv = csv.reader(archivo)\n\n"
            "    next(lector_csv)  # Omitimos la primera fila (encabezado)\n"
            "    \n"
            "    for fila in lector_csv:\n\n"
            "        producto, cantidad, precio = fila[0], int(fila[1]), float(fila[2])\n"
            "        \n"
            "        # Acumulamos las cantidades y los ingresos\n\n"
            "        ventas[producto]['cantidad'] += cantidad\n\n"
            "        ventas[producto]['ingresos'] += cantidad * precio\n"
            "```\n"
            "\n"
            "### üîπ **Explicaci√≥n:**  \n\n"
            "- Usamos `defaultdict` para crear un diccionario donde cada producto tiene sus ventas y sus ingresos acumulados.  \n\n"
            "- Abrimos el archivo CSV en modo lectura (`open('ventas.csv', 'r')`).  \n\n"
            "- `csv.reader(archivo)` lee cada l√≠nea del archivo como una lista.  \n\n"
            "- `next(lector_csv)` salta la primera fila porque es el encabezado.  \n\n"
            "- Iteramos sobre cada fila, obteniendo:  \n\n"
            "  - `producto` (nombre del producto)  \n\n"
            "  - `cantidad` (convertida a entero)  \n\n"
            "  - `precio` (convertido a flotante)  \n\n"
            "- Acumulamos la cantidad total vendida y los ingresos en el diccionario `ventas`.  \n"
            "\n"
            "**Paso 3: Encontrar el producto m√°s vendido y el de mayores ingresos**  \n"
            "\n"
            "```\n\n"
            "producto_mas_vendido = max(ventas.items(), key=lambda x: x[1]['cantidad'])\n\n"
            "producto_mas_ingresos = max(ventas.items(), key=lambda x: x[1]['ingresos'])\n"
            "\n"
            "print(f'Producto m√°s vendido: {producto_mas_vendido[0]} ({producto_mas_vendido[1]['cantidad']} unidades)')\n\n"
            "print(f'Producto con m√°s ingresos: {producto_mas_ingresos[0]} (${producto_mas_ingresos[1]['ingresos']:.2f})')\n"
            "```\n"
            "\n"
            "### üîπ **Explicaci√≥n:**  \n\n"
            "- `max(ventas.items(), key=lambda x: x[1]['cantidad'])`: Busca el producto con mayor cantidad vendida.  \n\n"
            "- `max(ventas.items(), key=lambda x: x[1]['ingresos'])`: Encuentra el producto con m√°s ingresos.  \n\n"
            "- `print()`: Muestra los resultados en la consola.  \n"
            "\n"
            "**Paso 4: Guardar los resultados en un nuevo archivo CSV**  \n"
            "\n"
            "```\n\n"
            "with open('resultados_ventas.csv', 'w', newline='', encoding='utf-8') as archivo_salida:\n\n"
            "    escritor_csv = csv.writer(archivo_salida)\n"
            "    \n"
            "    # Escribir encabezado\n\n"
            "    escritor_csv.writerow(['Producto', 'Cantidad Vendida', 'Ingresos Totales'])\n"
            "    \n"
            "    # Escribir datos\n\n"
            "    for producto, datos in ventas.items():\n\n"
            "        escritor_csv.writerow([producto, datos['cantidad'], f'{datos['ingresos']:.2f}'])\n"
            "```\n"
            "\n"
            "### üîπ **Explicaci√≥n:**  \n\n"
            "- Abrimos un nuevo archivo `resultados_ventas.csv` en modo escritura.  \n\n"
            "- Escribimos la primera fila con los nombres de las columnas.  \n\n"
            "- Iteramos sobre el diccionario `ventas` para escribir los datos en el archivo.  \n"
            "\n"
            "**C√≥digo Completo**  \n"
            "\n"
            "```\n\n"
            "import csv\n\n"
            "from collections import defaultdict\n"
            "\n"
            "# Diccionario para almacenar los datos\n\n"
            "ventas = defaultdict(lambda: {'cantidad': 0, 'ingresos': 0})\n"
            "\n"
            "# Leer archivo CSV y procesar datos\n\n"
            "with open('ventas.csv', newline='', encoding='utf-8') as archivo:\n\n"
            "    lector_csv = csv.reader(archivo)\n\n"
            "    next(lector_csv)  # Saltar el encabezado\n"
            "\n"
            "    for fila in lector_csv:\n\n"
            "        producto, cantidad, precio = fila[0], int(fila[1]), float(fila[2])\n\n"
            "        ventas[producto]['cantidad'] += cantidad\n\n"
            "        ventas[producto]['ingresos'] += cantidad * precio\n"
            "\n"
            "# Encontrar productos destacados\n\n"
            "producto_mas_vendido = max(ventas.items(), key=lambda x: x[1]['cantidad'])\n\n"
            "producto_mas_ingresos = max(ventas.items(), key=lambda x: x[1]['ingresos'])\n"
            "\n"
            "print(f'Producto m√°s vendido: {producto_mas_vendido[0]} ({producto_mas_vendido[1]['cantidad']} unidades)')\n\n"
            "print(f'Producto con m√°s ingresos: {producto_mas_ingresos[0]} (${producto_mas_ingresos[1]['ingresos']:.2f})')\n"
            "\n"
            "# Guardar los resultados en un nuevo archivo CSV\n\n"
            "with open('resultados_ventas.csv', 'w', newline='', encoding='utf-8') as archivo_salida:\n\n"
            "    escritor_csv = csv.writer(archivo_salida)\n\n"
            "    escritor_csv.writerow(['Producto', 'Cantidad Vendida', 'Ingresos Totales'])\n"
            "\n"
            "    for producto, datos in ventas.items():\n\n"
            "        escritor_csv.writerow([producto, datos['cantidad'], f'{datos['ingresos']:.2f}'])\n"
            "```\n"
            "\n"
            "**Ejemplo de Salida en Consola**  \n"
            "\n"
            "```\n\n"
            "Producto m√°s vendido: Teclado (15 unidades)\n\n"
            "Producto con m√°s ingresos: Laptop ($4900.00)\n"
            "```\n"
            "\n"
            "**Ejemplo de Salida en `resultados_ventas.csv`**  \n"
            "\n"
            "```\n\n"
            "Producto,Cantidad Vendida,Ingresos Totales\n\n"
            "Laptop,7,4900.00\n\n"
            "Teclado,15,300.00\n\n"
            "Mouse,8,120.00\n\n"
            "Monitor,4,600.00\n"
            "```\n"
            "\n"
            "**¬øQu√© se aprende con este ejercicio?**  \n\n"
            "‚úÖ **Manejo de archivos CSV** (lectura y escritura).  \n\n"
            "‚úÖ **Uso de estructuras de datos avanzadas** (`defaultdict` para acumular informaci√≥n).  \n\n"
            "‚úÖ **Uso de funciones de ordenaci√≥n** (`max()` con `lambda`).  \n\n"
            "‚úÖ **Bucles e iteraciones eficientes**.  \n\n"
            "‚úÖ **Conversi√≥n de tipos de datos** (de cadena a `int` y `float`).  \n"
            "\n"
        ),

        (
            "ejercicio12",
            "# üìå Ejercicio 12:  \n\n"
            "Escribe una funci√≥n en Python llamada `numeros_faltantes` que tome una lista de n√∫meros enteros ordenados de forma ascendente y devuelva una lista con los n√∫meros que faltan en la secuencia.  \n"
            "\n"
            "**Ejemplo 1:**  \n"
            "```\n"
            "entrada = [1, 2, 4, 6, 7, 10]\n\n"
            "salida = [3, 5, 8, 9]\n"
            "```  \n"
            "**Ejemplo 2:**  \n"
            "```\n"
            "entrada = [10, 11, 12, 14, 16]\n\n"
            "salida = [13, 15]\n"
            "```\n"
            "\n"
            "### ‚ú® **Soluci√≥n Explicada**:\n\n"
            "Aqu√≠ tienes la soluci√≥n con una explicaci√≥n paso a paso:\n"
            "\n"
            "```\n"
            "def numeros_faltantes(lista):\n\n"
            "    if not lista:  # Si la lista est√° vac√≠a, retornamos una lista vac√≠a\n\n"
            "        return []\n"
            "\n"
            "    inicio = lista[0]  # Primer n√∫mero de la lista\n\n"
            "    fin = lista[-1]    # √öltimo n√∫mero de la lista\n"
            "    \n"
            "    # Generamos un conjunto con todos los n√∫meros en el rango de la secuencia\n\n"
            "    conjunto_completo = set(range(inicio, fin + 1))\n"
            "    \n"
            "    # Convertimos la lista de entrada en un conjunto\n\n"
            "    conjunto_lista = set(lista)\n"
            "    \n"
            "    # La diferencia entre ambos conjuntos nos da los n√∫meros faltantes\n\n"
            "    faltantes = sorted(conjunto_completo - conjunto_lista)\n"
            "    \n"
            "    return faltantes\n"
            "\n"
            "# Pruebas\n\n"
            "print(numeros_faltantes([1, 2, 4, 6, 7, 10]))  # ‚ûù [3, 5, 8, 9]\n\n"
            "print(numeros_faltantes([10, 11, 12, 14, 16])) # ‚ûù [13, 15]\n\n"
            "print(numeros_faltantes([]))                   # ‚ûù []\n\n"
            "print(numeros_faltantes([5, 6, 7, 8]))         # ‚ûù []\n"
            "```\n"
            "\n"
            "üîç **Explicaci√≥n del C√≥digo**:\n\n"
            "1. **Verificaci√≥n de lista vac√≠a**: Si la lista est√° vac√≠a, simplemente retornamos `[]`.\n\n"
            "2. **Encontramos el rango completo**: Usamos `range(inicio, fin+1)` para generar todos los n√∫meros desde el primero hasta el √∫ltimo de la lista.\n\n"
            "3. **Creamos conjuntos**: Convertimos la lista dada en un `set()` para poder compararla con el conjunto completo.\n\n"
            "4. **Diferencia de conjuntos**: Restamos ambos conjuntos (`conjunto_completo - conjunto_lista`) para obtener los n√∫meros faltantes.\n\n"
            "5. **Devolvemos los valores ordenados**: Convertimos el resultado en una lista ordenada.\n"
            "\n"
            "Este tipo de ejercicio eval√∫a el conocimiento sobre:\n\n"
            "‚úÖ Manipulaci√≥n de listas y conjuntos  \n\n"
            "‚úÖ Uso de `range()` y operaciones de conjuntos  \n\n"
            "‚úÖ Eficiencia en la soluci√≥n (uso de conjuntos en vez de bucles anidados)\n"
        ),

        (
            "ejercicio13",
            "# üìå Ejercicio 13  \n\n"
            "Escribe una funci√≥n en Python llamada `rango_faltante_mas_largo` que tome una lista de n√∫meros enteros ordenados y devuelva el **rango continuo de n√∫meros faltantes m√°s largo** dentro de la secuencia.\n"
            "**Ejemplo 1:**  \n"
            "```\n"
            "entrada = [1, 2, 4, 6, 7, 10, 11, 12, 15]\n\n"
            "salida = [5, 6]\n"
            "```\n"
            "**Explicaci√≥n:** Los n√∫meros faltantes son `[3, 5, 8, 9, 13, 14]`, pero el rango m√°s largo es `[5, 6]` con longitud 2.\n"
            "\n"
            "**Ejemplo 2:**  \n"
            "```\n\n"
            "entrada = [10, 11, 12, 14, 16, 17, 18, 20, 21, 22]\n\n"
            "salida = [13, 14]\n"
            "```\n\n"
            "> Explicaci√≥n: Los n√∫meros faltantes son `[13, 15, 19]`, pero el rango m√°s largo es `[13, 14]` con longitud 2.\n"
            "\n"
            "### ‚ú® **Soluci√≥n Explicada**:\n"
            "\n"
            "```\n\n"
            "def rango_faltante_mas_largo(lista):\n\n"
            "    if not lista:\n\n"
            "        return []\n"
            "\n"
            "    inicio, fin = lista[0], lista[-1]\n\n"
            "    conjunto_lista = set(lista)\n"
            "    \n"
            "    max_rango = []\n\n"
            "    actual_rango = []\n"
            "\n"
            "    for num in range(inicio, fin + 1):\n\n"
            "        if num not in conjunto_lista:\n\n"
            "            actual_rango.append(num)\n\n"
            "        else:\n\n"
            "            if len(actual_rango) > len(max_rango):\n\n"
            "                max_rango = actual_rango\n\n"
            "            actual_rango = []  # Reiniciamos la lista\n"
            "\n"
            "    # Verificaci√≥n final por si el rango m√°s largo est√° al final de la iteraci√≥n\n\n"
            "    if len(actual_rango) > len(max_rango):\n\n"
            "        max_rango = actual_rango\n"
            "\n"
            "    return max_rango\n"
            "\n"
            "# Pruebas\n\n"
            "print(rango_faltante_mas_largo([1, 2, 4, 6, 7, 10, 11, 12, 15]))  # ‚ûù [5, 6]\n\n"
            "print(rango_faltante_mas_largo([10, 11, 12, 14, 16, 17, 18, 20, 21, 22]))  # ‚ûù [13, 14]\n\n"
            "print(rango_faltante_mas_largo([1, 3, 5, 7, 9]))  # ‚ûù [2, 3]\n\n"
            "print(rango_faltante_mas_largo([5, 6, 7, 8]))  # ‚ûù []\n\n"
            "print(rango_faltante_mas_largo([]))  # ‚ûù []\n"
            "```\n"
            "\n"
            "üîç **Explicaci√≥n del C√≥digo**:\n\n"
            "1. **Verificaci√≥n de lista vac√≠a**: Si la lista est√° vac√≠a, retornamos `[]`.\n\n"
            "2. **Generamos el rango completo**: Desde `inicio` hasta `fin` usando `range()`.\n\n"
            "3. **Recorremos el rango**:\n\n"
            "   - Si encontramos un n√∫mero faltante, lo agregamos a `actual_rango`.\n\n"
            "   - Si encontramos un n√∫mero que **s√≠ est√° en la lista**, verificamos si `actual_rango` es m√°s largo que `max_rango`, y luego lo reiniciamos.\n\n"
            "4. **Verificaci√≥n final**: Por si el rango m√°s largo termina justo al final del bucle.\n\n"
            "5. **Retornamos el rango m√°s largo de n√∫meros faltantes**.\n"
            "\n"
            "üìà **Complejidad del Algoritmo**:\n\n"
            "- La soluci√≥n usa un **√∫nico recorrido (O(n))**, ya que iteramos la lista una vez.\n\n"
            "- El uso de `set(lista)` nos permite hacer b√∫squedas en **O(1)** en lugar de O(n).\n"
            "\n"
            "üí° **Este tipo de ejercicio eval√∫a**:\n\n"
            "‚úÖ Manipulaci√≥n eficiente de listas  \n\n"
            "‚úÖ Algoritmos de b√∫squeda de secuencias  \n\n"
            "‚úÖ Complejidad computacional  \n"  
        ),

        (
            "ejercicio14",
            "# üìå Ejercicio 14  \n\n"
            "Escribe una funci√≥n en Python llamada `subarreglo_maximo` que encuentre la **subsecuencia contigua** con la **mayor suma** dentro de una lista de n√∫meros enteros (puede contener positivos y negativos).  \n"

            "**Ejemplo 1:**  \n"
            "```\n\n"
            "entrada = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n"
            "salida = [4, -1, 2, 1]  # Suma = 6\n"
            "```\n"

            "**Ejemplo 2:**  \n"
            "```\n\n"
            "entrada = [5, -2, 3, -1, 6, -3, 2, -5, 4]\n\n"
            "salida = [5, -2, 3, -1, 6]  # Suma = 11\n"
            "```\n"

            "**Ejemplo 3:**  \n"
            "```\n\n"
            "entrada = [-1, -2, -3, -4]\n\n"
            "salida = [-1]  # Si todos son negativos, devolvemos el mayor\n"
            "```\n"

            '### ‚ú® Soluci√≥n Explicada (Usando Kadane"s Algorithm):\n'

            "```\n\n"
            "def subarreglo_maximo(arr):\n\n"
            "    if not arr:\n\n"
            "        return []\n"
            "\n"
            "    max_suma = arr[0]\n\n"
            "    actual_suma = arr[0]\n"
            "    \n"
            "    inicio, fin = 0, 0\n\n"
            "    temp_inicio = 0\n"
            "\n"
            "    for i in range(1, len(arr)):\n\n"
            "        if arr[i] > actual_suma + arr[i]:  \n\n"
            "            actual_suma = arr[i]\n\n"
            "            temp_inicio = i  # Iniciamos nueva sublista\n\n"
            "        else:\n\n"
            "            actual_suma += arr[i]  \n"
            "\n"
            "        if actual_suma > max_suma:\n\n"
            "            max_suma = actual_suma\n\n"
            "            inicio = temp_inicio\n\n"
            "            fin = i  # Marcamos el final del mejor subarreglo\n"
            "\n"
            "    return arr[inicio:fin+1]  # Devolvemos la sublista con mayor suma\n"
            "\n"
            "# Pruebas\n\n"
            "print(subarreglo_maximo([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # ‚ûù [4, -1, 2, 1]\n\n"
            "print(subarreglo_maximo([5, -2, 3, -1, 6, -3, 2, -5, 4]))  # ‚ûù [5, -2, 3, -1, 6]\n\n"
            "print(subarreglo_maximo([-1, -2, -3, -4]))  # ‚ûù [-1]\n\n"
            "print(subarreglo_maximo([1, 2, 3, 4, 5]))  # ‚ûù [1, 2, 3, 4, 5]\n\n"
            "print(subarreglo_maximo([]))  # ‚ûù []\n"
            "```\n"
            "\n"
            "üîç **Explicaci√≥n del C√≥digo**:\n\n"
            "1. **Inicializamos variables**:\n\n"
            "   - `max_suma` almacena la mayor suma encontrada.\n\n"
            "   - `actual_suma` mantiene la suma de la subsecuencia actual.\n\n"
            "   - `inicio`, `fin` y `temp_inicio` nos permiten rastrear los √≠ndices del mejor subarreglo.\n\n"
            "2. **Recorremos la lista**:\n\n"
            "   - Decidimos si agregar el n√∫mero actual a la suma o **empezar una nueva subsecuencia**.\n\n"
            "   - Si la nueva suma supera la `max_suma`, actualizamos los √≠ndices.\n\n"
            "3. **Devolvemos la subsecuencia con mayor suma**.\n"
            "\n"
            "üìà **Complejidad del Algoritmo**:\n\n"
            "- **O(n)** ‚Üí Kadane‚Äôs Algorithm resuelve este problema en **tiempo lineal**.\n"
            "\n"
            "üí° **Este ejercicio eval√∫a**:\n\n"
            "‚úÖ Algoritmos de programaci√≥n din√°mica  \n\n"
            "‚úÖ Manipulaci√≥n eficiente de listas  \n\n"
            "‚úÖ Manejo de secuencias y sumas  \n"
        ),

        (
            "ejercicio15",
            "## üìå **Ejercicio: Suma de D√≠gitos Recursiva (Ra√≠z Digital)**  \n\n"
            "**Ejemplo 1:**  \n"
            "```\n"
            "entrada = 9875\n"
            "salida = 2\n"
            "```\n"
            "**Explicaci√≥n:**\n"
            "9 + 8 + 7 + 5 = **29**\n"
            "2 + 9 = **11** \n"
            "1 + 1 = **2** \n"
            "\n"
            "**Ejemplo 2:**\n"
            "```\n\n"
            "entrada = 1234\n\n"
            "salida = 1\n"
            "```\n\n"
            "**Explicaci√≥n:**  \n"
            "1 + 2 + 3 + 4 = **10** \n"
            "1 + 0 = **1**  \n"
            "\n"
            "**Ejemplo 3:**  \n"
            "```\n\n"
            "entrada = 9\n\n"
            "salida = 9\n"
            "```\n\n"
            "**Explicaci√≥n:** Es un solo d√≠gito, as√≠ que se devuelve tal cual.\n"
            "\n"
            "‚ú® **Soluci√≥n Explicada (Versi√≥n Recursiva)**:\n"
            "```\n\n"
            "def raiz_digital(n):\n\n"
            "    if n < 10:  # Si ya es un solo d√≠gito, lo devolvemos\n\n"
            "        return n\n\n"
            "    suma = sum(int(digito) for digito in str(n))  # Sumamos los d√≠gitos\n\n"
            "    return raiz_digital(suma)  # Llamamos a la funci√≥n recursivamente\n"
            "\n"
            "# Pruebas\n\n"
            "print(raiz_digital(9875))  # ‚ûù 2\n\n"
            "print(raiz_digital(1234))  # ‚ûù 1\n\n"
            "print(raiz_digital(9))     # ‚ûù 9\n\n"
            "print(raiz_digital(99999)) # ‚ûù 9\n\n"
            "print(raiz_digital(100))   # ‚ûù 1\n"
            "```\n"
            "\n"
            "üîç **Explicaci√≥n del C√≥digo**:\n\n"
            "1. **Caso base**: Si `n` ya es un solo d√≠gito, se devuelve tal cual.\n\n"
            "2. **Convertimos el n√∫mero en una lista de d√≠gitos** (`str(n)`) y los sumamos.\n\n"
            "3. **Llamamos a la funci√≥n recursivamente** con la nueva suma hasta llegar a un solo d√≠gito.\n"
            "\n"
            "üìà **Complejidad del Algoritmo**:\n\n"
            "- **O(log n)** ‚Üí Porque en cada paso reducimos la cantidad de d√≠gitos.\n"
            "\n"
            "üí° **Este ejercicio ayuda a practicar**:  \n\n"
            "‚úÖ Recursi√≥n  \n\n"
            "‚úÖ Manipulaci√≥n de n√∫meros y strings  \n\n"
            "‚úÖ Algoritmos matem√°ticos b√°sicos  \n"
        ),

        (
            "ejercicio16",
            "# Ejercicio 16: Conversi√≥n de temperatura\n"
            "### Crea un programa que convierta grados Celsius a Fahrenheit.\n"
            "El usuario debe ingresar la temperatura en Celsius y el programa mostrar√° el equivalente en Fahrenheit.\n"
            "```\n"
            "F√≥rmula: F = (C √ó 9/5) + 32\n"
            "```\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'celsius = float(input("Ingresa la temperatura en Celsius: "))'
            "fahrenheit = (celsius * 9/5) + 32\n"
            'print(f"{celsius}¬∞C equivalen a {fahrenheit}¬∞F")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos input() para recibir la temperatura en Celsius y float() para convertirla a decimal.\n"
            "- Aplicamos la f√≥rmula de conversi√≥n.\n"
            "- Usamos una f-string para formatear la salida con los valores.\n"
        ),

        (
            "ejercicio17",
            "# Ejercicio 17: N√∫mero primo\n\n"
            "### Descripci√≥n\n"
            "Verifica si un numero ingresado por el usuario es primo o no\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'numero = int(input("Ingresa un n√∫mero: "))\n'
            "es_primo = True\n\n"
            "if numero <= 1:\n"
            "    es_primo = False\n"
            "else:\n"
            "    for i in range(2, int(numero**0.5) + 1):\n"
            "        if numero % i == 0:\n"
            "            es_primo = False\n"
            "            break\n\n"
            'print(f"¬ø{numero} es primo? {es_primo}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Un n√∫mero primo es mayor que 1 y solo divisible por 1 y s√≠ mismo.\n"
            "- Iteramos desde 2 hasta la ra√≠z cuadrada del n√∫mero (optimizaci√≥n para reducir iteraciones).\n"
            "- Si el n√∫mero es divisible por alg√∫n valor en ese rango, no es primo.\n"
        ),

        (
            "ejercicio18",
            "# Ejercicio 18: Invertir una cadena\n\n"
            "### Descripci√≥n\n"
            "Escribe un programa que invierta una cadena ingresada por el usuario.\n"
            "**Ejemplo:** 'hola' -> 'aloh'\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'cadena = input("Ingresa una cadena: ")\n'
            'invertida = ""\n\n'
            "for caracter in cadena:\n"
            "    invertida = caracter + invertida\n\n"
            'print(f"Cadena invertida: {invertida}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos un bucle for para recorrer cada car√°cter de la cadena original.\n"
            "- En cada iteraci√≥n, concatenamos el car√°cter al principio de la cadena invertida.\n"
            "- Alternativamente, se podr√≠a usar cadena[::-1], pero este m√©todo ense√±a el proceso manual.\n"
        ),

        (
            "ejercicio19",
            "# Ejercicio 19: Fibonacci simple\n\n"
            "Genera los primeros n t√©rminos de la secuencia de Fibonacci, donde n es ingresado por el usuario.\n"
            "La secuencia comienza con 0 y 1, y cada t√©rmino siguiente es la suma de los dos anteriores.\n"
            "\n"
            "**Ejemplo:** Si n = 5, la salida es [0, 1, 1, 2, 3].\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'n = int(input("Ingresa cu√°ntos t√©rminos de Fibonacci quieres: "))\n'
            "fibonacci = [0, 1]\n\n"
            "for i in range(2, n):\n"
            "    siguiente = fibonacci[i-1] + fibonacci[i-2]\n"
            "    fibonacci.append(siguiente)\n\n"
            'print(f"Primeros {n} t√©rminos:", fibonacci[:n])\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Inicializamos la lista con los primeros dos valores: [0, 1].\n"
            "- Usamos un bucle para calcular cada nuevo t√©rmino sumando los dos anteriores.\n"
            "- Si el usuario ingresa n <= 2, usamos fibonacci[:n] para evitar errores.\n"
        ),

        (
            "ejercicio20",
            "# Ejercicio 20: Tabla de multiplicar\n\n"
            "Imprime la tabla de multiplicar de un n√∫mero ingresado por el usuario, desde el 1 hasta el 10.\n"
            "**Ejemplo:** Para 5, la salida debe ser 5x1=5, 5x2=10, ..., 5x10=50.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'numero = int(input("Ingresa un n√∫mero: "))\n\n'
            "for i in range(1, 11):\n"
            '    print(f"{numero}x{i} = {numero * i}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos un bucle for con range(1, 11) para iterar del 1 al 10.\n"
            "- En cada iteraci√≥n, calculamos el producto y usamos f-strings para formatear la salida.\n"
            "- Ideal para practicar bucles y formateo de cadenas.\n"

        ),

        (
            "ejercicio21",
            "# Ejercicio 21: Suma de d√≠gitos\n\n"
            "Calcula la suma de los d√≠gitos de un n√∫mero entero ingresado por el usuario.\n"
            "**Ejemplo:** Si el n√∫mero es 1234, la suma es 1 + 2 + 3 + 4 = 10.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'numero = input("Ingresa un n√∫mero entero: ")\n'
            "suma = 0\n\n"
            "for digito in numero:\n"
            "    suma += int(digito)\n\n"
            'print(f"Suma de los d√≠gitos: {suma}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Tratamos el n√∫mero como una cadena para iterar sobre cada d√≠gito.\n"
            "- Convertimos cada d√≠gito a entero y lo sumamos.\n"
            "- Alternativa num√©rica: usar % 10 y divisiones para extraer d√≠gitos (ejercicio avanzado).\n"

        ),

        (
            "ejercicio22",
            "# Ejercicio 22: Adivina el n√∫mero\n\n"
            "Crea un juego donde el programa genera un n√∫mero aleatorio entre 1 y 100, y el usuario debe adivinarlo.\n"
            "\n"
            'El programa da pistas como "muy alto" o "muy bajo" hasta que el usuario acierte.\n'
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import random\n\n"
            "numero_secreto = random.randint(1, 100)\n"
            "intentos = 0\n\n"
            "while True:\n"
            '    intento = int(input("Adivina el n√∫mero (1-100): "))\n'
            "    intentos += 1\n\n"
            "    if intento < numero_secreto:\n"
            '        print("Demasiado bajo ‚¨á")\n'
            "    elif intento > numero_secreto:\n"
            '        print("Demasiado alto ‚¨Ü")\n'
            "    else:\n"
            '        print(f"¬°Correcto! Lo lograste en {intentos} intentos.")\n'
            "        break\n"
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos random.randint() para generar el n√∫mero aleatorio.\n"
            "- El bucle while True se repite hasta que el usuario acierta.\n"
            "- Contamos los intentos para dar retroalimentaci√≥n al final.\n"
        ),

        (
            "ejercicio23",
            "# Ejercicio 23: Factorial de un n√∫mero (usando recursi√≥n)\n\n"
            "Calcula el factorial de un n√∫mero usando una funci√≥n recursiva.\n"
            "El factorial de n (n!) es el producto de todos los enteros positivos desde 1 hasta n.\n"
            "\n"
            "**Ejemplo:** 5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def factorial(n):\n"
            "    if n == 0 or n == 1:\n"
            "        return 1\n"
            "    else:\n"
            "        return n * factorial(n-1)\n\n"
            'numero = int(input("Ingresa un n√∫mero: "))\n'
            'print(f"{numero}! = {factorial(numero)}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- La recursi√≥n se basa en que n! = n √ó (n-1)!, con caso base 0! = 1 y 1! = 1.\n"
            "- Si n es 0 o 1, retorna 1. En otro caso, llama a la funci√≥n con n-1.\n"
        ),

        (
            "ejercicio24",
            "# Ejercicio 24: Filtrar n√∫meros pares de una lista\n\n"
            "Crea una lista con n√∫meros del 1 al 20 y luego filtra solo los n√∫meros pares usando comprensi√≥n de listas.\n"
            "Salida esperada: [2, 4, 6, ..., 20].\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "numeros = list(range(1, 21))\n"
            "pares = [num for num in numeros if num % 2 == 0]\n"
            'print("N√∫meros pares:", pares)\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- range(1, 21) genera n√∫meros del 1 al 20.\n"
            "- La comprensi√≥n de listas ([num for ...]) filtra los elementos que cumplen num % 2 == 0.\n"
            "- Ideal para ense√±ar sintaxis compacta y eficiente.\n"
        ),

        (
            "ejercicio25",
            "# Ejercicio 25: Combinar dos diccionarios\n\n"
            "Combina dos diccionarios sumando los valores de las claves repetidas.\n"
            "Ejemplo:\n"
            "dict1 = {'a': 10, 'b': 20}\n"
            "dict2 = {'b': 30, 'c': 40}\n\n"
            "Resultado: {'a': 10, 'b': 50, 'c': 40}.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "dict1 = {'a': 10, 'b': 20}\n"
            "dict2 = {'b': 30, 'c': 40}\n"
            "resultado = {}\n\n"
            "#Combinar claves √∫nicas de ambos diccionarios\n"
            "for key in dict1.keys() | dict2.keys():\n"
            "    resultado[key] = dict1.get(key, 0) + dict2.get(key, 0)\n\n"
            'print("Diccionario combinado:", resultado)\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- dict1.keys() | dict2.keys() obtiene todas las claves √∫nicas de ambos diccionarios.\n"
            "- get(key, 0) devuelve 0 si la clave no existe en un diccionario.\n"
            "- Sumamos los valores de cada clave para combinarlos.\n"
        ),

        (
            "ejercicio26",
            "# Ejercicio 26: Validar a√±o bisiesto\n\n"
            "Determina si un a√±o ingresado por el usuario es bisiesto.\n"
            "\n"
            "### Reglas:\n"
            "- Divisible por 4 ‚Üí Bisiesto.\n"
            "- Excepto si es divisible por 100 ‚Üí No bisiesto.\n"
            "- A menos que tambi√©n sea divisible por 400 ‚Üí Bisiesto.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'anio = int(input("Ingresa un a√±o: "))\n\n'
            'es_bisiesto = (anio % 4 == 0 and anio % 100 != 0) or (anio % 400 == 0)\n'
            'print(f"¬ø{anio} es bisiesto? {es_bisiesto}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos operadores l√≥gicos para aplicar las reglas en una sola l√≠nea.\n"
            "- Ejemplo: 2000 es bisiesto (divisible por 400), pero 1900 no (divisible por 100 pero no por 400).\n"
        ),

        (
            "ejercicio27",
            "# Ejercicio 27: Ordenar lista con Bubble Sort\n\n"
            "Implementa el algoritmo de Bubble Sort para ordenar una lista de n√∫meros ingresada por el usuario.\n"
            "Ejemplo: [5, 3, 8, 1] ‚Üí [1, 3, 5, 8].\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "lista = [5, 3, 8, 1, 2]\n"
            "n = len(lista)\n\n"
            "for i in range(n):\n"
            "    for j in range(0, n-i-1):\n"
            "        if lista[j] > lista[j+1]:\n"
            "            lista[j], lista[j+1] = lista[j+1], lista[j]  # Intercambiar\n\n"
            'print("Lista ordenada:", lista)\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Bubble Sort compara elementos adyacentes y los intercambia si est√°n en orden incorrecto.\n"
            "- El bucle externo controla las pasadas completas, y el interno recorre la lista reduciendo el rango en cada pasada (n-i-1).\n"
            "- √ötil para ense√±ar algoritmos de ordenamiento b√°sicos.\n"
            "\n"

        ),

        (
            "ejercicio28",
            "# Ejercicio 28: Contar palabras en un archivo\n\n"
            "Crea un programa que lea un archivo de texto (.txt) y cuente cu√°ntas veces aparece cada palabra. Ignora may√∫sculas/min√∫sculas y signos de puntuaci√≥n.\n"
            'Ejemplo de salida: {"python": 5, "hola": 3, ...}.\n'
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import string\n\n"
            "def contar_palabras(nombre_archivo):\n"
            "    contador = {}\n"
            "    with open(nombre_archivo, 'r') as archivo:\n"
            "        texto = archivo.read().lower()\n"
            "        # Eliminar signos de puntuaci√≥n\n"
            "        texto = texto.translate(str.maketrans('', '', string.punctuation))\n"
            "        palabras = texto.split()\n\n"
            "        for palabra in palabras:\n"
            "            contador[palabra] = contador.get(palabra, 0) + 1\n"
            "    return contador\n\n"
            '# Ejecuci√≥n (aseg√∫rate de tener el archivo "ejemplo.txt")\n'
            'resultado = contar_palabras("ejemplo.txt")\n'
            'print("Frecuencia de palabras:", resultado)\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos translate() y string.punctuation para eliminar signos de puntuaci√≥n.\n"
            "- contador.get(palabra, 0) evita errores si la palabra no est√° en el diccionario.\n"
            "- Ideal para ense√±ar manejo de archivos y limpieza de datos.\n"
        ),

        (
            "ejercicio29",
            "# Ejercicio 29: Cifrado C√©sar\n\n"
            "Implementa un cifrado C√©sar que desplace cada letra de un mensaje por un n√∫mero fijo de posiciones en el alfabeto.\n"
            'Ejemplo: Con desplazamiento 3, "HOLA" ‚Üí "KROD".\n'
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def cifrado_cesar(texto, desplazamiento):\n"
            "    resultado = []\n"
            "    for letra in texto:\n"
            "        if letra.isalpha():\n"
            "            ascii_base = ord('a') if letra.islower() else ord('A')\n"
            "            nueva_letra = chr((ord(letra) - ascii_base + desplazamiento) % 26 + ascii_base)\n"
            "            resultado.append(nueva_letra)\n"
            "        else:\n"
            "            resultado.append(letra)\n"
            "    return ''.join(resultado)\n\n"
            'texto = input("Ingresa el texto: ")\n'
            'desplazamiento = int(input("Desplazamiento: ")\n'
            'print("Texto cifrado:", cifrado_cesar(texto, desplazamiento))\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos ord() y chr() para convertir entre caracteres y valores ASCII.\n"
            '- % 26 asegura que el desplazamiento "d√© la vuelta" (ej: la z + 1 ‚Üí a).\n'
            "- Se conservan espacios y caracteres no alfab√©ticos.\n"
        ),

        (
            "ejercicio30",
            "# Ejercicio 30: Calculadora de edad\n\n"
            "Pide al usuario su fecha de nacimiento (dd/mm/aaaa) y calcula su edad en a√±os.\n"
            "Ejemplo: Si hoy es 15/04/2024 y naci√≥ el 20/05/2000 ‚Üí 23 a√±os.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "from datetime import datetime\n\n"
            "def calcular_edad(fecha_nac):\n"
            "    hoy = datetime.now()\n"
            '    nacimiento = datetime.strptime(fecha_nac, "%d/%m/%Y")\n\n'
            "    edad = hoy.year - nacimiento.year\n"
            "    # Ajustar si a√∫n no ha pasado el cumplea√±os este a√±o\n"
            "    if (hoy.month, hoy.day) < (nacimiento.month, nacimiento.day):\n"
            "        edad -= 1\n"
            "    return edad\n\n"
            'fecha = input("Ingresa tu fecha de nacimiento (dd/mm/aaaa): ")\n'
            'print(f"Tienes {calcular_edad(fecha)} a√±os.")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos datetime para manejar fechas.\n"
            "- strptime convierte la cadena de entrada en un objeto fecha.\n"
            "- El ajuste resta 1 a√±o si el cumplea√±os a√∫n no ha ocurrido en el a√±o actual.\n"
        ),

        (
            "ejercicio31",
            "# Ejercicio 31: Validar contrase√±a segura\n\n"
            "Verifica si una contrase√±a tiene al menos 8 caracteres, una may√∫scula, una min√∫scula, y un n√∫mero.\n"
            "Ejemplo:\n"
            "Contrase√±a: Python3 ‚Üí V√°lida.\n"
            "Contrase√±a: hola ‚Üí Inv√°lida.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def es_contrase√±a_segura(password):\n"
            "    if len(password) < 8:\n"
            "        return False\n"
            "    tiene_mayuscula = any(c.isupper() for c in password)\n"
            "    tiene_minuscula = any(c.islower() for c in password)\n"
            "    tiene_numero = any(c.isdigit() for c in password)\n"
            "    return tiene_mayuscula and tiene_minuscula and tiene_numero\n\n"
            'password = input("Ingresa tu contrase√±a: ")\n'
            'print("¬øEs segura?", es_contrase√±a_segura(password))\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos any() para verificar al menos un car√°cter cumple cada condici√≥n.\n"
            "- Combina comprobaciones de longitud y tipos de caracteres.\n"
        ),

        (
            "ejercicio32",
            "# Ejercicio 32: B√∫squeda binaria (recursiva)\n\n"
            "Implementa el algoritmo de b√∫squeda binaria de forma recursiva para encontrar un elemento en una lista ordenada.\n"
            "Si el elemento existe, devuelve su √≠ndice; si no, devuelve -1.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def busqueda_binaria(lista, elemento, inicio=0, fin=None):\n"
            "    if fin is None:\n"
            "        fin = len(lista) - 1\n"
            "    if inicio > fin:\n"
            "        return -1\n\n"
            "    medio = (inicio + fin) // 2\n\n"
            "    if lista[medio] == elemento:\n"
            "        return medio\n"
            "    elif lista[medio] < elemento:\n"
            "        return busqueda_binaria(lista, elemento, medio + 1, fin)\n"
            "    else:\n"
            "        return busqueda_binaria(lista, elemento, inicio, medio - 1)\n\n"
            "# Ejemplo de uso:\n"
            "lista_ordenada = [2, 5, 8, 12, 16, 23, 38, 45]\n"
            "elemento = 23\n"
            "indice = busqueda_binaria(lista_ordenada, elemento)\n"
            'print(f"El elemento {elemento} est√° en el √≠ndice {indice}" if indice != -1 else "No encontrado")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- La b√∫squeda binaria divide la lista en mitades hasta encontrar el elemento.\n"
            "- Complejidad: O(log n), mucho m√°s eficiente que una b√∫squeda lineal (O(n)).\n"
            "- Requiere que la lista est√© preordenada.\n"

        ),

        (
            "ejercicio33",
            "# Ejercicio 33: Implementar una pila (Stack) con clases\n\n"
            "Crea una clase Pila que permita:\n"
            "- A√±adir elementos (push).\n"
            "- Eliminar el √∫ltimo elemento a√±adido (pop).\n"
            "- Verificar si est√° vac√≠a.\n"
            '- Validar si una cadena de par√©ntesis est√° balanceada (ej: "(()())" ‚Üí v√°lida, "())(" ‚Üí inv√°lida).\n'
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "class Pila:\n"
            "    def __init__(self):\n"
            "        self.elementos = []\n\n"
            "    def push(self, elemento):\n"
            "        self.elementos.append(elemento)\n\n"
            "    def pop(self):\n"
            "        if not self.esta_vacia():\n"
            "            return self.elementos.pop()\n"
            "        return None\n\n"
            "    def esta_vacia(self):\n"
            "        return len(self.elementos) == 0\n\n"
            "def parentesis_balanceados(cadena):\n"
            "    pila = Pila()\n"
            "    for caracter in cadena:\n"
            "        if caracter == '(':\n"
            "            pila.push(caracter)\n"
            "        elif caracter == ')':\n"
            "            if pila.esta_vacia():\n"
            "                return False\n"
            "            pila.pop()\n"
            "    return pila.esta_vacia()\n\n"
            "# Ejemplo:\n"
            'cadena = "(()()())"\n'
            'print(f"¬ø` {cadena} ` est√° balanceada? {parentesis_balanceados(cadena)}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- La clase Pila usa una lista interna para almacenar elementos.\n"
            "- Para validar par√©ntesis, cada ( se apila y cada ) desapila si hay correspondencia.\n"
            "- Si la pila est√° vac√≠a al final, la cadena es v√°lida.\n"
        ),
        
        (
            "ejercicio34",
            "# Ejercicio 34: Generador de n√∫meros primos (Criba de Erat√≥stenes)\n\n"
            "Implementa el algoritmo de la Criba de Erat√≥stenes para generar todos los primos menores o iguales a n.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def criba_eratostenes(n):\n"
            "    if n < 2:\n"
            "        return []\n"
            "    sieve = [True] * (n + 1)\n"
            "    sieve[0] = sieve[1] = False\n"
            "    for numero in range(2, int(n**0.5) + 1):\n"
            "        if sieve[numero]:\n"
            "            for multiplo in range(numero*numero, n+1, numero):\n"
            "                sieve[multiplo] = False\n"
            "    return [i for i, es_primo in enumerate(sieve) if es_primo]\n\n"
            "# Ejemplo:\n"
            "n = 30\n"
            'print(f"Primos ‚â§ {n}: {criba_eratostenes(n)}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- El algoritmo marca los m√∫ltiplos de cada primo empezando desde 2.\n"
            "- Complejidad: O(n log log n), mucho m√°s eficiente que verificar cada n√∫mero individualmente.\n"
            "- Usado en problemas de teor√≠a de n√∫meros y optimizaci√≥n.\n"
        ),

        (
            "ejercicio35",
            "# Ejercicio 35: Decorador para medir tiempo de ejecuci√≥n\n\n"
            "Crea un decorador que mida el tiempo de ejecuci√≥n de una funci√≥n y lo imprima.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import time\n\n"
            "def medir_tiempo(func):\n"
            "    def wrapper(*args, **kwargs):\n"
            "        inicio = time.time()\n"
            "        resultado = func(*args, **kwargs)\n"
            "        fin = time.time()\n"
            '        print(f"Tiempo de ejecuci√≥n de {func.__name__}: {fin - inicio:.4f} segundos")\n'
            "        return resultado\n"
            "    return wrapper\n\n"
            "@medir_tiempo\n"
            "def funcion_ejemplo(n):\n"
            "    suma = 0\n"
            "    for i in range(n):\n"
            "        suma += i\n"
            "    return suma\n\n"
            "# Ejemplo:\n"
            "funcion_ejemplo(1_000_000)\n"
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Los decoradores envuelven funciones para a√±adir funcionalidad (en este caso, medir tiempo).\n"
            "- √ötil para optimizar c√≥digo y diagnosticar cuellos de botella.\n"
            "- *args y **kwargs permiten que el decorador sea gen√©rico.\n"
        ),

        (
            "ejercicio36",
            "# Ejercicio 36: Par o impar\n\n"
            "Pide al usuario un n√∫mero y determina si es par o impar.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'numero = int(input("Ingresa un n√∫mero: "))\n'
            "if numero % 2 == 0:\n"
            '    print(f"{numero} es par.")\n'
            "else:\n"
            '    print(f"{numero} es impar.")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos el operador % (m√≥dulo) para ver si el residuo de dividir entre 2 es 0.\n"
            "- Ideal para practicar condicionales simples.\n"
        ),

        (
            "ejercicio37",
            "# Ejercicio 37: Calculadora de √°rea\n\n"
            "Pide al usuario elegir entre calcular el √°rea de un c√≠rculo o un rect√°ngulo, luego pide los datos necesarios y muestra el resultado.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'opcion = input("¬ø√Årea de c√≠rculo (C) o rect√°ngulo (R)? ").lower()\n\n'
            'if opcion == "c":\n'
            '    radio = float(input("Radio del c√≠rculo: "))\n'
            "    area = 3.1416 * radio ** 2\n"
            '    print(f"√Årea: {area:.2f}")\n'
            'elif opcion == "r":\n'
            '    base = float(input("Base del rect√°ngulo: "))\n'
            '    altura = float(input("Altura del rect√°ngulo: "))\n'
            "    area = base * altura\n"
            '    print(f"√Årea: {area:.2f}")\n'
            "else:\n"
            '    print("Opci√≥n inv√°lida.")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos lower() para manejar may√∫sculas/min√∫sculas.\n"
            "- Formateamos el resultado con :.2f para mostrar dos decimales.\n"
        ),

        (
            "ejercicio38",
            "# Ejercicio 38: Quiz de preguntas simples\n\n"
            "Crea un cuestionario de 3 preguntas de opci√≥n m√∫ltiple (ej: capitales de pa√≠ses) y muestra el puntaje final.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "puntaje = 0\n\n"
            'print("Responde las siguientes preguntas:")\n'
            'print("1. ¬øCu√°l es la capital de Francia?")\n'
            'print("a) Londres  b) Par√≠s  c) Roma")\n'
            'resp1 = input("Tu respuesta: ").lower()\n'
            'if resp1 == "b":\n'
            "    puntaje += 1\n\n"
            'print("\n2. ¬øCu√°ntos planetas hay en el sistema solar?")\n'
            'print("a) 7  b) 8  c) 9")\n'
            'resp2 = input("Tu respuesta: ").lower()\n'
            'if resp2 == "b":\n'
            "    puntaje += 1\n\n"
            'print("\n3. ¬øQu√© lenguaje usamos en este curso?")\n'
            'print("a) Java  b) Python  c) C++")\n'
            'resp3 = input("Tu respuesta: ").lower()\n'
            'if resp3 == "b":\n'
            "    puntaje += 1\n\n"
            'print(f"\nPuntaje final: {puntaje}/3")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Cada pregunta tiene una respuesta correcta predefinida.\n"
            "- Usamos un contador (puntaje) para llevar la cuenta de aciertos.\n"
        ),

        (
            "ejercicio39",
            "# Ejercicio 39: Contar elementos en una lista\n\n"
            "Pide al usuario ingresar una lista de n√∫meros separados por comas, luego pide un n√∫mero espec√≠fico y cuenta cu√°ntas veces aparece.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            'entrada = input("Ingresa n√∫meros separados por comas: ")\n'
            'lista = [int(num) for num in entrada.split(",")]\n'
            'busqueda = int(input("¬øQu√© n√∫mero quieres contar? "))\n\n'
            "conteo = lista.count(busqueda)\n"
            'print(f"El n√∫mero {busqueda} aparece {conteo} veces.")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            '- split(",") divide la cadena en partes usando comas.\n'
            "- count() es un m√©todo de listas que simplifica el conteo.\n"
        ),

        (
            "ejercicio40",
            "# Ejercicio 40: B√∫squeda en profundidad (DFS) en grafos\n\n"
            "Implementa el algoritmo DFS para recorrer un grafo representado como un diccionario de listas de adyacencia. El programa debe mostrar el orden de visita de los nodos.\n"
            "\n"
            "**Entrada de ejemplo**\n"
            "```\n"
            "grafo = {\n"
            "    'A': ['B', 'C'],\n"
            "    'B': ['D', 'E'],\n"
            "    'C': ['F'],\n"
            "    'D': [],\n"
            "    'E': ['F'],\n"
            "    'F': []\n"
            "}\n"
            "```\n"
            "**Salida esperada (empezando desde 'A'):**\n"
            "A -> B -> D -> E -> F -> C\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def dfs(grafo, nodo_inicial):\n"
            "    visitados = set()\n"
            "    stack = [nodo_inicial]\n"
            "    recorrido = []\n\n"
            "    while stack:\n"
            "        nodo = stack.pop()\n"
            "        if nodo not in visitados:\n"
            "            visitados.add(nodo)\n"
            "            recorrido.append(nodo)\n"
            "            # Agregar vecinos en orden inverso para mantener el orden l√≥gico\n"
            "            for vecino in reversed(grafo[nodo]):\n"
            "                stack.append(vecino)\n"
            "    return recorrido\n\n"
            "grafo = {\n"
            "    'A': ['B', 'C'],\n"
            "    'B': ['D', 'E'],\n"
            "    'C': ['F'],\n"
            "    'D': [],\n"
            "    'E': ['F'],\n"
            "    'F': []\n"
            "}\n"
            'print("DFS:", " -> ".join(dfs(grafo, "A")))\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Usamos una pila (LIFO) para el recorrido.\n"
            "- reversed() asegura que los vecinos se procesen en el orden correcto (ej: 'B' antes que 'C').\n"
            "- Complejidad: O(V + E), donde V es el n√∫mero de v√©rtices y E el de aristas.\n"
        ),

        (
            "ejercicio41",
            "# Ejercicio 41: Validar correo electr√≥nico con regex\n\n"
            "Usa expresiones regulares para validar si una cadena es un correo electr√≥nico v√°lido.\n"
            "**Reglas b√°sicas:**\n"
            "- Formato: nombre@dominio.extension\n"
            "- Extensiones v√°lidas: 2 a 4 letras (ej: .com, .org, .edu).\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import re\n\n"
            "def validar_email(email):\n"
            "    patron = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$'\n"
            "    return re.match(patron, email) is not None\n\n"
            'emails = ["usuario@example.com", "invalido@.com", "nombre@dominio.extensionlarga"]\n'
            "for email in emails:\n"
            '    print(f"{email}: {"V√°lido" if validar_email(email) else "Inv√°lido"}")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- ^ y $ aseguran que toda la cadena cumple el patr√≥n.\n"
            "- [a-zA-Z]{2,4} valida extensiones de 2 a 4 caracteres.\n"
            "**Componentes del patr√≥n**\n"
            "- [a-zA-Z0-9._%+-]+: Nombre del usuario.\n"
            "- @[a-zA-Z0-9.-]+: Dominio.\n"
            "- \.[a-zA-Z]{2,4}$: Extensi√≥n.\n"

        ),

        (
            "ejercicio42",
            "# Ejercicio 42: Gestor de tareas con archivos JSON\n\n"
            "Crea un programa que permita:\n"
            "- Agregar tareas (nombre y estado: pendiente/completada).\n"
            "- Guardar las tareas en un archivo JSON.\n"
            "- Cargar tareas desde el archivo.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import json\n\n"
            "def cargar_tareas(archivo):\n"
            "    try:\n"
            "        with open(archivo, 'r') as f:\n"
            "            return json.load(f)\n"
            "    except FileNotFoundError:\n"
            "        return []\n\n"
            "def guardar_tareas(tareas, archivo):\n"
            "    with open(archivo, 'w') as f:\n"
            "        json.dump(tareas, f, indent=4)\n\n"
            "def agregar_tarea(nombre, tareas):\n"
            '    tareas.append({"nombre": nombre, "completada": False})\n\n'
            "# Ejemplo de uso:\n"
            'archivo = "tareas.json"\n'
            "tareas = cargar_tareas(archivo)\n\n"
            'agregar_tarea("Aprender Python", tareas)\n'
            'agregar_tarea("Hacer ejercicio", tareas)\n\n'
            "guardar_tareas(tareas, archivo)\n"
            'print("Tareas guardadas en "tareas.json".")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- json.dump() y json.load() manejan la serializaci√≥n de datos.\n"
            "- Manejo de excepciones: FileNotFoundError para archivos inexistentes.\n"
            '- Estructura del JSON: Lista de diccionarios con claves "nombre" y "completada".\n'
        ),

        (
            "ejercicio43",
            "# Ejercicio 43: (Threading b√°sico)\n\n"
            "Crea dos hilos que impriman n√∫meros pares e impares del 1 al 10 simult√°neamente.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import threading\n\n"
            "def imprimir_pares():\n"
            "    for i in range(2, 11, 2):\n"
            '        print(f"Par: {i}")\n\n'
            "def imprimir_impares():\n"
            "    for i in range(1, 11, 2):\n"
            '        print(f"Impar: {i}")\n\n'
            "hilo_pares = threading.Thread(target=imprimir_pares)\n"
            "hilo_impares = threading.Thread(target=imprimir_impares)\n\n"
            "hilo_pares.start()\n"
            "hilo_impares.start()\n\n"
            "hilo_pares.join()\n"
            "hilo_impares.join()\n\n"
            'print("Hilos terminados.")\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Threading: Permite ejecuci√≥n concurrente (no paralela en CPython por el GIL).\n"
            "- Sincronizaci√≥n: join() espera a que los hilos terminen.\n"
            "- Salida: Los n√∫meros pares e impares se mezclar√°n seg√∫n el orden de ejecuci√≥n.\n"
        ),

        (
            "ejercicio44",
            "# Ejercicio 44: Clases abstractas y herencia\n\n"
            "Crea una clase abstracta Figura con m√©todos calcular_area() y calcular_perimetro(). Luego implementa las clases Circulo y Rectangulo heredando de Figura.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "from abc import ABC, abstractmethod\n"
            "import math\n\n"
            "class Figura(ABC):\n"
            "    @abstractmethod\n"
            "    def calcular_area(self):\n"
            "        pass\n\n"
            "    @abstractmethod\n"
            "    def calcular_perimetro(self):\n"
            "        pass\n\n"
            "class Circulo(Figura):\n"
            "    def __init__(self, radio):\n"
            "        self.radio = radio\n\n"
            "    def calcular_area(self):\n"
            "        return math.pi * self.radio ** 2\n\n"
            "    def calcular_perimetro(self):\n"
            "        return 2 * math.pi * self.radio\n\n"
            "class Rectangulo(Figura):\n"
            "    def __init__(self, base, altura):\n"
            "        self.base = base\n"
            "        self.altura = altura\n\n"
            "    def calcular_area(self):\n"
            "        return self.base * self.altura\n\n"
            "    def calcular_perimetro(self):\n"
            "        return 2 * (self.base + self.altura)\n\n"
            "# Ejemplo de uso:\n"
            "circulo = Circulo(5)\n"
            'print(f"√Årea del c√≠rculo: {circulo.calcular_area():.2f}")  # 78.54\n'
            "rectangulo = Rectangulo(4, 7)\n"
            'print(f"Per√≠metro del rect√°ngulo: {rectangulo.calcular_perimetro()}")  # 22\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- ABC y @abstractmethod definen m√©todos que las subclases deben implementar.\n"
            "- Cumple con el principio de abstracci√≥n en POO.\n"
        ),

        (
            "ejercicio45",
            "# Ejercicio 45: Merge Sort (algoritmo recursivo)\n\n"
            "Implementa el algoritmo Merge Sort para ordenar una lista de n√∫meros.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "def merge_sort(lista):\n"
            "    if len(lista) > 1:\n"
            "        medio = len(lista) // 2\n"
            "        izquierda = lista[:medio]\n"
            "        derecha = lista[medio:]\n\n"
            "        merge_sort(izquierda)\n"
            "        merge_sort(derecha)\n\n"
            "        i = j = k = 0\n\n"
            "        # Fusionar sublistas ordenadas\n"
            "        while i < len(izquierda) and j < len(derecha):\n"
            "            if izquierda[i] < derecha[j]:\n"
            "                lista[k] = izquierda[i]\n"
            "                i += 1\n"
            "            else:\n"
            "                lista[k] = derecha[j]\n"
            "                j += 1\n"
            "            k += 1\n\n"
            "        # Elementos restantes\n"
            "        while i < len(izquierda):\n"
            "            lista[k] = izquierda[i]\n"
            "            i += 1\n"
            "            k += 1\n\n"
            "        while j < len(derecha):\n"
            "            lista[k] = derecha[j]\n"
            "            j += 1\n"
            "            k += 1\n\n"
            "# Ejemplo:\n"
            "lista = [38, 27, 43, 3, 9, 82, 10]\n"
            "merge_sort(lista)\n"
            'print("Lista ordenada:", lista)  # [3, 9, 10, 27, 38, 43, 82]\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Divide y vencer√°s: Divide la lista en mitades, ordena recursivamente y fusiona.\n"
            "- Complejidad: O(n log n) en todos los casos.\n"
        ),

        (
            "ejercicio46",
            "# Ejercicio 46: Conexi√≥n a SQLite y CRUD\n\n"
            "Crea una base de datos SQLite llamada estudiantes.db con una tabla Estudiante (id, nombre, edad). Implementa funciones para insertar, consultar y eliminar registros.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import sqlite3\n\n"
            "def crear_tabla():\n"
            '    conexion = sqlite3.connect("estudiantes.db")\n'
            "    cursor = conexion.cursor()\n"
            "    cursor.execute('''CREATE TABLE IF NOT EXISTS Estudiante\n"
            "                      (id INTEGER PRIMARY KEY, nombre TEXT, edad INTEGER)''')\n"
            "    conexion.commit()\n"
            "    conexion.close()\n\n"
            "def insertar_estudiante(nombre, edad):\n"
            '    conexion = sqlite3.connect("estudiantes.db")\n'
            "    cursor = conexion.cursor()\n"
            '    cursor.execute("INSERT INTO Estudiante (nombre, edad) VALUES (?, ?)", (nombre, edad))\n'
            "    conexion.commit()\n"
            "    conexion.close()\n\n"
            "def consultar_estudiantes():\n"
            '    conexion = sqlite3.connect("estudiantes.db")\n'
            "    cursor = conexion.cursor()\n"
            '    cursor.execute("SELECT * FROM Estudiante")\n'
            "    estudiantes = cursor.fetchall()\n"
            "    conexion.close()\n"
            "    return estudiantes\n\n"
            "# Ejemplo de uso:\n"
            "crear_tabla()\n"
            'insertar_estudiante("Ana", 22)\n'
            'insertar_estudiante("Luis", 25)\n'
            'print("Estudiantes:", consultar_estudiantes())  # [(1, "Ana", 22), (2, "Luis", 25)]\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- CRUD: Create (INSERT), Read (SELECT).\n"
            "- Usa par√°metros ? para evitar inyecciones SQL.\n"
        ),

        (
            "ejercicio47",
            "# Ejercicio 47: Consumo de API REST (OpenWeatherMap)\n\n"
            "Usa la librer√≠a requests para obtener el clima actual de una ciudad usando la API de OpenWeatherMap. Necesitar√°s una API key (gratuita al registrarse).\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import requests\n\n"
            "def obtener_clima(ciudad, api_key):\n"
            '    url = f"http://api.openweathermap.org/data/2.5/weather?q={ciudad}&appid={api_key}&units=metric"\n'
            "    respuesta = requests.get(url)\n"
            "    if respuesta.status_code == 200:\n"
            "        datos = respuesta.json()\n"
            '        temperatura = datos["main"]["temp"]\n'
            '        clima = datos["weather"][0]["description"]\n'
            '        return f"Clima en {ciudad}: {temperatura}¬∞C, {clima.capitalize()}"\n'
            "    else:\n"
            '        return "Error al obtener datos"\n\n'
            "# Ejemplo (reemplaza TU_API_KEY con tu clave):\n"
            'api_key = "TU_API_KEY"\n'
            'print(obtener_clima("Madrid", api_key))  # Ej: "Clima en Madrid: 18¬∞C, Nubes dispersas"\n'
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- API REST: Uso de endpoints y par√°metros en la URL.\n"
            "- JSON: Los datos de respuesta se parsean como diccionario.\n"
        ),

        (
            "ejercicio48",
            "# Ejercicio 48: An√°lisis de datos con Pandas\n\n"
            "Carga un dataset desde un archivo CSV (ej: iris.csv) y muestra:\n"
            "- Promedio de longitud de p√©talos por especie.\n"
            "- M√°ximo valor de ancho de s√©palos.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import pandas as pd\n\n"
            "# Descargar el dataset desde la URL\n"
            'url = "https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv"\n'
            "datos = pd.read_csv(url)\n\n"
            "# Promedio de longitud de p√©talos por especie\n"
            'promedio = datos.groupby("species")["petal_length"].mean()\n'
            'print("Promedio por especie:\n", promedio)\n\n'
            "# M√°ximo ancho de s√©palos\n"
            'max_ancho = datos["sepal_width"].max()\n'
            'print("M√°ximo ancho de s√©palos:", max_ancho)\n'
            "```\n"
            "Salida:\n"
            "```\n"
            "Promedio por especie:\n"
            " species\n"
            "setosa        1.464\n"
            "versicolor    4.260\n"
            "virginica     5.552\n\n"
            "M√°ximo ancho de s√©palos: 4.4\n"
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Pandas: Librer√≠a clave para an√°lisis de datos.\n"
            "- groupby() agrupa datos por categor√≠as.\n"
        ),

        (
            "ejercicio49",
            "# Ejercicio 49: Concurrencia con asyncio\n\n"
            "Crea dos tareas as√≠ncronas que impriman n√∫meros del 1-5 y letras A-E con delays de 1 segundo.\n"
            "\n"
            "### Soluci√≥n\n"
            "```\n"
            "import asyncio\n\n"
            "async def imprimir_numeros():\n"
            "    for i in range(1, 6):\n"
            "        print(i)\n"
            "        await asyncio.sleep(1)\n\n"
            "async def imprimir_letras():\n"
            '    for letra in "ABCDE":\n'
            "        print(letra)\n"
            "        await asyncio.sleep(1)\n\n"
            "async def main():\n"
            "    await asyncio.gather(imprimir_numeros(), imprimir_letras())\n\n"
            "asyncio.run(main())\n"
            "```\n"
            "\n"
            "**Explicaci√≥n**\n"
            "- Asyncio: Maneja concurrencia con corrutinas y await.\n"
            "- Salida: N√∫meros y letras se mezclan cada segundo.\n"
        ),

        (
            "ejercicio50",
            "# in progress"
        ),



    ]

    for prompt, response in prompts_responses:
        add_or_update_predefined_prompt(prompt, response)