from model import PythonDB

def add_or_update_predefined_prompt(prompt, response):
    try:
        # Verificar si el prompt ya existe
        existing_entry = PythonDB.get_by_prompt(prompt)
        if existing_entry:
            # Si el prompt existe, actualizar la respuesta
            existing_entry.response = response
            existing_entry.save()
            print(f"Prompt existente actualizado: {prompt} -> {response}")
        else:
            # Si el prompt no existe, crear una nueva entrada
            new_entry = PythonDB(prompt=prompt, response=response)
            new_entry.save()
            print(f"Nuevo prompt predefinido agregado: {prompt} -> {response}")
    except Exception as e:
        print(f"Error al agregar o actualizar el prompt predefinido: {e}")

if __name__ == "__main__":
    # Ejemplo de uso
    prompt = "¿Qué es una base de datos?"
    response = "Una base de datos es una colección organizada de datos, generalmente almacenados y accesibles electrónicamente desde un sistema informático."

    add_or_update_predefined_prompt(prompt, response)
    
    # Agregar más prompts predefinidos según sea necesario
    prompts_responses = [

        (
            "ejercicio1",
            "# Ejercicio de python \n\n"
            "### Contador de palabras en una frase  \n\n"
            "Escribe un programa en `Python` que solicite al usuario una frase y devuelva el número de palabras que contiene.  \n"
            "\n"
            "**Requisitos:**  \n"
            "1. Solicitar al usuario que ingrese una frase.  \n"
            "2. Contar cuántas palabras tiene la frase.  \n"
            "3. Imprimir el resultado en pantalla.  \n"
            "4. Ignorar espacios en blanco extra al inicio o al final de la frase.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "Ingrese una frase: Hola, este es un ejercicio de Python.\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "La frase tiene 7 palabras.\n"
            "```\n"
            "\n"
            "### Solución:\n"
            "```\n\n"
            "# Solicitar al usuario que ingrese una frase\n\n"
            "frase = input('Ingrese una frase: ').strip()\n"
            "\n"
            "# Dividir la frase en palabras usando split() y contar la cantidad de palabras\n\n"
            "num_palabras = len(frase.split())\n"
            "\n"
            "# Mostrar el resultado\n\n"
            "print(f'La frase tiene {num_palabras} palabras.')\n"
            "```\n"
            "\n"
            "Este ejercicio te ayuda a practicar el uso de `input()`, manipulación de cadenas y la función `split()`. 🚀  \n"
            "\n"
            "Si quieres seguir con mas ejercicios el siguiente es ejercicio2. Un Saludo 😊\n"
        ),


        (

            "ejercicio2",
            "# Ejercicio: Números faltantes en una lista  \n\n"
            "Dada una lista de números enteros del 1 al N en orden aleatorio, donde falta exactamente un número, escribe un programa en Python que encuentre el número faltante.  \n"
            "\n"
            "### Requisitos:\n"
            "1. La lista contendrá números únicos dentro del rango de 1 a N.  \n"
            "2. El programa debe identificar cuál número falta.  \n"
            "3. La solución debe ser eficiente en términos de tiempo de ejecución.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 4, 5]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "El número faltante es: 3\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "```\n\n"
            "def encontrar_faltante(numeros):\n\n"
            "    n = len(numeros) + 1  # Como falta un número, el total debe ser len(numeros) + 1\n\n"
            "    suma_esperada = n * (n + 1) // 2  # Suma de los primeros N números (fórmula matemática)\n\n"
            "    suma_actual = sum(numeros)  # Suma de los números en la lista\n\n"
            "    return suma_esperada - suma_actual  # El número que falta\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 4, 5]\n\n"
            "faltante = encontrar_faltante(numeros)\n\n"
            "print(f'El número faltante es: {faltante}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "- Se usa la fórmula de la **suma de los primeros N números**:  \n\n"
            "```\n\n"
            "                       N x ( N + 1)     \n"
            " Suma =       ---------------------------------\n"
            "                             2\n"
            "```\n"
            "\n"
            "- Restamos la suma de la lista dada de la suma esperada, obteniendo así el número faltante.  \n\n"
            "- Esta solución tiene una `complejidad O(n)`, lo que la hace eficiente.  \n"
            "\n"
            "Este tipo de ejercicios son muy comunes en pruebas técnicas. Si necesitas más variaciones o dificultad extra, sigue con ejercicio3 =) 🚀\n"
        ),

        (
            "ejercicio3",
            "# Ejercicio: Primer carácter no repetido en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el primer carácter que no se repite y devuelve su índice. Si todos los caracteres se repiten, devuelve `-1`.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. El programa debe recibir una cadena de caracteres.  \n"
            "2. Debe encontrar el primer carácter único (que aparece solo una vez).  \n"
            "3. Debe devolver el índice de ese carácter o `-1` si no hay caracteres únicos.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'abacabad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            'El primer carácter no repetido es "c" en el índice 3.\n'
            "```\n"
            "\n"
            "**Ejemplo con todos repetidos:**  \n"
            "```\n\n"
            "texto = 'aabbcc'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "No hay caracteres únicos.\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "\n"
            "```\n\n"
            "def primer_no_repetido(texto):\n\n"
            "    conteo = {}  # Diccionario para contar la frecuencia de cada carácter\n"
            "\n"
            "    # Contar ocurrencias de cada carácter\n\n"
            "    for letra in texto:\n\n"
            "        conteo[letra] = conteo.get(letra, 0) + 1\n"
            "\n"
            "    # Buscar el primer carácter con una sola ocurrencia\n\n"
            "    for i, letra in enumerate(texto):\n\n"
            "        if conteo[letra] == 1:\n\n"
            "            return i  # Retorna el índice del primer carácter único\n"
            "    \n"
            "    return -1  # Si no hay caracteres únicos\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'abacabad'\n\n"
            "indice = primer_no_repetido(texto)\n"
            "\n"
            "if indice != -1:\n\n"
            "    print(f'El primer carácter no repetido es '{texto[indice]}' en el índice {indice}.')\n\n"
            "else:\n\n"
            "    print('No hay caracteres únicos.')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "1. **Primer paso:** Se usa un diccionario (`conteo`) para contar la frecuencia de cada letra en la cadena.  \n\n"
            "2. **Segundo paso:** Se recorre nuevamente la cadena y se devuelve el índice del primer carácter que aparece solo una vez.  \n\n"
            "3. **Complejidad:** Esta solución tiene **O(n)** de complejidad, ya que se recorren los datos dos veces como máximo.  \n"
            "\n"
            "Este ejercicio es útil para evaluar habilidades en manipulación de cadenas y estructuras de datos como diccionarios.  \n"
            "\n"
            "Si quieres otra variante o más desafíos, sigue con ejercicio4 🚀\n"
        ),

        (
            "ejercicio4",
            "# Ejercicio: Rotar una lista a la derecha  \n"
            "\n"
            "Dada una lista de números enteros y un número `k`, escribe un programa en Python que rote la lista `k` posiciones a la derecha.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de números y un número `k`.  \n"
            "2. Mover los elementos `k` posiciones hacia la derecha.  \n"
            "3. Si `k` es mayor que el tamaño de la lista, usar `k % len(lista)`.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [4, 5, 1, 2, 3]\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista está vacía, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tamaño de la lista\n\n"
            "    return lista[-k:] + lista[:-k]  # Tomar los últimos k elementos y colocarlos al inicio\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k)}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "1. **Controlamos el caso de una lista vacía** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Dividimos la lista en dos partes**:  \n\n"
            "   - `lista[-k:]` obtiene los últimos `k` elementos.  \n\n"
            "   - `lista[:-k]` obtiene los elementos restantes.  \n\n"
            "   - Se concatenan para formar la nueva lista rotada.  \n\n"
            "4. **Eficiencia:**  \n\n"
            "   - Esta solución tiene una complejidad de **O(n)**, ya que solo se realizan operaciones de división y concatenación en la lista.  \n"
            "\n"
            "Este tipo de ejercicio es útil para evaluar la manipulación de listas y la optimización de algoritmos.  \n"
            "\n"
            "¿Quieres otro más diferente o con más dificultad? si no recuerdas comandos pon `help`🚀\n"
        ),

        (
            "ejercicio5",
            "# Ejercicio: Rotar una lista en ambas direcciones  \n"
            "\n"
            "Dada una lista de números enteros, un número `k` y una dirección (`'derecha'` o `'izquierda'`), escribe un programa en Python que rote la lista `k` posiciones en la dirección indicada.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de números, un número `k` y una dirección (`'derecha'` o `'izquierda'`).\n"
            "2. Mover los elementos `k` posiciones en la dirección especificada.\n"
            "3. Si `k` es mayor que el tamaño de la lista, usar `k % len(lista)`.\n"
            "4. Si la dirección no es válida, mostrar un mensaje de error.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista está vacía, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tamaño de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        return lista[-k:] + lista[:-k]  # Mover k posiciones a la derecha\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        return lista[k:] + lista[:k]  # Mover k posiciones a la izquierda\n\n"
            "    else:\n\n"
            "        raise ValueError('Dirección inválida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k, direccion)}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "1. **Manejamos listas vacías** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Rotamos según la dirección:**  \n\n"
            "   - Si es `'derecha'`, usamos `lista[-k:] + lista[:-k]`.  \n\n"
            "   - Si es `'izquierda'`, usamos `lista[k:] + lista[:k]`.  \n\n"
            "4. **Agregamos manejo de errores** con `raise ValueError` para evitar direcciones inválidas.  \n\n"
            "5. **Eficiencia:**  \n\n"
            "   - La solución sigue siendo **O(n)**, lo cual es óptimo para este problema.  \n"
            "\n"
            "Este nivel de dificultad evalúa la capacidad del candidato para manejar parámetros adicionales, excepciones y lógica condicional.  \n"
            "\n"
            "¿Quieres complicarlo aún más? Podemos hacerlo **en tiempo constante O(1)** usando una estrategia diferente. 🚀\n"
            "\n"
            "`Te espero en el siguiente =)`"
        ), 

        (
            "ejercicio6",
            "# Ejercicio: Rotar una lista en O(1) sin modificarla**  \n"
            "\n"
            "Dada una lista de números enteros, un número `k` y una dirección (`'derecha'` o `'izquierda'`), escribe un programa en Python que realice la rotación sin modificar la lista original y en tiempo **O(1)** de acceso.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de números, un número `k` y una dirección (`'derecha'` o `'izquierda'`).\n"
            "2. Lograr la rotación sin crear una copia completa de la lista ni usar operaciones costosas de slicing.\n"
            "3. La solución debe permitir iterar sobre la lista rotada en tiempo **O(1)**.\n"
            "4. Si `k` es mayor que el tamaño de la lista, usar `k % len(lista)`. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "\n"
            "```\n\n"
            "def iterador_rotado(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return iter([])  # Devolver un iterador vacío si la lista está vacía\n"
            "\n"
            "    n = len(lista)\n\n"
            "    k = k % n  # Asegurar que k no sea mayor que el tamaño de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        inicio = n - k\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        inicio = k\n\n"
            "    else:\n\n"
            "        raise ValueError('Dirección inválida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "    return (lista[(inicio + i) % n] for i in range(n))  # Generador en O(1)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {list(iterador_rotado(numeros, k, direccion))}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "1. **No modificamos la lista original** ni hacemos slicing.  \n\n"
            "2. **Usamos índices calculados** para acceder a los elementos en el nuevo orden sin copiar la lista.  \n\n"
            "3. **Manejamos `k > len(lista)`** con `k % n`.  \n\n"
            "4. **La rotación se logra con un generador**, permitiendo iterar sobre la lista en **O(1)** sin ocupar más memoria.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "✅ **Tiempo de acceso O(1)** porque solo cambiamos los índices.  \n\n"
            "✅ **Espacio O(1)** porque usamos un generador en lugar de copiar la lista.  \n"
            "\n"
            "Este tipo de problema es útil en pruebas técnicas cuando se evalúa eficiencia y manipulación de iteradores. 🚀  \n"
            "\n"
            "Si quieres un desafío aún más complicado, dime. 🔥\n"
        ),

        (
            "ejercicio7",
            '# Ejercicio: Subarray de suma máxima (Kadane"s Algorithm)  \n'
            "\n"
            "Dada una lista de números enteros (positivos y negativos), encuentra el **subarray contiguo** con la **suma más alta** y devuelve esa suma.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de números enteros.  \n"
            "2. Identificar el subarray contiguo cuya suma es la máxima posible.\n"
            "3. La solución debe ser **O(n)** (lineal) en tiempo de ejecución.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Suma máxima del subarray: 6  # (Subarray: [4, -1, 2, 1])\n"
            "```\n"
            "\n"
            '### Solución (Kadane"s Algorithm - O(n))  \n'
            "\n"
            "```\n\n"
            "def max_subarray_suma(nums):\n\n"
            "    if not nums:\n\n"
            "        return 0  # Si la lista está vacía, la suma es 0\n"
            "    \n"
            "    max_actual = max_global = nums[0]  # Inicializamos con el primer elemento\n"
            "\n"
            "    for num in nums[1:]:\n\n"
            "        max_actual = max(num, max_actual + num)  # Máximo entre el número actual y seguir el subarray\n\n"
            "        max_global = max(max_global, max_actual)  # Guardamos el máximo global encontrado\n"
            "    \n"
            "    return max_global\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n"
            "print(f'Suma máxima del subarray: {max_subarray_suma(numeros)}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n"
            "1. **Se usa una estrategia de programación dinámica:**  \n"
            "   - `max_actual` almacena la mejor suma encontrada hasta el momento.  \n"
            "   - `max_global` almacena la mejor suma global de cualquier subarray encontrado.  \n\n"
            "2. **En cada iteración:**  \n\n"
            "   - `max_actual` decide si continuar con la suma actual o reiniciar con el número actual.\n"
            "   - `max_global` se actualiza si `max_actual` es mayor.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n)**: Se recorre la lista una sola vez.  \n"
            "   - **Espacio O(1)**: Solo usamos variables auxiliares, sin estructuras extra.  \n"
            "\n"
            "Este ejercicio es un clásico en pruebas técnicas para evaluar comprensión de **programación dinámica** y optimización de algoritmos.  \n"

        ),

        (
            "ejercicio8",
            "# Ejercicio: Palíndromo más largo en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el **substring palindrómico más largo** dentro de ella.  \n"
            "\n"
            "### Requisitos:\n"
            "1. Recibir una cadena de texto.  \n"
            "2. Identificar el substring más largo que sea un palíndromo.  \n"
            "3. La solución debe ser **eficiente (O(n²) o mejor si es posible).**  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'babad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Palíndromo más largo: 'bab'  # o 'aba'\n"
            "```\n"
            "\n"
            "### Solución (Expandiendo desde el centro - O(n²))  \n"
            "\n"
            "```\n\n"
            "def palindromo_mas_largo(s):\n\n"
            "    if not s:\n\n"
            "        return ''\n"
            "\n"
            "    def expandir_desde_centro(izq, der):\n\n"
            "        while izq >= 0 and der < len(s) and s[izq] == s[der]:\n\n"
            "            izq -= 1\n\n"
            "            der += 1\n\n"
            "        return s[izq + 1:der]  # Devolvemos la subcadena palindrómica encontrada\n"
            "\n"
            "    mejor_palindromo = ''\n"
            "\n"
            "    for i in range(len(s)):\n\n"
            "        # Expandir para palíndromos de longitud impar (ej. 'aba')\n\n"
            "        palindromo1 = expandir_desde_centro(i, i)\n\n"
            "        # Expandir para palíndromos de longitud par (ej. 'abba')\n\n"
            "        palindromo2 = expandir_desde_centro(i, i + 1)\n"
            "\n"
            "        # Guardar el más largo encontrado hasta ahora\n\n"
            "        if len(palindromo1) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo1\n\n"
            "        if len(palindromo2) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo2\n"
            "\n"
            "    return mejor_palindromo\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'babad'\n\n"
            "print(f'Palíndromo más largo: {palindromo_mas_largo(texto)}')\n"
            "```\n"
            "\n"
            "**Explicación:**  \n"
            "1. **Expansión desde el centro:**  \n"
            "   - Tomamos cada letra como un centro potencial.  \n"
            "   - Expandimos a la izquierda y derecha mientras los caracteres sean iguales.  \n"
            "   - Verificamos tanto para **longitudes impares ('aba')** como **pares ('abba')**.  \n\n"
            "2. **Guardamos el más largo encontrado:**  \n"
            "   - Se comparan los resultados de cada expansión.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n²)**: Revisamos `n` posiciones y expandimos en `n` en el peor caso.  \n"
            "   - **Espacio O(1)**: No usamos estructuras adicionales.  \n"

        ),

        (
            "ejercicio9",
            "# Ejercicio: FizzBuzz Modificado  \n"
            "\n"
            "El clásico problema de **FizzBuzz** se usa mucho en pruebas técnicas, pero vamos a darle un giro más interesante:  \n"
            "\n"
            "### Instrucciones:  \n"
            "Escribe un programa que recorra los números del 1 al `N` e imprima:\n"
            "- `'Fizz'` si el número es múltiplo de 3.\n"
            "- `'Buzz'` si el número es múltiplo de 5. \n"
            "- `'FizzBuzz'` si el número es múltiplo de 3 y 5.\n"
            "- **Si el número es primo**, imprimir `'Prime'`, independientemente de si es múltiplo de 3 o 5. \n"
            "- En cualquier otro caso, imprimir el número. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "N = 20\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "1\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "8\n\n"
            "Fizz\n\n"
            "Buzz\n\n"
            "11\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "14\n\n"
            "FizzBuzz\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n"
            "```\n"
            "\n"
            "### Solución:  \n"
            "\n"
            "```\n\n"
            "def es_primo(num):\n\n"
            "    if num < 2:\n\n"
            "        return False\n\n"
            "    for i in range(2, int(num ** 0.5) + 1):  # Verificar divisibilidad hasta la raíz cuadrada\n\n"
            "        if num % i == 0:\n\n"
            "            return False\n\n"
            "    return True\n"
            "\n"
            "def fizzbuzz_modificado(N):\n\n"
            "    for i in range(1, N + 1):  \n\n"
            "        if es_primo(i):  # Si es primo, lo imprimimos directamente\n\n"
            "            print('Prime')\n\n"
            "        elif i % 3 == 0 and i % 5 == 0:\n\n"
            "            print('FizzBuzz')\n\n"
            "        elif i % 3 == 0:\n\n"
            "            print('Fizz')\n\n"
            "        elif i % 5 == 0:\n\n"
            "            print('Buzz')\n\n"
            "        else:\n\n"
            "            print(i)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "N = 20\n\n"
            "fizzbuzz_modificado(N)\n"
            "```\n"
            "\n"
            "**Explicación:**  \n\n"
            "1. **Usamos un `for` para recorrer los números de 1 a `N`**.  \n\n"
            "2. **Creamos una función `es_primo(num)`**:  \n\n"
            "   - Verifica si un número es primo comprobando divisibilidad hasta `√num`.  \n\n"
            "3. **Estructura condicional dentro del `for`**:  \n\n"
            "   - Primero comprobamos si es primo.  \n\n"
            "   - Luego aplicamos las reglas de FizzBuzz.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "✅ **Tiempo O(N√N)** por la verificación de primos (mejorable con la criba de Eratóstenes).  \n\n"
            "✅ **Uso de `for` de manera clara y estructurada**.  \n"
            "\n"
            "`Así se hace crack !`  🚀🔥\n"
        ),

        (
            "ejercicio10",
            "# Ejercicio: Anagramas  \n"
            "\n"
            "Dadas dos cadenas de texto, escribe una función en Python que determine si son **anagramas**.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Dos palabras son **anagramas** si tienen las mismas letras en distinta posición.  \n"
            "2. La comparación **no debe ser sensible a mayúsculas/minúsculas**.  \n"
            "3. Ignorar los espacios y caracteres especiales.  \n"
            "4. La solución debe ser **eficiente (O(n))**.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "Otro ejemplo:  \n"
            "```\n\n"
            "cadena1 = 'Hello'\n\n"
            "cadena2 = 'Olelh'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "### Solución (O(n))  \n"
            "\n"
            "```\n\n"
            "from collections import Counter\n\n"
            "import re\n"
            "\n"
            "def son_anagramas(cadena1, cadena2):\n\n"
            "    # Normalizar: convertir a minúsculas y eliminar caracteres que no sean letras\n\n"
            '    cadena1 = re.sub(r"[^a-z]", "", cadena1.lower())\n\n'
            '    cadena2 = re.sub(r"[^a-z]", "", cadena2.lower())\n'
            "\n"
            "    # Comparar las frecuencias de letras usando Counter\n\n"
            "    return Counter(cadena1) == Counter(cadena2)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n\n"
            "print(f'Son anagramas: {son_anagramas(cadena1, cadena2)}')\n"
            "```\n"
            "\n"
            "**Explicación:** \n"
            "1. **Normalización de cadenas:**  \n"
            "   - Convertimos a minúsculas (`lower()`).  \n"
            '   - Eliminamos espacios y caracteres especiales usando `re.sub(r"[^a-z]", "", texto)`.  \n\n'
            "2. **Comparación eficiente con `Counter` de `collections`**:  \n"
            "   - Cuenta la frecuencia de cada letra en ambas cadenas.  \n"
            "   - Si los `Counter` son iguales, las palabras son anagramas.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "✅ **Tiempo O(n)** (un solo recorrido para limpiar y otro para contar letras).  \n\n"
            "✅ **Espacio O(1)** (uso mínimo de memoria adicional).  \n"
            "\n"
            "Este ejercicio es muy común en pruebas técnicas para evaluar **manejo de cadenas, estructuras de datos y optimización**.  \n"
        ),      


    ]

    for prompt, response in prompts_responses:
        add_or_update_predefined_prompt(prompt, response)