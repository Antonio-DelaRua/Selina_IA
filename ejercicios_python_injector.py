from model import PythonDB

def add_or_update_predefined_prompt(prompt, response):
    try:
        # Verificar si el prompt ya existe
        existing_entry = PythonDB.get_by_prompt(prompt)
        if existing_entry:
            # Si el prompt existe, actualizar la respuesta
            existing_entry.response = response
            existing_entry.save()
            print(f"Prompt existente actualizado: {prompt} -> {response}")
        else:
            # Si el prompt no existe, crear una nueva entrada
            new_entry = PythonDB(prompt=prompt, response=response)
            new_entry.save()
            print(f"Nuevo prompt predefinido agregado: {prompt} -> {response}")
    except Exception as e:
        print(f"Error al agregar o actualizar el prompt predefinido: {e}")

if __name__ == "__main__":
    # Ejemplo de uso
    prompt = "¬øQu√© es una base de datos?"
    response = "Una base de datos es una colecci√≥n organizada de datos, generalmente almacenados y accesibles electr√≥nicamente desde un sistema inform√°tico."

    add_or_update_predefined_prompt(prompt, response)
    
    # Agregar m√°s prompts predefinidos seg√∫n sea necesario
    prompts_responses = [

        (
            "ejercicio1",
            "# Ejercicio de python \n\n"
            "### Contador de palabras en una frase  \n\n"
            "Escribe un programa en `Python` que solicite al usuario una frase y devuelva el n√∫mero de palabras que contiene.  \n"
            "\n"
            "**Requisitos:**  \n"
            "1. Solicitar al usuario que ingrese una frase.  \n"
            "2. Contar cu√°ntas palabras tiene la frase.  \n"
            "3. Imprimir el resultado en pantalla.  \n"
            "4. Ignorar espacios en blanco extra al inicio o al final de la frase.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "Ingrese una frase: Hola, este es un ejercicio de Python.\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "La frase tiene 7 palabras.\n"
            "```\n"
            "\n"
            "### Soluci√≥n:\n"
            "```\n\n"
            "# Solicitar al usuario que ingrese una frase\n\n"
            "frase = input('Ingrese una frase: ').strip()\n"
            "\n"
            "# Dividir la frase en palabras usando split() y contar la cantidad de palabras\n\n"
            "num_palabras = len(frase.split())\n"
            "\n"
            "# Mostrar el resultado\n\n"
            "print(f'La frase tiene {num_palabras} palabras.')\n"
            "```\n"
            "\n"
            "Este ejercicio te ayuda a practicar el uso de `input()`, manipulaci√≥n de cadenas y la funci√≥n `split()`. üöÄ  \n"
            "\n"
            "Si quieres seguir con mas ejercicios el siguiente es ejercicio2. Un Saludo üòä\n"
        ),


        (

            "ejercicio2",
            "# Ejercicio: N√∫meros faltantes en una lista  \n\n"
            "Dada una lista de n√∫meros enteros del 1 al N en orden aleatorio, donde falta exactamente un n√∫mero, escribe un programa en Python que encuentre el n√∫mero faltante.  \n"
            "\n"
            "### Requisitos:\n"
            "1. La lista contendr√° n√∫meros √∫nicos dentro del rango de 1 a N.  \n"
            "2. El programa debe identificar cu√°l n√∫mero falta.  \n"
            "3. La soluci√≥n debe ser eficiente en t√©rminos de tiempo de ejecuci√≥n.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 4, 5]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "El n√∫mero faltante es: 3\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "```\n\n"
            "def encontrar_faltante(numeros):\n\n"
            "    n = len(numeros) + 1  # Como falta un n√∫mero, el total debe ser len(numeros) + 1\n\n"
            "    suma_esperada = n * (n + 1) // 2  # Suma de los primeros N n√∫meros (f√≥rmula matem√°tica)\n\n"
            "    suma_actual = sum(numeros)  # Suma de los n√∫meros en la lista\n\n"
            "    return suma_esperada - suma_actual  # El n√∫mero que falta\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 4, 5]\n\n"
            "faltante = encontrar_faltante(numeros)\n\n"
            "print(f'El n√∫mero faltante es: {faltante}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "- Se usa la f√≥rmula de la **suma de los primeros N n√∫meros**:  \n\n"
            "```\n\n"
            "                       N x ( N + 1)     \n"
            " Suma =       ---------------------------------\n"
            "                             2\n"
            "```\n"
            "\n"
            "- Restamos la suma de la lista dada de la suma esperada, obteniendo as√≠ el n√∫mero faltante.  \n\n"
            "- Esta soluci√≥n tiene una `complejidad O(n)`, lo que la hace eficiente.  \n"
            "\n"
            "Este tipo de ejercicios son muy comunes en pruebas t√©cnicas. Si necesitas m√°s variaciones o dificultad extra, sigue con ejercicio3 =) üöÄ\n"
        ),

        (
            "ejercicio3",
            "# Ejercicio: Primer car√°cter no repetido en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el primer car√°cter que no se repite y devuelve su √≠ndice. Si todos los caracteres se repiten, devuelve `-1`.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. El programa debe recibir una cadena de caracteres.  \n"
            "2. Debe encontrar el primer car√°cter √∫nico (que aparece solo una vez).  \n"
            "3. Debe devolver el √≠ndice de ese car√°cter o `-1` si no hay caracteres √∫nicos.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'abacabad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            'El primer car√°cter no repetido es "c" en el √≠ndice 3.\n'
            "```\n"
            "\n"
            "**Ejemplo con todos repetidos:**  \n"
            "```\n\n"
            "texto = 'aabbcc'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "No hay caracteres √∫nicos.\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def primer_no_repetido(texto):\n\n"
            "    conteo = {}  # Diccionario para contar la frecuencia de cada car√°cter\n"
            "\n"
            "    # Contar ocurrencias de cada car√°cter\n\n"
            "    for letra in texto:\n\n"
            "        conteo[letra] = conteo.get(letra, 0) + 1\n"
            "\n"
            "    # Buscar el primer car√°cter con una sola ocurrencia\n\n"
            "    for i, letra in enumerate(texto):\n\n"
            "        if conteo[letra] == 1:\n\n"
            "            return i  # Retorna el √≠ndice del primer car√°cter √∫nico\n"
            "    \n"
            "    return -1  # Si no hay caracteres √∫nicos\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'abacabad'\n\n"
            "indice = primer_no_repetido(texto)\n"
            "\n"
            "if indice != -1:\n\n"
            "    print(f'El primer car√°cter no repetido es '{texto[indice]}' en el √≠ndice {indice}.')\n\n"
            "else:\n\n"
            "    print('No hay caracteres √∫nicos.')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Primer paso:** Se usa un diccionario (`conteo`) para contar la frecuencia de cada letra en la cadena.  \n\n"
            "2. **Segundo paso:** Se recorre nuevamente la cadena y se devuelve el √≠ndice del primer car√°cter que aparece solo una vez.  \n\n"
            "3. **Complejidad:** Esta soluci√≥n tiene **O(n)** de complejidad, ya que se recorren los datos dos veces como m√°ximo.  \n"
            "\n"
            "Este ejercicio es √∫til para evaluar habilidades en manipulaci√≥n de cadenas y estructuras de datos como diccionarios.  \n"
            "\n"
            "Si quieres otra variante o m√°s desaf√≠os, sigue con ejercicio4 üöÄ\n"
        ),

        (
            "ejercicio4",
            "# Ejercicio: Rotar una lista a la derecha  \n"
            "\n"
            "Dada una lista de n√∫meros enteros y un n√∫mero `k`, escribe un programa en Python que rote la lista `k` posiciones a la derecha.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros y un n√∫mero `k`.  \n"
            "2. Mover los elementos `k` posiciones hacia la derecha.  \n"
            "3. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [4, 5, 1, 2, 3]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista est√° vac√≠a, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tama√±o de la lista\n\n"
            "    return lista[-k:] + lista[:-k]  # Tomar los √∫ltimos k elementos y colocarlos al inicio\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Controlamos el caso de una lista vac√≠a** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Dividimos la lista en dos partes**:  \n\n"
            "   - `lista[-k:]` obtiene los √∫ltimos `k` elementos.  \n\n"
            "   - `lista[:-k]` obtiene los elementos restantes.  \n\n"
            "   - Se concatenan para formar la nueva lista rotada.  \n\n"
            "4. **Eficiencia:**  \n\n"
            "   - Esta soluci√≥n tiene una complejidad de **O(n)**, ya que solo se realizan operaciones de divisi√≥n y concatenaci√≥n en la lista.  \n"
            "\n"
            "Este tipo de ejercicio es √∫til para evaluar la manipulaci√≥n de listas y la optimizaci√≥n de algoritmos.  \n"
            "\n"
            "¬øQuieres otro m√°s diferente o con m√°s dificultad? si no recuerdas comandos pon `help`üöÄ\n"
        ),

        (
            "ejercicio5",
            "# Ejercicio: Rotar una lista en ambas direcciones  \n"
            "\n"
            "Dada una lista de n√∫meros enteros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`), escribe un programa en Python que rote la lista `k` posiciones en la direcci√≥n indicada.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`).\n"
            "2. Mover los elementos `k` posiciones en la direcci√≥n especificada.\n"
            "3. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`.\n"
            "4. Si la direcci√≥n no es v√°lida, mostrar un mensaje de error.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def rotar_lista(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return lista  # Si la lista est√° vac√≠a, devolverla sin cambios\n"
            "\n"
            "    k = k % len(lista)  # Asegurar que k no sea mayor que el tama√±o de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        return lista[-k:] + lista[:-k]  # Mover k posiciones a la derecha\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        return lista[k:] + lista[:k]  # Mover k posiciones a la izquierda\n\n"
            "    else:\n\n"
            "        raise ValueError('Direcci√≥n inv√°lida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {rotar_lista(numeros, k, direccion)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Manejamos listas vac√≠as** para evitar errores.  \n\n"
            "2. **Evitamos rotaciones innecesarias** con `k % len(lista)`.  \n\n"
            "3. **Rotamos seg√∫n la direcci√≥n:**  \n\n"
            "   - Si es `'derecha'`, usamos `lista[-k:] + lista[:-k]`.  \n\n"
            "   - Si es `'izquierda'`, usamos `lista[k:] + lista[:k]`.  \n\n"
            "4. **Agregamos manejo de errores** con `raise ValueError` para evitar direcciones inv√°lidas.  \n\n"
            "5. **Eficiencia:**  \n\n"
            "   - La soluci√≥n sigue siendo **O(n)**, lo cual es √≥ptimo para este problema.  \n"
            "\n"
            "Este nivel de dificultad eval√∫a la capacidad del candidato para manejar par√°metros adicionales, excepciones y l√≥gica condicional.  \n"
            "\n"
            "¬øQuieres complicarlo a√∫n m√°s? Podemos hacerlo **en tiempo constante O(1)** usando una estrategia diferente. üöÄ\n"
            "\n"
            "`Te espero en el siguiente =)`"
        ), 

        (
            "ejercicio6",
            "# Ejercicio: Rotar una lista en O(1) sin modificarla**  \n"
            "\n"
            "Dada una lista de n√∫meros enteros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`), escribe un programa en Python que realice la rotaci√≥n sin modificar la lista original y en tiempo **O(1)** de acceso.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros, un n√∫mero `k` y una direcci√≥n (`'derecha'` o `'izquierda'`).\n"
            "2. Lograr la rotaci√≥n sin crear una copia completa de la lista ni usar operaciones costosas de slicing.\n"
            "3. La soluci√≥n debe permitir iterar sobre la lista rotada en tiempo **O(1)**.\n"
            "4. Si `k` es mayor que el tama√±o de la lista, usar `k % len(lista)`. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [1, 2, 3, 4, 5]  \n\n"
            "k = 2  \n\n"
            "direccion = 'izquierda'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Lista rotada: [3, 4, 5, 1, 2]\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def iterador_rotado(lista, k, direccion='derecha'):\n\n"
            "    if not lista:\n\n"
            "        return iter([])  # Devolver un iterador vac√≠o si la lista est√° vac√≠a\n"
            "\n"
            "    n = len(lista)\n\n"
            "    k = k % n  # Asegurar que k no sea mayor que el tama√±o de la lista\n"
            "\n"
            "    if direccion == 'derecha':\n\n"
            "        inicio = n - k\n\n"
            "    elif direccion == 'izquierda':\n\n"
            "        inicio = k\n\n"
            "    else:\n\n"
            "        raise ValueError('Direcci√≥n inv√°lida. Usa 'derecha' o 'izquierda'.')\n"
            "\n"
            "    return (lista[(inicio + i) % n] for i in range(n))  # Generador en O(1)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [1, 2, 3, 4, 5]\n\n"
            "k = 2\n\n"
            "direccion = 'izquierda'\n"
            "\n"
            "print(f'Lista rotada: {list(iterador_rotado(numeros, k, direccion))}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **No modificamos la lista original** ni hacemos slicing.  \n\n"
            "2. **Usamos √≠ndices calculados** para acceder a los elementos en el nuevo orden sin copiar la lista.  \n\n"
            "3. **Manejamos `k > len(lista)`** con `k % n`.  \n\n"
            "4. **La rotaci√≥n se logra con un generador**, permitiendo iterar sobre la lista en **O(1)** sin ocupar m√°s memoria.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo de acceso O(1)** porque solo cambiamos los √≠ndices.  \n\n"
            "‚úÖ **Espacio O(1)** porque usamos un generador en lugar de copiar la lista.  \n"
            "\n"
            "Este tipo de problema es √∫til en pruebas t√©cnicas cuando se eval√∫a eficiencia y manipulaci√≥n de iteradores. üöÄ  \n"
            "\n"
            "Si quieres un desaf√≠o a√∫n m√°s complicado, dime. üî•\n"
        ),

        (
            "ejercicio7",
            '# Ejercicio: Subarray de suma m√°xima (Kadane"s Algorithm)  \n'
            "\n"
            "Dada una lista de n√∫meros enteros (positivos y negativos), encuentra el **subarray contiguo** con la **suma m√°s alta** y devuelve esa suma.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Recibir una lista de n√∫meros enteros.  \n"
            "2. Identificar el subarray contiguo cuya suma es la m√°xima posible.\n"
            "3. La soluci√≥n debe ser **O(n)** (lineal) en tiempo de ejecuci√≥n.\n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Suma m√°xima del subarray: 6  # (Subarray: [4, -1, 2, 1])\n"
            "```\n"
            "\n"
            '### Soluci√≥n (Kadane"s Algorithm - O(n))  \n'
            "\n"
            "```\n\n"
            "def max_subarray_suma(nums):\n\n"
            "    if not nums:\n\n"
            "        return 0  # Si la lista est√° vac√≠a, la suma es 0\n"
            "    \n"
            "    max_actual = max_global = nums[0]  # Inicializamos con el primer elemento\n"
            "\n"
            "    for num in nums[1:]:\n\n"
            "        max_actual = max(num, max_actual + num)  # M√°ximo entre el n√∫mero actual y seguir el subarray\n\n"
            "        max_global = max(max_global, max_actual)  # Guardamos el m√°ximo global encontrado\n"
            "    \n"
            "    return max_global\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "numeros = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n"
            "print(f'Suma m√°xima del subarray: {max_subarray_suma(numeros)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n"
            "1. **Se usa una estrategia de programaci√≥n din√°mica:**  \n"
            "   - `max_actual` almacena la mejor suma encontrada hasta el momento.  \n"
            "   - `max_global` almacena la mejor suma global de cualquier subarray encontrado.  \n\n"
            "2. **En cada iteraci√≥n:**  \n\n"
            "   - `max_actual` decide si continuar con la suma actual o reiniciar con el n√∫mero actual.\n"
            "   - `max_global` se actualiza si `max_actual` es mayor.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n)**: Se recorre la lista una sola vez.  \n"
            "   - **Espacio O(1)**: Solo usamos variables auxiliares, sin estructuras extra.  \n"
            "\n"
            "Este ejercicio es un cl√°sico en pruebas t√©cnicas para evaluar comprensi√≥n de **programaci√≥n din√°mica** y optimizaci√≥n de algoritmos.  \n"

        ),

        (
            "ejercicio8",
            "# Ejercicio: Pal√≠ndromo m√°s largo en una cadena  \n"
            "\n"
            "Dada una cadena de texto, encuentra el **substring palindr√≥mico m√°s largo** dentro de ella.  \n"
            "\n"
            "### Requisitos:\n"
            "1. Recibir una cadena de texto.  \n"
            "2. Identificar el substring m√°s largo que sea un pal√≠ndromo.  \n"
            "3. La soluci√≥n debe ser **eficiente (O(n¬≤) o mejor si es posible).**  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "texto = 'babad'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Pal√≠ndromo m√°s largo: 'bab'  # o 'aba'\n"
            "```\n"
            "\n"
            "### Soluci√≥n (Expandiendo desde el centro - O(n¬≤))  \n"
            "\n"
            "```\n\n"
            "def palindromo_mas_largo(s):\n\n"
            "    if not s:\n\n"
            "        return ''\n"
            "\n"
            "    def expandir_desde_centro(izq, der):\n\n"
            "        while izq >= 0 and der < len(s) and s[izq] == s[der]:\n\n"
            "            izq -= 1\n\n"
            "            der += 1\n\n"
            "        return s[izq + 1:der]  # Devolvemos la subcadena palindr√≥mica encontrada\n"
            "\n"
            "    mejor_palindromo = ''\n"
            "\n"
            "    for i in range(len(s)):\n\n"
            "        # Expandir para pal√≠ndromos de longitud impar (ej. 'aba')\n\n"
            "        palindromo1 = expandir_desde_centro(i, i)\n\n"
            "        # Expandir para pal√≠ndromos de longitud par (ej. 'abba')\n\n"
            "        palindromo2 = expandir_desde_centro(i, i + 1)\n"
            "\n"
            "        # Guardar el m√°s largo encontrado hasta ahora\n\n"
            "        if len(palindromo1) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo1\n\n"
            "        if len(palindromo2) > len(mejor_palindromo):\n\n"
            "            mejor_palindromo = palindromo2\n"
            "\n"
            "    return mejor_palindromo\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "texto = 'babad'\n\n"
            "print(f'Pal√≠ndromo m√°s largo: {palindromo_mas_largo(texto)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n"
            "1. **Expansi√≥n desde el centro:**  \n"
            "   - Tomamos cada letra como un centro potencial.  \n"
            "   - Expandimos a la izquierda y derecha mientras los caracteres sean iguales.  \n"
            "   - Verificamos tanto para **longitudes impares ('aba')** como **pares ('abba')**.  \n\n"
            "2. **Guardamos el m√°s largo encontrado:**  \n"
            "   - Se comparan los resultados de cada expansi√≥n.  \n\n"
            "3. **Eficiencia:**  \n"
            "   - **Tiempo O(n¬≤)**: Revisamos `n` posiciones y expandimos en `n` en el peor caso.  \n"
            "   - **Espacio O(1)**: No usamos estructuras adicionales.  \n"

        ),

        (
            "ejercicio9",
            "# Ejercicio: FizzBuzz Modificado  \n"
            "\n"
            "El cl√°sico problema de **FizzBuzz** se usa mucho en pruebas t√©cnicas, pero vamos a darle un giro m√°s interesante:  \n"
            "\n"
            "### Instrucciones:  \n"
            "Escribe un programa que recorra los n√∫meros del 1 al `N` e imprima:\n"
            "- `'Fizz'` si el n√∫mero es m√∫ltiplo de 3.\n"
            "- `'Buzz'` si el n√∫mero es m√∫ltiplo de 5. \n"
            "- `'FizzBuzz'` si el n√∫mero es m√∫ltiplo de 3 y 5.\n"
            "- **Si el n√∫mero es primo**, imprimir `'Prime'`, independientemente de si es m√∫ltiplo de 3 o 5. \n"
            "- En cualquier otro caso, imprimir el n√∫mero. \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "N = 20\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "1\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "8\n\n"
            "Fizz\n\n"
            "Buzz\n\n"
            "11\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "14\n\n"
            "FizzBuzz\n\n"
            "Prime\n\n"
            "Fizz\n\n"
            "Prime\n\n"
            "Buzz\n\n"
            "Fizz\n"
            "```\n"
            "\n"
            "### Soluci√≥n:  \n"
            "\n"
            "```\n\n"
            "def es_primo(num):\n\n"
            "    if num < 2:\n\n"
            "        return False\n\n"
            "    for i in range(2, int(num ** 0.5) + 1):  # Verificar divisibilidad hasta la ra√≠z cuadrada\n\n"
            "        if num % i == 0:\n\n"
            "            return False\n\n"
            "    return True\n"
            "\n"
            "def fizzbuzz_modificado(N):\n\n"
            "    for i in range(1, N + 1):  \n\n"
            "        if es_primo(i):  # Si es primo, lo imprimimos directamente\n\n"
            "            print('Prime')\n\n"
            "        elif i % 3 == 0 and i % 5 == 0:\n\n"
            "            print('FizzBuzz')\n\n"
            "        elif i % 3 == 0:\n\n"
            "            print('Fizz')\n\n"
            "        elif i % 5 == 0:\n\n"
            "            print('Buzz')\n\n"
            "        else:\n\n"
            "            print(i)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "N = 20\n\n"
            "fizzbuzz_modificado(N)\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:**  \n\n"
            "1. **Usamos un `for` para recorrer los n√∫meros de 1 a `N`**.  \n\n"
            "2. **Creamos una funci√≥n `es_primo(num)`**:  \n\n"
            "   - Verifica si un n√∫mero es primo comprobando divisibilidad hasta `‚àönum`.  \n\n"
            "3. **Estructura condicional dentro del `for`**:  \n\n"
            "   - Primero comprobamos si es primo.  \n\n"
            "   - Luego aplicamos las reglas de FizzBuzz.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo O(N‚àöN)** por la verificaci√≥n de primos (mejorable con la criba de Erat√≥stenes).  \n\n"
            "‚úÖ **Uso de `for` de manera clara y estructurada**.  \n"
            "\n"
            "`As√≠ se hace crack !`  üöÄüî•\n"
        ),

        (
            "ejercicio10",
            "# Ejercicio: Anagramas  \n"
            "\n"
            "Dadas dos cadenas de texto, escribe una funci√≥n en Python que determine si son **anagramas**.  \n"
            "\n"
            "### Requisitos:  \n"
            "1. Dos palabras son **anagramas** si tienen las mismas letras en distinta posici√≥n.  \n"
            "2. La comparaci√≥n **no debe ser sensible a may√∫sculas/min√∫sculas**.  \n"
            "3. Ignorar los espacios y caracteres especiales.  \n"
            "4. La soluci√≥n debe ser **eficiente (O(n))**.  \n"
            "\n"
            "**Ejemplo de entrada:**  \n"
            "```\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "Otro ejemplo:  \n"
            "```\n\n"
            "cadena1 = 'Hello'\n\n"
            "cadena2 = 'Olelh'\n"
            "```\n\n"
            "**Salida esperada:**  \n"
            "```\n\n"
            "Son anagramas: True\n"
            "```\n"
            "\n"
            "### Soluci√≥n (O(n))  \n"
            "\n"
            "```\n\n"
            "from collections import Counter\n\n"
            "import re\n"
            "\n"
            "def son_anagramas(cadena1, cadena2):\n\n"
            "    # Normalizar: convertir a min√∫sculas y eliminar caracteres que no sean letras\n\n"
            '    cadena1 = re.sub(r"[^a-z]", "", cadena1.lower())\n\n'
            '    cadena2 = re.sub(r"[^a-z]", "", cadena2.lower())\n'
            "\n"
            "    # Comparar las frecuencias de letras usando Counter\n\n"
            "    return Counter(cadena1) == Counter(cadena2)\n"
            "\n"
            "# Ejemplo de uso\n\n"
            "cadena1 = 'Listen'\n\n"
            "cadena2 = 'Silent'\n\n"
            "print(f'Son anagramas: {son_anagramas(cadena1, cadena2)}')\n"
            "```\n"
            "\n"
            "**Explicaci√≥n:** \n"
            "1. **Normalizaci√≥n de cadenas:**  \n"
            "   - Convertimos a min√∫sculas (`lower()`).  \n"
            '   - Eliminamos espacios y caracteres especiales usando `re.sub(r"[^a-z]", "", texto)`.  \n\n'
            "2. **Comparaci√≥n eficiente con `Counter` de `collections`**:  \n"
            "   - Cuenta la frecuencia de cada letra en ambas cadenas.  \n"
            "   - Si los `Counter` son iguales, las palabras son anagramas.  \n"
            "\n"
            "**Eficiencia:**  \n\n"
            "‚úÖ **Tiempo O(n)** (un solo recorrido para limpiar y otro para contar letras).  \n\n"
            "‚úÖ **Espacio O(1)** (uso m√≠nimo de memoria adicional).  \n"
            "\n"
            "Este ejercicio es muy com√∫n en pruebas t√©cnicas para evaluar **manejo de cadenas, estructuras de datos y optimizaci√≥n**.  \n"
        ),      


    ]

    for prompt, response in prompts_responses:
        add_or_update_predefined_prompt(prompt, response)