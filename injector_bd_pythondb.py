from model import PythonDB

def add_or_update_predefined_prompt(prompt, response):
    try:
        # Verificar si el prompt ya existe
        existing_entry = PythonDB.get_by_prompt(prompt)
        if existing_entry:
            # Si el prompt existe, actualizar la respuesta
            existing_entry.response = response
            existing_entry.save()
            print(f"Prompt existente actualizado: {prompt} -> {response}")
        else:
            # Si el prompt no existe, crear una nueva entrada
            new_entry = PythonDB(prompt=prompt, response=response)
            new_entry.save()
            print(f"Nuevo prompt predefinido agregado: {prompt} -> {response}")
    except Exception as e:
        print(f"Error al agregar o actualizar el prompt predefinido: {e}")

if __name__ == "__main__":
    # Ejemplo de uso
    prompt = "¿Qué es una base de datos?"
    response = "Una base de datos es una colección organizada de datos, generalmente almacenados y accesibles electrónicamente desde un sistema informático."

    add_or_update_predefined_prompt(prompt, response)
    
    # Agregar más prompts predefinidos según sea necesario
    prompts_responses = [

            (
                "hola",
                "Pulsa ESC para destruir el mundo"
            ),


            (
        "como instalar python en windows?",
        "## Para instalar Python en Windows, sigue estos pasos:\n\n"
        "**Descarga Python**\n"
        "- Ve al sitio web oficial de Python: https://www.python.org/downloads/ \n\n"
        "**Instala Python**\n"
        "- Abre el archivo descargado (python-xxx.exe).\n"
        "- IMPORTANTE: Marca la casilla 'Add Python to PATH' (Agregar Python al PATH).\n"
        "- Haz clic en 'Install Now' y espera a que termine la instalación.\n\n"
        "**Verifica la instalación**\n"
        "- Presiona Win + R, escribe cmd y presiona Enter.\n"
        "```\npython --version\n"
        "or python -V\n```\n\n"
        "**(OPCIONAL) Instalar pip y probarlo**\n"
        "```\npip --version\n```\n"
        "```\npip install numpy pandas\n```"
    ),

            (
        "fundamentos de python",
        "**Sintaxis y Semántica Básica:**\n\n"
        "- **Tipos de datos básicos:** [int]  |  [float]  | [str]  |  [bool] \n\n"
        "- **Operadores:** [aritméticos]  |  [comparativos]  |  [lógicos]\n\n"
        "- **Estructuras de control:** [if]  |  [for]  |  [while]\n"
    ),

 (
        "tipos de datos basicos",
        "Python es un lenguaje de programación de alto nivel, interpretado y de tipado dinámico.\n"
        "Esto significa que no necesitas declarar el tipo de una variable antes de usarla. A continuación,\n"
        "se describen los tipos de datos básicos más importantes en Python:\n\n"
        "**- Tipos de Datos Numéricos **\n\n"
        "**Enteros (int):**\n"
        "```\na = 5\nb = -3\nc = 0\n```\n"
        "**Números de Punto Flotante (float): **\n"
        "```\nx = 3.14\ny = -0.5\nz = 2.0\n```\n"
        "**Números Complejos (complex):**\n"
        "```\nnum1 = 2 + 3j\nnum2 = -1j\nnum3 = 3.5 + 0j\n```\n"
        "**- Cadenas de Texto (str) **\n"
        "Las cadenas de texto son secuencias de caracteres encerradas entre comillas simples (')\n"
        "o dobles comillas. Las cadenas son inmutables, lo que significa que no se pueden cambiar una vez creadas.\n"
        "```\nsaludo = \"Hola, mundo!\"\nnombre = 'Antonio'\n```\n"
        "**Booleanos (bool) **\n"
        "Los valores booleanos representan verdad (True) o falsedad (False). Son muy útiles\n"
        "en estructuras de control y comparaciones.\n"
        "```\nes_mayor = True\nes_menor = False\n```\n"
        "**Tipos de Datos de Secuencia **\n\n"
        "**Listas (list): **\n"
        "Son colecciones ordenadas y mutables de elementos, que pueden ser de diferentes tipos.\n"
        "```\nnumeros = [1, 2, 3, 4, 5]\nmezcla = [1, 'dos', 3.0, True]\n```\n"
        "**Tuplas (tuple): **\n"
        "Son colecciones ordenadas e inmutables de elementos. Al ser inmutables, son más rápidas y seguras.\n"
        "```\ncoordenadas = (10, 20)\ndatos = ('Antonio', 30, 'España')\n```\n"
        "**Conjuntos (set): **\n"
        "Son colecciones desordenadas de elementos únicos. Son útiles para operaciones\n"
        "de conjunto como uniones e intersecciones.\n"
        "```\nfrutas = {\"manzana\", \"naranja\", \"plátano\"}\n```\n"
        "**Diccionarios (dict): **\n"
        "Son colecciones desordenadas de pares clave-valor. Permiten un acceso rápido a los valores asociados a una clave.\n"
        "```\npersona = {\"nombre\": \"Antonio\", \"edad\": 30, \"ciudad\": \"Madrid\"}\n```\n\n"
        "**Ejemplos de Uso**\n"
        "**Enteros:** \n"
        "a = 10\n"
        "b = -5\n\n"
        "**Flotantes:**\n"
        "pi = 3.14159\n"
        "gravedad = 9.8\n\n"
        "**Complejos:** \n"
        "c = 1 + 2j\n\n"
        "**Cadenas de texto:**\n"
        'saludo = "¡Hola, mundo!"\n'
        "nombre = 'Antonio'\n\n"
        "**Booleanos:**\n"
        "es_adulto = True\n"
        "es_estudiante = False\n\n"
        "**Listas:** \n"
        "numeros = [1, 2, 3, 4, 5]\n"
        "mixtos = [1, \"dos\", 3.0, True]\n\n"
        "**Tuplas:** \n"
        "punto = (10, 20)\n"
        "informacion = (\"Antonio\", 30, \"España\")\n\n"
        "**Conjuntos:**\n"
        "colores = {\"rojo\", \"verde\", \"azul\"}\n\n"
        "**Diccionarios:** \n"
        "coche = {\"marca\": \"Toyota\", \"modelo\": \"Corolla\", \"año\": 2021}\n\n"
        "**Operaciones Básicas**\n\n"
        "**Operaciones Aritméticas:** Suma, resta, multiplicación, división, módulo, y exponenciación.\n"
        "```\nsuma = 10 + 5\nresta = 10 - 5\nmultiplicacion = 10 * 5\ndivision = 10 / 5\nmodulo = 10 % 3\nexponente = 2 ** 3\n```\n"
        "**Operaciones con Listas: **Acceso, modificación, adición y eliminación de elementos.\n"
        "```\ndiccionario = {\"nombre\": \"Antonio\", \"edad\": 30}\ndiccionario[\"edad\"] = 31\ndiccionario[\"ciudad\"] = \"Madrid\"\ndel diccionario[\"edad\"]\n```\n"
    ),
            (
        "enteros",
        "### Ejemplos de enteros (int) en Python\n\n"
        "**Asignación básica:**\n"
        "```python\n"
        "# Números positivos\n"
        "edad = 25\n"
        "cantidad_productos = 1000\n"
        "año_actual = 2024\n\n"
        "# Números negativos\n"
        "temperatura_bajo_cero = -15\n"
        "deuda = -5000\n\n"
        "# Cero\n"
        "puntos_iniciales = 0\n"
        "```"
        "**Operaciones aritméticas:**\n"
        "```python\n"
        "# Suma\n"
        "resultado_suma = 15 + 10  # 25\n\n"
        "# Resta\n"
        "resultado_resta = 50 - 30  # 20\n\n"
        "# Multiplicación\n"
        "resultado_mult = 7 * 3  # 21\n\n"
        "# División entera (//)\n"
        "resultado_div_entera = 20 // 6  # 3 (descarta decimales)\n\n"
        "# Módulo (%)\n"
        "residuo = 20 % 6  # 2 (resto de la división)\n\n"
        "# Potencia (**)\n"
        "cubo = 3 ** 3  # 27\n\n"
        "```\n"
        "**Uso en contexto real:**\n"
        "```python\n"
        "# Calcular días vividos (aproximado)\n"
        "años = 30\n"
        "días_por_año = 365\n"
        "días_vividos = años * días_por_año  # 10,950\n\n"
        "# Controlar inventario"
        "stock_inicial = 150\n"
        "ventas = 47\n"
        "reposición = 60\n"
        "stock_actual = stock_inicial - ventas + reposición  # 163\n\n"
        "# Conversión de unidades\n"
        "kilómetros = 5\n"
        "metros = kilómetros * 1000  # 5000\n\n"
        "```\n"
        "**Conversión a entero:**\n"
        "```python\n"
        "# Desde string numérico\n"
        'numero_str = "45"\n'
        "numero_int = int(numero_str)  # 45 (ahora es tipo int)\n\n"
        "# Desde float"
        "numero_float = 12.99\n"
        "numero_int = int(numero_float)  # 12 (trunca decimales)\n\n"
        '# Error común (evitar) --> # int("Hola") → ValueError\n'
        "```\n"
        "**Casos especiales:**\n"
        "```python\n"
        "# Notación científica (se almacena como int si no hay decimales)\n"
        "gran_numero = 2e3  # 2000 (tipo int)\n\n"
        "# Sistemas numéricos\n"
        "hexadecimal = 0xFF  # 255 en decimal\n"
        "binario = 0b1010  # 10 en decimal\n"
        "octal = 0o77  # 63 en decimal\n"
        "```\n"
),
            (
        "int",
        "**Ejemplos de enteros (int) en Python**\n\n"
        "**Asignación básica:**\n"
        "```python\n"
        "# Números positivos\n"
        "edad = 25\n"
        "cantidad_productos = 1000\n"
        "año_actual = 2024\n\n"
        "# Números negativos\n"
        "temperatura_bajo_cero = -15\n"
        "deuda = -5000\n\n"
        "# Cero\n"
        "puntos_iniciales = 0\n"
        "```"
        "**Operaciones aritméticas:**\n"
        "```python\n"
        "# Suma\n"
        "resultado_suma = 15 + 10  # 25\n\n"
        "# Resta\n"
        "resultado_resta = 50 - 30  # 20\n\n"
        "# Multiplicación\n"
        "resultado_mult = 7 * 3  # 21\n\n"
        "# División entera (//)\n"
        "resultado_div_entera = 20 // 6  # 3 (descarta decimales)\n\n"
        "# Módulo (%)\n"
        "residuo = 20 % 6  # 2 (resto de la división)\n\n"
        "# Potencia (**)\n"
        "cubo = 3 ** 3  # 27\n\n"
        "```\n"
        "**Uso en contexto real:**\n"
        "```python\n"
        "# Calcular días vividos (aproximado)\n"
        "años = 30\n"
        "días_por_año = 365\n"
        "días_vividos = años * días_por_año  # 10,950\n\n"
        "# Controlar inventario"
        "stock_inicial = 150\n"
        "ventas = 47\n"
        "reposición = 60\n"
        "stock_actual = stock_inicial - ventas + reposición  # 163\n\n"
        "# Conversión de unidades\n"
        "kilómetros = 5\n"
        "metros = kilómetros * 1000  # 5000\n\n"
        "```\n"
        "**Conversión a entero:**\n"
        "```python\n"
        "# Desde string numérico\n"
        'numero_str = "45"\n'
        "numero_int = int(numero_str)  # 45 (ahora es tipo int)\n\n"
        "# Desde float"
        "numero_float = 12.99\n"
        "numero_int = int(numero_float)  # 12 (trunca decimales)\n\n"
        '# Error común (evitar) --> # int("Hola") → ValueError\n'
        "```\n"
        "**Casos especiales:**\n"
        "```python\n"
        "# Notación científica (se almacena como int si no hay decimales)\n"
        "gran_numero = 2e3  # 2000 (tipo int)\n\n"
        "# Sistemas numéricos\n"
        "hexadecimal = 0xFF  # 255 en decimal\n"
        "binario = 0b1010  # 10 en decimal\n"
        "octal = 0o77  # 63 en decimal\n"
        "```\n"
),

            (
        "float",
        "**¿Qué es un float en Python?**\n\n"
        "Los float son números de punto flotante (decimales) que permiten representar valores reales con parte fraccionaria.\n\n"
        "**Ejemplo de uso práctico**\n"
        "```python\n"
        "# 1. Asignación básica\n"
        "temperatura = 23.5\n"       
        "pi = 3.1415926535\n"
        "presupuesto = 1500.75\n\n"
        "# 2. Notación científica\n"
        "velocidad_luz = 3e8      # 300000000.0\n"
        "micro_metro = 1e-6       # 0.000001\n\n"
        "# 3. Operaciones matemáticas\n"
        "radio = 5.0\n"
        "area_circulo = pi * (radio ** 2)  # 78.5398163375\n\n"
        "# 4. Conversiones\n"
        "entero_a_float = float(42)        # 42.0\n"
        'texto_a_float = float("15.75")    # 15.75\n\n'
        "# 5. Resultados de división\n"
        "division = 10 / 3  # 3.3333333333333335 (automáticamente float)\n\n"
        "**Casos especiales**\n"
        "infinito_positivo = float('inf')   # Representa infinito\n"
        "infinito_negativo = -float('inf')  # -infinito\n"
        "no_es_numero = float('nan')        # NaN (Not a Number)\n\n"
        "```\n"
        "**¿Cuándo usar floats?**\n"
        "- Cálculos científicos/ingeniería\n"
        "- Manejo de dinero (aunque mejor usar decimal para precisión absoluta)\n"
        "- Mediciones físicas (peso, temperatura, tiempo)\n"
        "- Gráficos y modelado 3D"
),

            (
        "numeros complejos",
        "**¿Qué es un complex en Python?**\n\n"
        "Los números complejos tienen una parte real y una parte imaginaria (múltiplo de j, la unidad imaginaria).\n\n"
        "**Ejemplo de uso práctico**\n"
        "```python\n"
        "# 1. Asignación directa\n"
        "z1 = 3 + 4j        # Parte real: 3 | Parte imaginaria: 4\n"       
        "z2 = -2.5 - 1.7j   # Números negativos\n"
        "z3 = 0j            # Complejo puramente imaginario (real=0)\n\n"
        "# 2. Usando complex()\n"
        "z4 = complex(2, 5)   # 2 + 5j\n"
        "z5 = complex(1.5)    # 1.5 + 0j (si solo se especifica real)\n\n"
        "```\n"
        "**Operaciones comunes**\n"
        "```python\n"
        "# Suma\n"
        "resultado_suma = (2 + 3j) + (1 - 2j)  # 3 + 1j\n\n"
        "# Multiplicación\n"
        "resultado_mult = (1 + 2j) * (3 - 4j)  # 11 + 2j (3 + 6j -4j -8j² → j²=-1)\n\n"
        '# Conjugado complejo\n'
        "conjugado = (5 - 3j).conjugate()  # 5 + 3j\n\n"
        "# Acceso a partes\n"
        "real = z1.real     # 3.0 (siempre retorna float)\n"
        "imag = z1.imag     # 4.0\n"
        "```\n"

        "**Casos especiales**\n"
        "```python\n"
        "# Desde strings\n"
        'z6 = complex("5+3j")      # 5 + 3j (sin espacios)\n'
        'z7 = complex("2.7")       # 2.7 + 0j\n\n'
        "# Magnitud y fase (módulo y argumento)\n"
        "import cmath\n"
        "modulo = abs(3 + 4j)      # 5.0 (√(3² +4²))\n"
        "fase = cmath.phase(1 + 1j) # 0.785 rad (45°)\n\n"
        "```\n"
        "**Aplicaciones prácticas**\n"
        "```python\n"
        "# 1. Resolver ecuaciones cuadráticas con raíces complejas\n"
        'a, b, c = 1, 2, 5\n'
        "discriminante = b**2 - 4*a*c\n"
        "raiz1 = (-b + cmath.sqrt(discriminante)) / (2*a)  # -1 + 2j\n"
        "raiz2 = (-b - cmath.sqrt(discriminante)) / (2*a)  # -1 - 2j\n\n"
        "# 2. Ingeniería eléctrica (impedancia)\n"
        "resistencia = 4.7  # Ohms (real)\n"
        "reactancia = 3.2j  # Ohms (imaginario)\n"
        "impedancia_total = resistencia + reactancia  # 4.7 + 3.2j\n\n"
        "# 3. Transformadas de Fourier (procesamiento de señales)\n"
        "muestra = [0.5 + 0j, 1j, -0.3 + 0.4j]  # Datos complejos típicos\n\n"
        "```\n"
        "**Precauciones importantes**\n"
        "```python\n"
        "# 1. La 'j' debe ir pegado al número imaginario\n"
        'incorrecto = 3 + j4     # Error (NameError: j4 no existe)\n'
        "correcto = 3 + 4j       # ✓\n\n"
        "# 2. Precisión en representación\n"
        "operacion = (0.1 + 0.2j) * 3  # 0.3 + 0.6j (precisión float)\n\n"
        "```\n"
        "**¿Cuándo usar complex?**\n"
        "- Análisis de circuitos AC\n"
        "- Procesamiento de señales digitales\n"
        "- Mecánica cuántica (funciones de onda)\n"
        "- Gráficos fractales (como el conjunto de Mandelbrot)"
),
            (
        "complex",
        "**¿Qué es un complex en Python?**\n\n"
        "Los números complejos tienen una parte real y una parte imaginaria (múltiplo de j, la unidad imaginaria).\n\n"
        "**Ejemplo de uso práctico**\n"
        "```python\n"
        "# 1. Asignación directa\n"
        "z1 = 3 + 4j        # Parte real: 3 | Parte imaginaria: 4\n"       
        "z2 = -2.5 - 1.7j   # Números negativos\n"
        "z3 = 0j            # Complejo puramente imaginario (real=0)\n\n"
        "# 2. Usando complex()\n"
        "z4 = complex(2, 5)   # 2 + 5j\n"
        "z5 = complex(1.5)    # 1.5 + 0j (si solo se especifica real)\n\n"
        "```\n"
        "**Operaciones comunes**\n"
        "```python\n"
        "# Suma\n"
        "resultado_suma = (2 + 3j) + (1 - 2j)  # 3 + 1j\n\n"
        "# Multiplicación\n"
        "resultado_mult = (1 + 2j) * (3 - 4j)  # 11 + 2j (3 + 6j -4j -8j² → j²=-1)\n\n"
        '# Conjugado complejo\n'
        "conjugado = (5 - 3j).conjugate()  # 5 + 3j\n\n"
        "# Acceso a partes\n"
        "real = z1.real     # 3.0 (siempre retorna float)\n"
        "imag = z1.imag     # 4.0\n"
        "```\n"

        "**Casos especiales**\n"
        "```python\n"
        "# Desde strings\n"
        'z6 = complex("5+3j")      # 5 + 3j (sin espacios)\n'
        'z7 = complex("2.7")       # 2.7 + 0j\n\n'
        "# Magnitud y fase (módulo y argumento)\n"
        "import cmath\n"
        "modulo = abs(3 + 4j)      # 5.0 (√(3² +4²))\n"
        "fase = cmath.phase(1 + 1j) # 0.785 rad (45°)\n\n"
        "```\n"
        "**Aplicaciones prácticas**\n"
        "```python\n"
        "# 1. Resolver ecuaciones cuadráticas con raíces complejas\n"
        'a, b, c = 1, 2, 5\n'
        "discriminante = b**2 - 4*a*c\n"
        "raiz1 = (-b + cmath.sqrt(discriminante)) / (2*a)  # -1 + 2j\n"
        "raiz2 = (-b - cmath.sqrt(discriminante)) / (2*a)  # -1 - 2j\n\n"
        "# 2. Ingeniería eléctrica (impedancia)\n"
        "resistencia = 4.7  # Ohms (real)\n"
        "reactancia = 3.2j  # Ohms (imaginario)\n"
        "impedancia_total = resistencia + reactancia  # 4.7 + 3.2j\n\n"
        "# 3. Transformadas de Fourier (procesamiento de señales)\n"
        "muestra = [0.5 + 0j, 1j, -0.3 + 0.4j]  # Datos complejos típicos\n\n"
        "```\n"
        "**Precauciones importantes**\n"
        "```python\n"
        "# 1. La 'j' debe ir pegado al número imaginario\n"
        'incorrecto = 3 + j4     # Error (NameError: j4 no existe)\n'
        "correcto = 3 + 4j       # ✓\n\n"
        "# 2. Precisión en representación\n"
        "operacion = (0.1 + 0.2j) * 3  # 0.3 + 0.6j (precisión float)\n\n"
        "```\n"
        "**¿Cuándo usar complex?**\n"
        "- Análisis de circuitos AC\n"
        "- Procesamiento de señales digitales\n"
        "- Mecánica cuántica (funciones de onda)\n"
        "- Gráficos fractales (como el conjunto de Mandelbrot)"
),

            (
        "cadena de texto",
        "**¿Qué es una cadena de texto en Python?**\n\n"
        "Las cadenas son secuencias inmutables de caracteres (letras, números, símbolos) encerradas entre comillas.\n\n"
        "**Ejemplo de uso básico**\n"
        "```python\n"
        "# 1. Creación de cadenas\n"
        'saludo = "¡Hola, mundo!"\n'       
        "direccion = 'Calle Falsa 123'\n"
        "poema = '''Roses are red,\n"
        "Violets are blue...'''  # Multilínea\n\n"
        "# 2. Caracteres especiales con escape\n"
        'texto = "Texto con \"comillas\" y \\barra\\"  # Usa \ para escapar\n\n'
        "# 3. Acceso a caracteres\n"
        "primera_letra = saludo[0]  # '¡' (índice 0)\n"
        "ultimo_caracter = saludo[-1]  # '!')\n"
        "subcadena = saludo[1:5]  # 'Hola' (slicing)\n\n"
        "```\n"
        "**Operaciones comunes**\n"
        "```python\n"
        "# Concatenación\n"
        'nombre = "Ana"\n'
        'bienvenida = "Hola, " + nombre + "!"  # "Hola, Ana!"\n\n'
        "# Repetición\n"
        'eco = "ja" * 3  # "jajaja"\n\n'
        "# Formateo con f-strings (Python 3.6+)\n"
        "edad = 25\n"
        'mensaje = f"{nombre} tiene {edad} años"  # "Ana tiene 25 años"\n\n'
        "# Métodos útiles\n"
        'texto = "  Python es Genial  "\n'
        'limpio = texto.strip()  # "Python es Genial" (elimina espacios)\n'
        'mayusculas = texto.upper()  # "  PYTHON ES GENIAL  ")\n'
        'reemplazo = texto.replace("Genial", "Increíble")  # "  Python es Increíble  "\n\n'
        "```\n"
        "**Casos especiales**\n"
        "```python\n"
        "# Unicode y emojis\n"
        'emoji = "Python 🐍"  # Soporta caracteres Unicode\n'
        'hex_code = "\u00A1Hola!"  # ¡Hola! (código hexadecimal)\n\n'
        "# Conversiones\n"
        'numero_str = str(42)  # "42" (entero a cadena)\n'
        'lista = "-".join(["a", "b", "c"])  # "a-b-c" (unión con separador)\n\n'
        "# Comprobaciones\n"
        'es_alfanumerico = "abc123".isalnum()  # True\n'
        'es_digito = "50".isdigit()  # True\n\n'
        "```\n"
        "**Aplicaciones prácticas**\n"
        "```python\n"
        "# 1. Procesamiento de texto\n"
        'frase = "Python es un lenguaje poderoso"\n'
        'palabras = frase.split()  # ["Python", "es", ..., "poderoso"]\n'
        "longitud = len(frase)  # 28 caracteres (incluyendo espacios)\n\n"
        "# 2. Validación de entrada de usuario\n"
        'email = "usuario@dominio.com"\n'
        'if "@" in email and "." in email.split("@")[1]:\n'
        '              print("Email válido")\n\n'
        "# 3. Generación de HTML/XML\n"
        "etiqueta = f'<a href=`{url}`>{texto}</a>'  # Plantillas simples\n\n"
        "# 4. Palíndromos\n"
        'es_palindromo = "anilina" == "anilina"[::-1]  # True (reversa)\n\n'
        "```\n"
        "**Precauciones importantes**\n"
        "```python\n"
        "# 1. Inmutabilidad: No se pueden modificar caracteres individuales\n"
        'cadena = "Hola"\n'
        '# cadena[0] = "M"  # Error: TypeError\n\n'
        "# 2. Codificación de caracteres\n"
        'texto = "Añadir carácter ñ"  # Usar codificación UTF-8 al guardar archivos\n\n'
        "# 3. Performance en concatenaciones grandes\n"
        "# Mejor usar listas y str.join():\n"
        'resultado = "\n".join(partes)  # Eficiente para muchas operaciones\n\n'
        "```\n"
        "**¿Cuándo usar str?**\n"
        "- Manipulación de texto (limpieza, análisis)\n"
        "- Interfaz de usuario y mensajes\n"
        "- Procesamiento de archivos (CSV, JSON, XML)\n"
        "- Generación de contenido dinámico (plantillas web)\n"
        "- Expresiones regulares (búsqueda de patrones)"
),

            (
        "str",
        "**¿Qué es una cadena de texto en Python?**\n\n"
        "Las cadenas son secuencias inmutables de caracteres (letras, números, símbolos) encerradas entre comillas.\n\n"
        "**Ejemplo de uso básico**\n"
        "```python\n"
        "# 1. Creación de cadenas\n"
        'saludo = "¡Hola, mundo!"\n'       
        "direccion = 'Calle Falsa 123'\n"
        "poema = '''Roses are red,\n"
        "Violets are blue...'''  # Multilínea\n\n"
        "# 2. Caracteres especiales con escape\n"
        'texto = "Texto con \"comillas\" y \\barra\\"  # Usa \ para escapar\n\n'
        "# 3. Acceso a caracteres\n"
        "primera_letra = saludo[0]  # '¡' (índice 0)\n"
        "ultimo_caracter = saludo[-1]  # '!')\n"
        "subcadena = saludo[1:5]  # 'Hola' (slicing)\n\n"
        "```\n"
        "**Operaciones comunes**\n"
        "```python\n"
        "# Concatenación\n"
        'nombre = "Ana"\n'
        'bienvenida = "Hola, " + nombre + "!"  # "Hola, Ana!"\n\n'
        "# Repetición\n"
        'eco = "ja" * 3  # "jajaja"\n\n'
        "# Formateo con f-strings (Python 3.6+)\n"
        "edad = 25\n"
        'mensaje = f"{nombre} tiene {edad} años"  # "Ana tiene 25 años"\n\n'
        "# Métodos útiles\n"
        'texto = "  Python es Genial  "\n'
        'limpio = texto.strip()  # "Python es Genial" (elimina espacios)\n'
        'mayusculas = texto.upper()  # "  PYTHON ES GENIAL  ")\n'
        'reemplazo = texto.replace("Genial", "Increíble")  # "  Python es Increíble  "\n\n'
        "```\n"
        "**Casos especiales**\n"
        "```python\n"
        "# Unicode y emojis\n"
        'emoji = "Python 🐍"  # Soporta caracteres Unicode\n'
        'hex_code = "\u00A1Hola!"  # ¡Hola! (código hexadecimal)\n\n'
        "# Conversiones\n"
        'numero_str = str(42)  # "42" (entero a cadena)\n'
        'lista = "-".join(["a", "b", "c"])  # "a-b-c" (unión con separador)\n\n'
        "# Comprobaciones\n"
        'es_alfanumerico = "abc123".isalnum()  # True\n'
        'es_digito = "50".isdigit()  # True\n\n'
        "```\n"
        "**Aplicaciones prácticas**\n"
        "```python\n"
        "# 1. Procesamiento de texto\n"
        'frase = "Python es un lenguaje poderoso"\n'
        'palabras = frase.split()  # ["Python", "es", ..., "poderoso"]\n'
        "longitud = len(frase)  # 28 caracteres (incluyendo espacios)\n\n"
        "# 2. Validación de entrada de usuario\n"
        'email = "usuario@dominio.com"\n'
        'if "@" in email and "." in email.split("@")[1]:\n'
        '              print("Email válido")\n\n'
        "# 3. Generación de HTML/XML\n"
        "etiqueta = f'<a href=`{url}`>{texto}</a>'  # Plantillas simples\n\n"
        "# 4. Palíndromos\n"
        'es_palindromo = "anilina" == "anilina"[::-1]  # True (reversa)\n\n'
        "```\n"
        "**Precauciones importantes**\n"
        "```python\n"
        "# 1. Inmutabilidad: No se pueden modificar caracteres individuales\n"
        'cadena = "Hola"\n'
        '# cadena[0] = "M"  # Error: TypeError\n\n'
        "# 2. Codificación de caracteres\n"
        'texto = "Añadir carácter ñ"  # Usar codificación UTF-8 al guardar archivos\n\n'
        "# 3. Performance en concatenaciones grandes\n"
        "# Mejor usar listas y str.join():\n"
        'resultado = "\n".join(partes)  # Eficiente para muchas operaciones\n\n'
        "```\n"
        "**¿Cuándo usar str?**\n"
        "- Manipulación de texto (limpieza, análisis)\n"
        "- Interfaz de usuario y mensajes\n"
        "- Procesamiento de archivos (CSV, JSON, XML)\n"
        "- Generación de contenido dinámico (plantillas web)\n"
        "- Expresiones regulares (búsqueda de patrones)"
),

    (
        "boolean",
        "¿Qué es un boolean en Python?\n\n"
        "Los booleanos son un tipo de dato que solo puede tener dos valores: `True` o `False`. Son utilizados comúnmente en estructuras de control y comparaciones.\n\n"
        "Ejemplo de uso práctico\n"
        "```python\n"
        "# 1. Asignación directa\n"
        "es_verdadero = True      # Asignación de valor True\n"
        "es_falso = False         # Asignación de valor False\n"
        "\n"
        "# 2. Comparaciones\n"
        "igual = (2 == 2)         # True, porque 2 es igual a 2\n"
        "mayor = (5 > 3)          # True, porque 5 es mayor que 3\n"
        "menor = (1 < 0)          # False, porque 1 no es menor que 0\n"
        "```\n"
        "Operaciones comunes\n"
        "```python\n"
        "# Operadores lógicos\n"
        "resultado_and = True and False  # False (ambos deben ser True)\n"
        "resultado_or = True or False    # True (al menos uno debe ser True)\n"
        "resultado_not = not True        # False (negación)\n"
        "\n"
        "# Comparaciones\n"
        "igual = (10 == 10)    # True\n"
        "diferente = (10 != 5) # True\n"
        "mayor = (7 > 4)       # True\n"
        "menor = (3 < 8)       # True\n"
        "\n"
        "# Condiciones\n"
        "if es_verdadero:\n"
        "    print(\"Es verdadero\")\n"
        "else:\n"
        "    print(\"Es falso\")\n"
        "# Output: Es verdadero\n"
        "```\n"
        "Casos especiales\n"
        "```python\n"
        "# Valores que evalúan a False\n"
        "valor_falso = bool(0)       # False (enteros)\n"
        "valor_falso = bool(0.0)     # False (flotantes)\n"
        "valor_falso = bool('')      # False (cadenas vacías)\n"
        "valor_falso = bool([])      # False (listas vacías)\n"
        "valor_falso = bool({})      # False (diccionarios vacíos)\n"
        "valor_falso = bool(None)    # False (NoneType)\n"
        "\n"
        "# Valores que evalúan a True\n"
        "valor_verdadero = bool(1)       # True (entero no cero)\n"
        "valor_verdadero = bool(-1)      # True (entero no cero negativo)\n"
        "valor_verdadero = bool(0.1)     # True (flotante no cero)\n"
        "valor_verdadero = bool('Hola')  # True (cadena no vacía)\n"
        "valor_verdadero = bool([1, 2])  # True (lista no vacía)\n"
        "valor_verdadero = bool({'a': 1}) # True (diccionario no vacío)\n"
        "```\n"
        "Aplicaciones prácticas\n"
        "```python\n"
        "# 1. Control de flujo\n"
        "saldo = 100\n"
        "retirar = 50\n"
        "if saldo >= retirar:\n"
        "    saldo -= retirar\n"
        "    print(\"Retiro exitoso\")\n"
        "else:\n"
        "    print(\"Saldo insuficiente\")\n"
        "\n"
        "# 2. Validación de entradas\n"
        "usuario_activo = True\n"
        "if usuario_activo:\n"
        "    print(\"El usuario está activo\")\n"
        "else:\n"
        "    print(\"El usuario no está activo\")\n"
        "\n"
        "# 3. Búsquedas en listas\n"
        "numeros = [1, 2, 3, 4, 5]\n"
        "valor_buscado = 3\n"
        "encontrado = valor_buscado in numeros  # True\n"
        "```\n"
        "Precauciones importantes\n"
        "```python\n"
        "# 1. Comparaciones con 'is' y '=='\n"
        "a = [1, 2, 3]\n"
        "b = a\n"
        "c = [1, 2, 3]\n"
        "comparacion_is = (a is b)  # True (mismo objeto en memoria)\n"
        "comparacion_is = (a is c)  # False (diferentes objetos)\n"
        "comparacion_eq = (a == c)  # True (mismo contenido)\n"
        "\n"
        "# 2. Cuidado con las comparaciones flotantes\n"
        "valor = 0.1 + 0.2\n"
        "comparacion = (valor == 0.3)  # False (precisión flotante)\n"
        "print(valor)  # 0.30000000000000004\n"
        "```\n"
        "¿Cuándo usar boolean?\n"
        "- Estructuras de control (if, while, for)\n"
        "- Validaciones y verificaciones\n"
        "- Comparaciones y evaluaciones lógicas\n"
        "- Filtrado de datos\n"
        "- Control de flujo en algoritmos"
    ),
                 (
        "listas",
        "¿Qué es una lista en Python?\n\n"
        "Las listas son estructuras de datos mutables que pueden contener una colección ordenada de elementos de cualquier tipo.\n\n"
        "Ejemplo de uso práctico\n"
        "```python\n"
        "# 1. Creación de listas\n"
        "vacia = []  # Lista vacía\n"
        "numeros = [1, 2, 3, 4, 5]  # Lista de enteros\n"
        "mixta = [1, 'dos', 3.0, [4, 5]]  # Lista mixta\n"
        "\n"
        "# 2. Acceso a elementos\n"
        "primer_elemento = numeros[0]  # 1 (índice 0)\n"
        "ultimo_elemento = numeros[-1]  # 5 (último elemento)\n"
        "sublista = numeros[1:4]  # [2, 3, 4] (slicing)\n"
        "```\n"
        "Operaciones comunes\n"
        "```python\n"
        "# Adición de elementos\n"
        "numeros.append(6)  # [1, 2, 3, 4, 5, 6] (agrega al final)\n"
        "numeros.insert(0, 0)  # [0, 1, 2, 3, 4, 5, 6] (inserta en índice)\n"
        "\n"
        "# Eliminación de elementos\n"
        "numeros.pop()  # [0, 1, 2, 3, 4, 5] (elimina el último)\n"
        "numeros.remove(3)  # [0, 1, 2, 4, 5] (elimina el primer 3 encontrado)\n"
        "\n"
        "# Modificación de elementos\n"
        "numeros[0] = -1  # [-1, 1, 2, 4, 5] (modifica el primer elemento)\n"
        "\n"
        "# Operaciones de lista\n"
        "concatenacion = [1, 2] + [3, 4]  # [1, 2, 3, 4] (concatenación)\n"
        "repeticion = [0] * 3  # [0, 0, 0] (repetición)\n"
        "longitud = len(numeros)  # 5 (número de elementos)\n"
        "```\n"
        "Casos especiales\n"
        "```python\n"
        "# Listas anidadas\n"
        "anidada = [[1, 2, 3], [4, 5, 6]]\n"
        "elemento_anidado = anidada[0][1]  # 2 (acceso a elemento anidado)\n"
        "\n"
        "# Comprensiones de listas\n"
        "cuadrados = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]\n"
        "\n"
        "# Métodos útiles\n"
        "numeros.extend([6, 7])  # [-1, 1, 2, 4, 5, 6, 7] (extiende con otra lista)\n"
        "numeros.reverse()  # [7, 6, 5, 4, 2, 1, -1] (invierte el orden)\n"
        "numeros.sort()  # [-1, 1, 2, 4, 5, 6, 7] (ordena la lista)\n"
        "```\n"
        "Aplicaciones prácticas\n"
        "```python\n"
        "# 1. Iteración sobre listas\n"
        "for num in numeros:\n"
        "    print(num)\n"
        "\n"
        "# 2. Filtrado de listas\n"
        "pares = [x for x in numeros if x % 2 == 0]  # [2, 4, 6]\n"
        "\n"
        "# 3. Operaciones matemáticas\n"
        "suma = sum(numeros)  # 24 (suma de elementos)\n"
        "```\n"
        "Precauciones importantes\n"
        "```python\n"
        "# 1. Índices fuera de rango\n"
        "try:\n"
        "    elemento = numeros[10]  # Error: IndexError\n"
        "except IndexError:\n"
        "    print(\"Índice fuera de rango\")\n"
        "\n"
        "# 2. Modificación durante la iteración\n"
        "for num in numeros:\n"
        "    if num < 0:\n"
        "        numeros.remove(num)  # Puede causar problemas\n"
        "\n"
        "# 3. Copias de listas\n"
        "copia_numeros = numeros[:]  # Crea una copia superficial\n"
        "```\n"
        "¿Cuándo usar listas?\n"
        "- Almacenar colecciones ordenadas de elementos\n"
        "- Realizar operaciones de agregación, filtrado y selección\n"
        "- Implementar estructuras de datos más complejas\n"
        "- Trabajar con secuencias de datos mutables\n"
    ),
    (
        "tuplas",
        "¿Qué es una tupla en Python?\n\n"
        "Las tuplas son estructuras de datos inmutables que pueden contener una colección ordenada de elementos de cualquier tipo.\n\n"
        "Ejemplo de uso práctico\n"
        "```python\n"
        "# 1. Creación de tuplas\n"
        "vacía = ()  # Tupla vacía\n"
        "numeros = (1, 2, 3, 4, 5)  # Tupla de enteros\n"
        "mixta = (1, 'dos', 3.0, (4, 5))  # Tupla mixta\n"
        "\n"
        "# 2. Acceso a elementos\n"
        "primer_elemento = numeros[0]  # 1 (índice 0)\n"
        "ultimo_elemento = numeros[-1]  # 5 (último elemento)\n"
        "subtupla = numeros[1:4]  # (2, 3, 4) (slicing)\n"
        "```\n"
        "Operaciones comunes\n"
        "```python\n"
        "# Concatenación de tuplas\n"
        "concatenacion = (1, 2) + (3, 4)  # (1, 2, 3, 4)\n"
        "\n"
        "# Repetición de tuplas\n"
        "repeticion = (0,) * 3  # (0, 0, 0)\n"
        "\n"
        "# Longitud de la tupla\n"
        "longitud = len(numeros)  # 5 (número de elementos)\n"
        "\n"
        "# Desempaquetado de tuplas\n"
        "a, b, c = (1, 2, 3)  # a=1, b=2, c=3\n"
        "```\n"
        "Casos especiales\n"
        "```python\n"
        "# Tuplas anidadas\n"
        "anidada = ((1, 2, 3), (4, 5, 6))\n"
        "elemento_anidado = anidada[0][1]  # 2 (acceso a elemento anidado)\n"
        "\n"
        "# Tuplas de un solo elemento\n"
        "un_elemento = (1,)  # Necesita una coma\n"
        "\n"
        "# Métodos útiles\n"
        "indice = numeros.index(3)  # 2 (índice del primer 3 encontrado)\n"
        "conteo = numeros.count(1)  # 1 (número de veces que 1 aparece)\n"
        "```\n"
        "Aplicaciones prácticas\n"
        "```python\n"
        "# 1. Pares clave-valor\n"
        "diccionario = dict([(1, 'uno'), (2, 'dos')])  # {1: 'uno', 2: 'dos'}\n"
        "\n"
        "# 2. Funciones que retornan múltiples valores\n"
        "def coordenadas():\n"
        "    return (10, 20)\n"
        "x, y = coordenadas()  # x=10, y=20\n"
        "\n"
        "# 3. Iteración sobre tuplas\n"
        "for numero in numeros:\n"
        "    print(numero)\n"
        "```\n"
        "Precauciones importantes\n"
        "```python\n"
        "# 1. Inmutabilidad: No se pueden modificar elementos individuales\n"
        "try:\n"
        "    numeros[0] = 0  # Error: TypeError\n"
        "except TypeError:\n"
        "    print(\"Las tuplas son inmutables\")\n"
        "\n"
        "# 2. Índices fuera de rango\n"
        "try:\n"
        "    elemento = numeros[10]  # Error: IndexError\n"
        "except IndexError:\n"
        "    print(\"Índice fuera de rango\")\n"
        "\n"
        "# 3. Copias de tuplas\n"
        "copia_numeros = tuple(numeros)  # Crea una copia superficial\n"
        "```\n"
        "¿Cuándo usar tuplas?\n"
        "- Almacenar colecciones ordenadas de elementos inmutables\n"
        "- Retornar múltiples valores desde una función\n"
        "- Utilizar como claves en diccionarios (si los elementos son hashables)\n"
        "- Proteger datos de modificaciones accidentales\n"
    ),

    (
        "set",
        "¿Qué es un conjunto en Python?\n\n"
        "Los conjuntos son estructuras de datos que almacenan elementos únicos y desordenados. Son mutables, pero sus elementos deben ser inmutables.\n\n"
        "Ejemplo de uso práctico\n"
        "```python\n"
        "# 1. Creación de conjuntos\n"
        "vacio = set()  # Conjunto vacío\n"
        "numeros = {1, 2, 3, 4, 5}  # Conjunto de enteros\n"
        "mixto = {1, 'dos', 3.0}  # Conjunto mixto\n"
        "\n"
        "# 2. Adición de elementos\n"
        "numeros.add(6)  # {1, 2, 3, 4, 5, 6}\n"
        "\n"
        "# 3. Eliminación de elementos\n"
        "numeros.remove(3)  # {1, 2, 4, 5, 6}\n"
        "numeros.discard(10)  # No causa error si el elemento no está presente\n"
        "\n"
        "# 4. Verificación de miembros\n"
        "existe = 2 in numeros  # True\n"
        "\n"
        "# 5. Longitud del conjunto\n"
        "longitud = len(numeros)  # 5 (número de elementos)\n"
        "```\n"
        "Operaciones comunes\n"
        "```python\n"
        "# Unión de conjuntos\n"
        "a = {1, 2, 3}\n"
        "b = {3, 4, 5}\n"
        "union = a | b  # {1, 2, 3, 4, 5}\n"
        "\n"
        "# Intersección de conjuntos\n"
        "interseccion = a & b  # {3}\n"
        "\n"
        "# Diferencia de conjuntos\n"
        "diferencia = a - b  # {1, 2}\n"
        "\n"
        "# Diferencia simétrica de conjuntos\n"
        "diferencia_simetrica = a ^ b  # {1, 2, 4, 5}\n"
        "```\n"
        "Casos especiales\n"
        "```python\n"
        "# Conjuntos inmutables (frozenset)\n"
        "inmutable = frozenset([1, 2, 3, 4, 5])\n"
        "\n"
        "# Métodos adicionales\n"
        "numeros.update({7, 8})  # {1, 2, 4, 5, 6, 7, 8} (agrega múltiples elementos)\n"
        "numeros.clear()  # Vacía el conjunto\n"
        "```\n"
        "Aplicaciones prácticas\n"
        "```python\n"
        "# 1. Eliminación de duplicados\n"
        "lista_con_duplicados = [1, 2, 2, 3, 4, 4, 5]\n"
        "sin_duplicados = list(set(lista_con_duplicados))  # [1, 2, 3, 4, 5]\n"
        "\n"
        "# 2. Operaciones de conjunto en bases de datos\n"
        "usuarios_A = {'Alice', 'Bob', 'Charlie'}\n"
        "usuarios_B = {'Bob', 'David'}\n"
        "usuarios_en_ambos = usuarios_A & usuarios_B  # {'Bob'}\n"
        "\n"
        "# 3. Filtrado de elementos únicos\n"
        "palabras = ['python', 'java', 'python', 'c++']\n"
        "unicas = set(palabras)  # {'python', 'java', 'c++'}\n"
        "```\n"
        "Precauciones importantes\n"
        "```python\n"
        "# 1. Los conjuntos no mantienen el orden\n"
        "conjunto = {3, 1, 2}\n"
        "for elemento in conjunto:\n"
        "    print(elemento)\n"
        "# La salida puede ser en cualquier orden\n"
        "\n"
        "# 2. Los elementos del conjunto deben ser inmutables\n"
        "try:\n"
        "    conjunto = {1, [2, 3]}  # Error: TypeError\n"
        "except TypeError:\n"
        "    print(\"Los elementos del conjunto deben ser inmutables\")\n"
        "\n"
        "# 3. Métodos de modificación no están disponibles en frozenset\n"
        "try:\n"
        "    inmutable.add(6)  # Error: AttributeError\n"
        "except AttributeError:\n"
        "    print(\"frozenset es inmutable\")\n"
        "```\n"
        "¿Cuándo usar conjuntos?\n"
        "- Almacenar colecciones de elementos únicos\n"
        "- Realizar operaciones de conjuntos como unión, intersección y diferencia\n"
        "- Filtrar elementos duplicados de una colección\n"
        "- Implementar operaciones de lógica de conjuntos en algoritmos\n"
    ),    
            (
        "diccionarios",
        "¿Qué es un diccionario en Python?\n\n"
        "Los diccionarios son estructuras de datos que almacenan pares clave-valor. Son mutables y permiten el acceso rápido a los valores mediante sus claves.\n\n"
        "Ejemplo de uso práctico\n"
        "```python\n"
        "# 1. Creación de diccionarios\n"
        "vacio = {}  # Diccionario vacío\n"
        "alumnos = {'Juan': 85, 'Ana': 92, 'Luis': 78}  # Diccionario con claves y valores\n"
        "\n"
        "# 2. Acceso a valores\n"
        "nota_ana = alumnos['Ana']  # 92 (acceso mediante clave)\n"
        "\n"
        "# 3. Adición y modificación de elementos\n"
        "alumnos['Pedro'] = 88  # {'Juan': 85, 'Ana': 92, 'Luis': 78, 'Pedro': 88}\n"
        "alumnos['Luis'] = 80  # {'Juan': 85, 'Ana': 92, 'Luis': 80, 'Pedro': 88} (modifica valor)\n"
        "```\n"
        "Operaciones comunes\n"
        "```python\n"
        "# Eliminación de elementos\n"
        "del alumnos['Juan']  # {'Ana': 92, 'Luis': 80, 'Pedro': 88}\n"
        "nota_pedro = alumnos.pop('Pedro')  # 88 y {'Ana': 92, 'Luis': 80}\n"
        "\n"
        "# Comprobación de existencia\n"
        "existe_ana = 'Ana' in alumnos  # True\n"
        "\n"
        "# Longitud del diccionario\n"
        "num_alumnos = len(alumnos)  # 2 (número de pares clave-valor)\n"
        "```\n"
        "Casos especiales\n"
        "```python\n"
        "# Recorrido de diccionarios\n"
        "for clave, valor in alumnos.items():\n"
        "    print(f'{clave}: {valor}')\n"
        "\n"
        "# Métodos útiles\n"
        "claves = alumnos.keys()  # dict_keys(['Ana', 'Luis'])\n"
        "valores = alumnos.values()  # dict_values([92, 80])\n"
        "pares = alumnos.items()  # dict_items([('Ana', 92), ('Luis', 80)])\n"
        "```\n"
        "Aplicaciones prácticas\n"
        "```python\n"
        "# 1. Contar frecuencia de elementos\n"
        "frutas = ['manzana', 'banana', 'manzana', 'naranja', 'banana', 'manzana']\n"
        "conteo = {}\n"
        "for fruta in frutas:\n"
        "    if fruta in conteo:\n"
        "        conteo[fruta] += 1\n"
        "    else:\n"
        "        conteo[fruta] = 1\n"
        "print(conteo)  # {'manzana': 3, 'banana': 2, 'naranja': 1}\n"
        "\n"
        "# 2. Almacenar configuraciones\n"
        "config = {'host': 'localhost', 'port': 8080, 'debug': True}\n"
        "\n"
        "# 3. Conversión entre diccionarios y listas de tuplas\n"
        "lista_tuplas = list(alumnos.items())  # [('Ana', 92), ('Luis', 80)]\n"
        "nuevo_diccionario = dict(lista_tuplas)  # {'Ana': 92, 'Luis': 80}\n"
        "```\n"
        "Precauciones importantes\n"
        "```python\n"
        "# 1. Claves únicas\n"
        "alumnos = {'Juan': 85, 'Ana': 92, 'Juan': 78}  # La segunda clave 'Juan' sobrescribe la primera\n"
        "print(alumnos)  # {'Juan': 78, 'Ana': 92}\n"
        "\n"
        "# 2. Claves inmutables\n"
        "try:\n"
        "    diccionario = {[1, 2]: 'valor'}  # Error: TypeError\n"
        "except TypeError:\n"
        "    print(\"Las claves deben ser inmutables\")\n"
        "\n"
        "# 3. Métodos de modificación no están disponibles en vistas de diccionario\n"
        "try:\n"
        "    claves = alumnos.keys()\n"
        "    claves.append('nuevo')  # Error: AttributeError\n"
        "except AttributeError:\n"
        "    print(\"Las vistas de diccionario son dinámicas pero no modificables\")\n"
        "```\n"
        "¿Cuándo usar diccionarios?\n"
        "- Almacenar pares clave-valor para acceso rápido\n"
        "- Contar frecuencia de elementos\n"
        "- Almacenar configuraciones y opciones\n"
        "- Modelar datos estructurados como registros\n"
    ),
            (
        "operadores aritmeticos",
        "** Operadores Aritméticos en Python\n\n"
        "son símbolos que se utilizan para realizar operaciones matemáticas sobre valores numéricos. Estos operadores incluyen:\n"
        "- Suma (+):  Suma dos valores.\n"
        "- Resta (-): Resta el segundo valor del primero.\n"
        "- Multiplicación (*): Multiplica dos valores.\n"
        "- División (/): Divide el primer valor por el segundo y devuelve un resultado con decimales.\n"
        "- División entera (//): Divide y devuelve solo la parte entera del resultado, sin decimales.\n"
        "- Módulo (%): Devuelve el resto de la división.\n"
        "- Potenciación ()**: Eleva un número a la potencia de otro.\n\n"
        "**Ejemplo detallado**\n"
        "```python\n"
        "# Definimos dos números\n"
        "a = 10\n"
        "b = 3\n\n"
        "# Realizamos operaciones aritméticas\n"
        "suma = a + b              # 10 + 3 = 13\n"
        "resta = a - b             # 10 - 3 = 7\n"
        "multiplicacion = a * b    # 10 * 3 = 30\n"
        "division = a / b          # 10 / 3 = 3.3333...\n"
        "division_entera = a // b  # 10 // 3 = 3\n"
        "modulo = a % b            # 10 % 3 = 1 (resto de la división)\n"
        "potencia = a ** b         # 10^3 = 1000\n\n"
        "# Imprimimos los resultados\n"
        'print(f"Suma: {suma}")\n'
        'print(f"Resta: {resta}")\n'
        'print(f"Multiplicación: {multiplicacion}")\n'
        'print(f"División: {division}")\n'
        'print(f"División Entera: {division_entera}")\n'
        'print(f"Módulo: {modulo}")\n'
        'print(f"Potencia: {potencia}")\n'
        "```\n"
        "**Desglose de cada paso**\n"
        "Definimos las variables:\n"
        "a = 10 \n"
        "b = 3\n\n"
        "Realizamos las operaciones y guardamos los resultados en variables:\n"
        "suma = 10 + 3 = 13\n"
        "resta = 10 - 3 = 7\n"
        "multiplicacion = 10 * 3 = 30\n"
        "division = 10 / 3 ≈ 3.3333...\n"
        "division_entera = 10 // 3 = 3 (descarta los decimales)\n"
        "modulo = 10 % 3 = 1 (el residuo de dividir 10 entre 3 es 1)\n"
        "potencia = 10 ** 3 = 1000 (10 elevado a la 3)\n\n"
        "Mostramos los resultados con **print()**, usando **f-strings** para formatear la salida.\n"
        "Salida esperada en consola:\n"
        "```python\n"
        "Suma: 13\n"
        "Resta: 7\n"
        "Multiplicación: 30\n"
        "División: 3.3333333333333335\n"
        "División Entera: 3\n"
        "Módulo: 1\n"
        "Potencia: 1000\n"
        "```\n"
),
    (
        "operadores logicos",
        "** Operadores Lógicos en Python\n\n"
        "son símbolos que se utilizan para combinar valores booleanos y realizar operaciones lógicas. Estos operadores incluyen:\n"
        "- AND (y): Devuelve True si ambos operandos son True.\n"
        "- OR (o): Devuelve True si al menos uno de los operandos es True.\n"
        "- NOT (no): Invierte el valor lógico del operando.\n\n"
        "**Ejemplo detallado**\n"
        "```python\n"
        "# Definimos dos valores booleanos\n"
        "a = True\n"
        "b = False\n\n"
        "# Realizamos operaciones lógicas\n"
        "resultado_and = a and b      # True and False = False\n"
        "resultado_or = a or b        # True or False = True\n"
        "resultado_not_a = not a      # not True = False\n"
        "resultado_not_b = not b      # not False = True\n\n"
        "# Imprimimos los resultados\n"
        'print(f"AND: {resultado_and}")\n'
        'print(f"OR: {resultado_or}")\n'
        'print(f"NOT a: {resultado_not_a}")\n'
        'print(f"NOT b: {resultado_not_b}")\n'
        "```\n"
        "**Desglose de cada paso**\n"
        "Definimos las variables:\n"
        "a = True \n"
        "b = False\n\n"
        "Realizamos las operaciones y guardamos los resultados en variables:\n"
        "resultado_and = True and False = False\n"
        "resultado_or = True or False = True\n"
        "resultado_not_a = not True = False\n"
        "resultado_not_b = not False = True\n\n"
        "Mostramos los resultados con **print()**, usando **f-strings** para formatear la salida.\n"
        "Salida esperada en consola:\n"
        "```python\n"
        "AND: False\n"
        "OR: True\n"
        "NOT a: False\n"
        "NOT b: True\n"
        "```\n"
    ),
        (
        "operadores de comparacion",
        "** Operadores de Comparación en Python\n\n"
        "son símbolos que se utilizan para comparar dos valores y devolver un valor booleano (True o False). Estos operadores incluyen:\n"
        "- Igual a (==): Devuelve True si ambos valores son iguales.\n"
        "- Distinto de (!=): Devuelve True si los valores son diferentes.\n"
        "- Mayor que (>): Devuelve True si el primer valor es mayor que el segundo.\n"
        "- Menor que (<): Devuelve True si el primer valor es menor que el segundo.\n"
        "- Mayor o igual que (>=): Devuelve True si el primer valor es mayor o igual que el segundo.\n"
        "- Menor o igual que (<=): Devuelve True si el primer valor es menor o igual que el segundo.\n\n"
        "**Ejemplo detallado**\n"
        "```python\n"
        "# Definimos dos números\n"
        "a = 10\n"
        "b = 3\n\n"
        "# Realizamos comparaciones\n"
        "igual = a == b               # 10 == 3 = False\n"
        "diferente = a != b           # 10 != 3 = True\n"
        "mayor = a > b                # 10 > 3 = True\n"
        "menor = a < b                # 10 < 3 = False\n"
        "mayor_o_igual = a >= b       # 10 >= 3 = True\n"
        "menor_o_igual = a <= b       # 10 <= 3 = False\n\n"
        "# Imprimimos los resultados\n"
        'print(f"Igual: {igual}")\n'
        'print(f"Diferente: {diferente}")\n'
        'print(f"Mayor: {mayor}")\n'
        'print(f"Menor: {menor}")\n'
        'print(f"Mayor o Igual: {mayor_o_igual}")\n'
        'print(f"Menor o Igual: {menor_o_igual}")\n'
        "```\n"
        "**Desglose de cada paso**\n"
        "Definimos las variables:\n"
        "a = 10 \n"
        "b = 3\n\n"
        "Realizamos las operaciones y guardamos los resultados en variables:\n"
        "igual = 10 == 3 = False\n"
        "diferente = 10 != 3 = True\n"
        "mayor = 10 > 3 = True\n"
        "menor = 10 < 3 = False\n"
        "mayor_o_igual = 10 >= 3 = True\n"
        "menor_o_igual = 10 <= 3 = False\n\n"
        "Mostramos los resultados con **print()**, usando **f-strings** para formatear la salida.\n"
        "Salida esperada en consola:\n"
        "```python\n"
        "Igual: False\n"
        "Diferente: True\n"
        "Mayor: True\n"
        "Menor: False\n"
        "Mayor o Igual: True\n"
        "Menor o Igual: False\n"
        "```\n"
    ),
        (
        "operadores de asignacion",
        "** Operadores de Asignación en Python\n\n"
        "son utilizados para asignar valores a las variables. Además del operador de asignación simple (=), Python proporciona varios operadores de asignación compuestos para realizar operaciones aritméticas y asignar el resultado a la misma variable. Estos operadores incluyen:\n"
        "- Asignación (=): Asigna un valor a una variable.\n"
        "- Suma y asigna (+=): Suma un valor a la variable y asigna el resultado a la misma variable.\n"
        "- Resta y asigna (-=): Resta un valor a la variable y asigna el resultado a la misma variable.\n"
        "- Multiplica y asigna (*=): Multiplica un valor a la variable y asigna el resultado a la misma variable.\n"
        "- Divide y asigna (/=): Divide un valor a la variable y asigna el resultado a la misma variable.\n"
        "- Divide enteramente y asigna (//=): Divide enteramente un valor a la variable y asigna el resultado a la misma variable.\n"
        "- Módulo y asigna (%=): Calcula el módulo de la variable con un valor y asigna el resultado a la misma variable.\n"
        "- Potencia y asigna (**=): Eleva la variable a la potencia de un valor y asigna el resultado a la misma variable.\n\n"
        "**Ejemplo detallado**\n"
        "```python\n"
        "# Definimos una variable\n"
        "a = 10\n\n"
        "# Realizamos operaciones de asignación\n"
        "a += 3  # a = a + 3 -> 13\n"
        "a -= 2  # a = a - 2 -> 11\n"
        "a *= 4  # a = a * 4 -> 44\n"
        "a /= 2  # a = a / 2 -> 22.0\n"
        "a //= 3  # a = a // 3 -> 7.0\n"
        "a %= 4  # a = a % 4 -> 3.0\n"
        "a **= 2  # a = a ** 2 -> 9.0\n\n"
        "# Imprimimos los resultados\n"
        'print(f"Asignación: a = {a}")\n'
        'print(f"Suma y Asigna: a += 3 -> {a}")\n'
        'print(f"Resta y Asigna: a -= 2 -> {a}")\n'
        'print(f"Multiplica y Asigna: a *= 4 -> {a}")\n'
        'print(f"Divide y Asigna: a /= 2 -> {a}")\n'
        'print(f"Divide Enteramente y Asigna: a //= 3 -> {a}")\n'
        'print(f"Módulo y Asigna: a %= 4 -> {a}")\n'
        'print(f"Potencia y Asigna: a **= 2 -> {a}")\n'
        "```\n"
        "**Desglose de cada paso**\n"
        "Definimos la variable:\n"
        "a = 10\n\n"
        "Realizamos las operaciones y asignamos los resultados a la misma variable:\n"
        "a += 3  -> 13\n"
        "a -= 2  -> 11\n"
        "a *= 4  -> 44\n"
        "a /= 2  -> 22.0\n"
        "a //= 3  -> 7.0\n"
        "a %= 4  -> 3.0\n"
        "a **= 2  -> 9.0\n\n"
        "Mostramos los resultados con **print()**, usando **f-strings** para formatear la salida.\n"
        "Salida esperada en consola:\n"
        "```python\n"
        "Asignación: a = 9.0\n"
        "Suma y Asigna: a += 3 -> 9.0\n"
        "Resta y Asigna: a -= 2 -> 9.0\n"
        "Multiplica y Asigna: a *= 4 -> 9.0\n"
        "Divide y Asigna: a /= 2 -> 9.0\n"
        "Divide Enteramente y Asigna: a //= 3 -> 9.0\n"
        "Módulo y Asigna: a %= 4 -> 9.0\n"
        "Potencia y Asigna: a **= 2 -> 9.0\n"
        "```\n"
    ),
            (
         "estructuras de control",
         "**Estructuras de control en Python**\n\n"
         "son mecanismos que permiten modificar el flujo de ejecución de un programa. Se dividen en tres tipos principales:\n\n"
         "- **Estructuras condicionales ** ( if , elif , else)\n"
         "Permiten ejecutar diferentes bloques de código según si una condición es verdadera o falsa.\n\n"
         "- **Estructuras de bucles o iterativas ** ( for , while )\n"
         "Permiten repetir un bloque de código varias veces.\n"
         "**for:** Se usa para recorrer elementos de una secuencia (listas, tuplas, cadenas, etc.).\n"
         "**while: ** Repite un bloque mientras una condición específica sea verdadera.\n\n"
         "- **Estructuras de control de flujo ** ( break , continue , pass )\n"
         "**break:** Detiene completamente la ejecución del bucle.\n"
         "**continue:** Salta a la siguiente iteración del bucle sin ejecutar el código restante de la iteración actual.\n"
         "**pass:** No hace nada, se usa como marcador de posición en estructuras vacías."       
    ),
    (
        "condicionales",
        "**Condicionales en Python:** if - elif - else\n\n"
        "Las estructuras condicionales permiten ejecutar diferentes bloques de código según si una condición es\n"
        "verdadera o falsa. Se basan en la palabra clave if y pueden incluir elif y else.\n\n"
        "**1. Condición simple con if**\n\n"
        "Ejecuta un bloque de código solo si la condición es verdadera.\n"
        "```python\n"
        "edad = 18\n\n"
        "if edad >= 18:  # Si la edad es mayor o igual a 18\n"
        '      print("Eres mayor de edad")\n'
        "```\n"
        " Explicación paso a paso\n\n"
        "- Definimos edad = 18.\n"
        '- Evaluamos edad >= 18. Como es verdadero, se ejecuta print("Eres mayor de edad").\n'
        "- Si la condición fuese falsa, no se ejecutaría nada.\n\n"
        "Salida esperada\n"
        "```python\n"
        "Eres mayor de edad\n"
        "```\n"
        "**2. Condición con if - else**\n\n"
        "Se usa cuando queremos ejecutar una acción si la condición es verdadera y otra si es falsa.\n"
        "```python\n"
        "edad = 16\n\n"
        "if edad >= 18:\n"
        '    print("Eres mayor de edad")\n'
        "else:\n"
        '    print("Eres menor de edad")\n'
        "```\n"
        "**Explicación paso a paso**\n\n"
        "- Definimos edad = 16.\n"
        "- Evaluamos edad >= 18. Como es falso, se ejecuta el bloque dentro de else.\n"
        '- Se imprime "Eres menor de edad".\n\n'
        "Salida esperada:\n"
        "```python\n"
        "Eres menor de edad\n"
        "```\n"
        "**3. Condición con if - elif - else**\n\n"
        "Se usa cuando hay varias condiciones posibles.\n"
        "```python\n"
        "nota = 85\n\n"
        "if nota >= 90:\n"
        '    print("Tienes una A")\n'
        "elif nota >= 80:\n"
        '    print("Tienes una B")\n'
        "elif nota >= 70:\n"
        '    print("Tienes una C")\n'
        "else:\n"
        '    print("Has reprobado")\n'
        "```\n"
        "**Explicación paso a paso**\n\n"
        "- nota = 85\n" 
        "- Se evalúa nota >= 90. Como es falso, pasa al siguiente elif.\n"
        '- Se evalúa nota >= 80. Como es verdadero, se ejecuta print("Tienes una B").\n'
        "- No se evalúan más condiciones porque ya se encontró una verdadera.\n\n"
        "**Salida esperada:**\n"
        "```python\n"
        "Tienes una B\n"
        "```\n"
        "**4. Condiciones anidadas (if dentro de if)\n\n"
        "Se usa cuando una condición depende de otra.\n"
        "```python\n"
        "edad = 20\n"
        "tiene_licencia = True\n\n"
        "if edad >= 18:\n"
        '    if tiene_licencia:\n'
        '        print("Puedes conducir")\n'
        "    else:\n"
        '        print("Necesitas una licencia")\n'
        "else:\n"
        '    print("Eres menor de edad, no puedes conducir")\n'
        "```\n"
        "Salida esperada:\n"
        "```python\n"
        "Puedes conducir\n"
        "```\n"
        "**5. Condición con operadores lógicos (and, or, not)**\n\n"
        "Se usan para combinar múltiples condiciones.\n"
        "```python\n"
        'usuario = "admin"\n'
        'contrasena = "1234"\n\n'
        'if usuario == "admin" and contrasena == "1234":\n'
        '    print("Acceso permitido")\n'
        'else:\n'
        '    print("Acceso denegado")\n'
        "```\n"
        "Explicación paso a paso\n\n"
        '- Se verifica que ambas condiciones sean verdaderas (usuario == "admin" y contrasena == "1234").\n'
        '- Como las dos son verdaderas, imprime "Acceso permitido".\n'
        '- Si una de ellas fuera falsa, se ejecutaría el else.\n\n'
        "Salida esperada\n"
        "```python\n"
        "Acceso permitido\n"
        "```\n"

    ),
    (
        "if",
        "Ejecuta un bloque de código solo si la condición es verdadera.\n"
        "```python\n"
        "edad = 18\n\n"
        "if edad >= 18:  # Si la edad es mayor o igual a 18\n"
        '      print("Eres mayor de edad")\n'
        "```\n"
        " Explicación paso a paso\n\n"
        "- Definimos edad = 18.\n"
        '- Evaluamos edad >= 18. Como es verdadero, se ejecuta print("Eres mayor de edad").\n'
        "- Si la condición fuese falsa, no se ejecutaría nada.\n\n"
        "Salida esperada\n"
        "```python\n"
        "Eres mayor de edad\n"
        "```\n"
    ),
    (
        "for",
        "**Bucle for**\n\n"
        "Se usa cuando queremos recorrer una secuencia de elementos (listas, cadenas, rangos, etc.).\n"
        "```python\n"
        "for i in range(1, 6):  # Recorre los números del 1 al 5\n"
        '    print(f"Número: {i}")\n'
        "```\n"
        "Explicación Paso a Paso\n\n"
        "- range(1, 6) genera los números 1, 2, 3, 4, 5 (el 6 no se incluye).\n"
        "- En cada iteración, la variable i toma un valor de la secuencia.\n"
        '- print(f"Número: {i}") muestra cada número en la consola.\n\n'
        "Salida esperada:\n"
        "```python\n"
        "Número: 1\n"
        "Número: 2\n"
        "Número: 3\n"
        "Número: 4\n"
        "Número: 5\n"
        "```\n"
    ),
       (
        "while",
        "**Bucle while**\n\n"
        "Se usa cuando queremos repetir un bloque mientras una condición sea verdadera.\n"
        "```python\n"
        "contador = 1\n\n"
        'while contador <= 5:  # Se repite mientras contador sea menor o igual a 5\n'
        '    print(f"Contador: {contador}")\n'
        '    contador += 1  # Incrementamos el contador en 1\n'
        "```\n"
        "Explicación Paso a Paso\n\n"
        "- Definimos contador = 1.\n"
        "- Se verifica contador <= 5, si es verdadero, se ejecuta el bloque dentro del while.\n"
        '- Se imprime el valor de contador y luego se incrementa en 1.\n'
        "- Cuando contador = 6, la condición es falsa y el bucle se detiene.\n\n"
        "Salida esperada:\n"
        "```python\n"
        "Contador: 1\n"
        "Contador: 2\n"
        "Contador: 3\n"
        "Contador: 4\n"
        "Contador: 5\n"
        "```\n"
    ),

           (
        "break",
        "**Control de flujo en bucles | break**\n\n"
        "Se usa cuando queremos Salir del bucle antes de tiempo.\n"
        "```python\n"
        "for num in range(1, 10):\n"
        '    if num == 5:\n'
        '        print("Se encontró el 5, saliendo del bucle...")\n'
        '        break  # Sale del bucle cuando num es 5\n'
        '    print(f"Número: {num}")\n'
        "```\n"
        "Salida esperada:\n"
        "```python\n"
        "Número: 1\n"
        "Número: 2\n"
        "Número: 3\n"
        "Número: 4\n"
        "Se encontró el 5, saliendo del bucle... \n"
        "```\n"
    ),
           (
        "continue",
        "**Control de flujo en bucles | continue**\n\n"
        "Se usa cuando queremosSaltar una iteración y seguir con la siguiente.\n"
        "```python\n"
        "for num in range(1, 6):\n"
        '    if num == 3:\n'
        '        print("Saltando el número 3...")\n'
        '        continue  # Salta esta iteración y sigue con la siguiente\n'
        '    print(f"Número: {num}")\n'
        "```\n"
        "Salida esperada:\n"
        "```python\n"
        "Número: 1\n"
        "Número: 2\n"
        "Saltando el número 3...\n"
        "Número: 4\n"
        "Número: 5\n"
        "```\n"
    ),
               (
        "pass",
        "**Control de flujo en bucles | pass**\n\n"
        "Marcador de posición, no hace nada\n"
        "```python\n"
        "for num in range(1, 6):\n"
        '    if num == 3:\n'
        '        pass  # No hace nada, solo mantiene la estructura válida\n'
        '    print(f"Número: {num}")\n'
        "```\n"
        "Salida esperada:\n"
        "```python\n"
        "Número: 1\n"
        "Número: 2\n"
        "Número: 3\n"
        "Número: 4\n"
        "Número: 5\n"
        "```\n"
    ),
    (
        "funcion python",
        "### La función calculará el factorial de un número usando un bucle for.\n"
        "\n"
        "```python\n"
        "# Definimos una función llamada factorial que recibe un número n como parámetro\n"
        "def factorial(n):\n"
        '    """\n\n'
        "    Calcula el factorial de un número entero positivo.\n\n"
        "    Parámetros:\n"
        "    n (int): El número del que queremos calcular el factorial.\n\n"
        "    Retorna:\n"
        "    int: El factorial del número n.\n"
        '     """\n\n'
        "    # Verificamos si el número es negativo\n"
        "    if n < 0:\n"
        '        return "No se puede calcular el factorial de un número negativo"\n\n'
        "    # Caso especial: el factorial de 0 es 1\n"
        "    if n == 0:\n"
        "        return 1\n\n"
        " # Inicializamos una variable para almacenar el resultado del factorial\n"
        "    resultado = 1\n\n"
        "    # Usamos un bucle for para multiplicar los números desde 1 hasta n\n"
        '  for i in range(1, n + 1):  # El rango va de 1 a n (incluyendo n)\n'
        "        resultado *= i  # Multiplicamos el resultado por el valor de i\n\n"
        "    # Retornamos el resultado final\n"
        "    return resultado\n\n"
        "# Solicitamos un número al usuario\n"
        'numero = int(input("Ingrese un número para calcular su factorial: "))\n\n'
        "# Llamamos a la función factorial y mostramos el resultado\n"
        'print(f"El factorial de {numero} es: {factorial(numero)}")\n'
        "```\n"
        "**Explicación paso a paso**\n\n"
        "- Definimos la función factorial(n) con un parámetro n.\n"
        "- Verificamos si n es negativo. Si lo es, devolvemos un mensaje de error.\n"
        "- Manejamos el caso especial n == 0, devolviendo 1.\n"
        "- Inicializamos resultado = 1 para almacenar el cálculo.\n"
        "- Iteramos con for i in range(1, n + 1) para multiplicar todos los números desde 1 hasta n.\n"
        "- Multiplicamos resultado *= i en cada iteración.\n"
        "- Retornamos el valor final después de completar el bucle.\n"
        "- Pedimos al usuario un número y mostramos el resultado usando print().\n\n"
        "Ejemplo de ejecución:\n"
        "```python\n"
        "\n"
        "Ingrese un número para calcular su factorial: 5\n"
        "El factorial de 5 es: 120\n"
        "```\n"
    ),
        (
        "palindromo",
        "### Función para verificar si un número es palíndromo\n"
        "```python\n"
        "def es_palindromo(numero):\n\n"
        '    # Convertimos el número a cadena para poder invertirlo\n'
        "    numero_str = str(numero) \n\n"
        "    Invertimos la cadena y la comparamos con la original\n"
        "    if numero_str == numero_str[::-1]: \n"
        "        return True  # Es palíndromo\n"
        "    int: El factorial del número n.\n"
        '    else:\n'
        "        return False  # No es palíndromo\n\n"
        "**# Solicitamos un número al usuario**\n"
        'num = int(input("Ingrese un número: "))\n\n'
        "# Verificamos si es palíndromo e imprimimos el resultado\n"
        "if es_palindromo(num):\n"
        '    print(f"El número {num} es un palíndromo.")\n'
        "else:\n"
        '    print(f"El número {num} no es un palíndromo.")\n'
        "```\n"
        "### Explicación paso a paso\n\n"
        "- Convertimos el número a cadena con str(numero), para poder manipularlo.\n"
        "- Invertimos la cadena usando [::-1] y la comparamos con la original.\n"
        "- Si son iguales, el número es un palíndromo y la función retorna True.\n"
        "- Si no son iguales, retorna False.\n"
        "- Pedimos al usuario un número, llamamos la función y mostramos el resultado.\n\n"
        "### Ejemplo de ejecución:\n"
        "```python\n"
        "Ingrese un número: 12321\n"
        "El número 12321 es un palíndromo.\n"
        "```\n"
    ),
            (
        "calculadora",
        "## Calculadora con Python\n\n"
        "```python\n"
        "import tkinter as tk\n"
        "from tkinter import ttk\n"
        "import math\n\n"
        "class Calculator:\n"
        "    def __init__(self, root):\n"
        "        # Configuración inicial de la ventana\n"
        "        self.root = root\n"
        '        self.root.title("Calculadora Científica")\n'
        '        self.root.geometry("400x500")\n'
        '        self.root.resizable(False, False)\n\n'
        "        # Variables de control\n"
        "        self.current_input = tk.StringVar()\n"
        "        self.history = []\n\n"
        "        # Configurar interfaz\n"
        "        self.create_display()\n"
        "        self.create_buttons()\n"
        "        self.create_history()\n\n"
        "    def create_display(self):\n"
        '        """Crea el área de visualización"""\n'
        "        frame = ttk.Frame(self.root, padding=10)\n"
        "        frame.pack(fill=tk.X)\n\n"
        "        self.display = ttk.Entry(\n"
        "            frame,\n"
        "            textvariable=self.current_input,\n"
        "            font=('Arial', 20),\n"
        "            justify='right',\n"
        "            state='readonly'\n"
        "        )\n"
        "        self.display.pack(fill=tk.X)\n\n"
        "    def create_buttons(self):\n"
        '        """Crea los botones de la calculadora"""\n'
        "        button_frame = ttk.Frame(self.root)\n"
        "        button_frame.pack(expand=True, fill=tk.BOTH)\n\n"
        "        # Configuración de botones\n"
        "        buttons = [\n"
        "            ('C', '←', 'π', '√', 'x²'),\n"
        "            ('7', '8', '9', '/', '('),\n"
        "            ('4', '5', '6', '*', ')'),\n"
        "            ('1', '2', '3', '-', '='),\n"
        "            ('0', '.', '%', '+', 'sin')\n"
        "        ]\n\n"
        "        for row_idx, row in enumerate(buttons):\n"
        "            for col_idx, btn_text in enumerate(row):\n"
        "                btn = ttk.Button(\n"
        "                    button_frame,\n"
        "                    text=btn_text,\n"
        "                    command=lambda t=btn_text: self.on_button_click(t)\n"
        "                )\n"
        "                btn.grid(\n"
        "                    row=row_idx,\n"
        "                    column=col_idx,\n"
        "                    sticky=tk.NSEW,\n"
        "                    padx=2,\n"
        "                    pady=2\n"
        "                )\n"
        "                button_frame.columnconfigure(col_idx, weight=1)\n"
        "            button_frame.rowconfigure(row_idx, weight=1)\n\n"
        "    def create_history(self):\n"
        '        """Crea el área de historial"""\n'
        "        history_frame = ttk.Frame(self.root)\n"
        "        history_frame.pack(fill=tk.BOTH, expand=True)\n\n"
        "        self.history_listbox = tk.Listbox(\n"
        "            history_frame,\n"
        "            font=('Arial', 10),\n"
        "            bg='#f0f0f0'\n"
        "        )\n"
        "        self.history_listbox.pack(fill=tk.BOTH, expand=True)\n\n"
        "    def on_button_click(self, button_text):\n"
        '        """Maneja los clics en los botones"""\n'
        "        current = self.current_input.get()\n\n"
        "        if button_text == 'C':\n"
        "            self.current_input.set('')\n"
        "        elif button_text == '←':\n"
        "            self.current_input.set(current[:-1])\n"
        "        elif button_text == '=':\n"
        "            self.calculate_result()\n"
        "        elif button_text == 'π':\n"
        "            self.current_input.set(current + str(math.pi))\n"
        "        elif button_text == '√':\n"
        "            self.current_input.set(f'sqrt({current})')\n"
        "        elif button_text == 'x²':\n"
        "            self.current_input.set(f'({current})**2')\n"
        "        elif button_text == 'sin':\n"
        "            self.current_input.set(f'math.sin({current})')\n"
        "        else:\n"
        "            self.current_input.set(current + button_text)\n\n"
        "    def calculate_result(self):\n"
        '        """Realiza el cálculo matemático"""\n'
        "        try:\n"
        "            expression = self.current_input.get()\n"
        "            # Reemplazar símbolos matemáticos\n"
        "            expression = expression.replace('√', 'math.sqrt')\n"
        "            expression = expression.replace('%', '/100')\n\n"
        "            result = eval(expression)\n"
        "            self.current_input.set(str(result))\n"
        '            self.update_history(f"{expression} = {result}")\n'
        "        except Exception as e:\n"
        '            self.current_input.set("Error")\n'
        '            self.update_history(f"Error en: {expression}")\n\n'
        "    def update_history(self, entry):\n"
        '        """Actualiza el historial de cálculos"""\n'
        "        self.history.append(entry)\n"
        "        self.history_listbox.insert(tk.END, entry)\n"
        "        if len(self.history) > 10:\n"
        "            self.history_listbox.delete(0)\n\n"
        'if __name__ == "__main__":\n'
        "    root = tk.Tk()\n"
        "    app = Calculator(root)\n"
        "    root.mainloop()\n"
        "```\n"
        "### Explicación detallada:\n\n"
        "**Estructura de la clase:**\n"
        "- La clase Calculator encapsula toda la funcionalidad.\n"
        "- __init__: Inicializa la ventana principal y componentes.\n\n"
        "**Configuración inicial:**\n"
        "- root.title(): Establece el título de la ventana.\n"
        "- root.geometry(): Define el tamaño inicial.\n"
        "- root.resizable(): Bloquea el redimensionamiento.\n\n"
        "**Variables de control:**\n"
        "- current_input: Almacena la entrada actual (StringVar para Tkinter).\n"
        "- history: Lista para guardar el historial.\n\n"
        "**Creación de componentes:**\n"
        "- Display: Usa un Entry de solo lectura para mostrar números.\n"
        "- Botones: Organizados en una cuadrícula con 5 filas y 5 columnas.\n"
        "- Historial: Listbox que muestra los últimos 10 cálculos.\n\n"
        "**Manejo de eventos:**\n"
        "- on_button_click: Determina la acción según el botón presionado.\n"
        "- Maneja casos especiales (π, √, funciones trigonométricas).\n"
        "- calculate_result: Evalúa la expresión usando eval() con seguridad.\n\n"
        "**Características especiales:**\n"
        "- Botones científicos (sqrt, π, seno).\n"
        "- Historial de operaciones.\n"
        "- Manejo de errores (divisiones por cero, operaciones inválidas).\n\n"
        "**Mejoras importantes:**\n"
        "- Seguridad: Al usar eval(), limitamos las funciones disponibles para prevenir inyección de código.\n"
        "- Manejo de errores: Captura cualquier excepción durante los cálculos.\n"
        "- Historial: Mantiene un registro de las últimas 10 operaciones.\n\n"
        "**Posibles mejoras:**\n"
        "- Añadir más funciones científicas (cos, tan, log)\n"
        "- Implementar conversión de unidades\n"
        "- Permitir entrada desde teclado físico\n"
        "- Cambiar temas (claro/oscuro)\n"
        "- Implementar cálculos en tiempo real\n"
        
    ),

        (
        "manejo de excepciones",
        "## Estructura Básica: try - except\n\n"
        "Captura y maneja excepciones específicas.\n"
        "```python\n"
        "try:\n"
        "    # Código que podría generar un error\n"
        "    resultado = 10 / 0  # División por cero\n"
        "except ZeroDivisionError:\n"
        "    # Se ejecuta si ocurre ZeroDivisionError\n"
        '    print("¡Error! No puedes dividir por cero.")\n'
        "```\n"
        "*Salida:*\n"
        "```python\n"
        "¡Error! No puedes dividir por cero.\n"
        "```\n"
        "**Múltiples Excepciones**\n\n"
        "Puedes capturar diferentes tipos de errores.\n"
        "```python\n"
        "try:\n"
        '    num = int(input("Ingresa un número: "))  # Ejemplo: Si el usuario ingresa "abc"\n'
        "    print(10 / num)  # Si num es 0, también habrá error\n"
        "except ValueError:\n"
        '    print("Debes ingresar un número válido.")\n'
        "except ZeroDivisionError:\n"
        '    print("No puedes dividir por cero.")\n'
        "```\n"
        "### Salidas posibles:\n\n"
        "- Si ingresas abc: Debes ingresar un número válido.\n"
        "- Si ingresas 0: No puedes dividir por cero.\n\n"
        "**else en Manejo de Excepciones**\n"
        "Se ejecuta solo si no hubo errores en el bloque try.\n"
        "```python\n"
        "try:\n"
        '    archivo = open("datos.txt", "r")\n'
        "except FileNotFoundError:\n"
        '    print("El archivo no existe.")\n'
        "else:\n"
        "    contenido = archivo.read()\n"
        "    print(contenido)\n"
        "    archivo.close()  # Importante cerrar el archivo\n"
        "```\n"
        "### finally en Manejo de Excepciones\n"
        "Se ejecuta siempre, haya o no errores. Útil para liberar recursos (como cerrar archivos).\n"
        "```python\n"
        "try:\n"
        '    archivo = open("config.txt", "r")\n'
        "    print(archivo.read())\n"
        "except FileNotFoundError:\n"
        '    print("Archivo no encontrado.")\n'
        "finally:\n"
        "    archivo.close()  # Siempre se cierra el archivo\n"
        '    print("Proceso finalizado.")\n'
        "```\n"
        "\n"
        "### Capturar Todas las Excepciones (Genérico)\n"
        "Usar except sin especificar el error (no recomendado para producción).\n"
        "```python\n"
        "try:\n"
        "    lista = [1, 2, 3]\n"
        "    print(lista[5])  # Índice fuera de rango\n"
        "except:\n"
        '    print("Ocurrió un error inesperado.")\n'
        "```\n"
        "### Lanzar Excepciones: raise\n"
        "Puedes forzar un error manualmente con raise.\n"
        "```python\n"
        "def calcular_edad(edad):\n"
        "    if edad < 0:\n"
        '        raise ValueError("La edad no puede ser negativa.")\n'
        '    return f"Tienes {edad} años."\n\n'
        "try:\n"
        "    print(calcular_edad(-5))\n"
        "except ValueError as e:\n"
        "    print(e)  # Imprime el mensaje de error\n"
        "```\n"
        "*Salida:*\n"
        "```python\n"
        "La edad no puede ser negativa.\n"
        "```\n"
        "### Excepciones Personalizadas\n"
        "Crea tus propias excepciones heredando de la clase Exception.\n"
        "```python\n"
        "class ErrorSaldoInsuficiente(Exception):\n"
        '    def __init__(self, mensaje="Saldo insuficiente."):\n'
        "        self.mensaje = mensaje\n"
        "        super().__init__(self.mensaje)\n\n"
        "def retirar_dinero(saldo, monto):\n"
        "    if monto > saldo:\n"
        "        raise ErrorSaldoInsuficiente()\n"
        "    return saldo - monto\n\n"
        "try:\n"
        "    retirar_dinero(100, 200)\n"
        "except ErrorSaldoInsuficiente as e:\n"
        "    print(e)  # Salida: Saldo insuficiente.\n"
        "```\n"
        "### Manejo de Excepciones Anidadas\n"
        "Excepciones dentro de funciones llamadas.\n"
        "```python\n"
        "def dividir(a, b):\n"
        "    return a / b\n\n"
        "try:\n"
        "    print(dividir(10, 0))\n"
        "except ZeroDivisionError:\n"
        '    print("Error en la función dividir: división por cero.")\n'
        "```\n"
        "*Ejemplo Completo: Validación de Entrada*\n"
        "```python\n"
        "while True:\n"
        "    try:\n"
        '        edad = int(input("Ingresa tu edad: "))\n'
        "        if edad < 0:\n"
        '            raise ValueError("La edad no puede ser negativa.")\n'
        "        break\n"
        "    except ValueError:\n"
        '        print("Entrada inválida. Ingresa un número entero positivo.")\n\n'
        'print(f"Tu edad es: {edad}")\n'
        "```\n"
        ),

            (
        "multiples excepciones",
        "**Múltiples Excepciones**\n\n"
        "Puedes capturar diferentes tipos de errores.\n"
        "```python\n"
        "try:\n"
        '    num = int(input("Ingresa un número: "))  # Ejemplo: Si el usuario ingresa "abc"\n'
        "    print(10 / num)  # Si num es 0, también habrá error\n"
        "except ValueError:\n"
        '    print("Debes ingresar un número válido.")\n'
        "except ZeroDivisionError:\n"
        '    print("No puedes dividir por cero.")\n'
        "```\n"
        "Salidas posibles:\n\n"
        "- Si ingresas abc: Debes ingresar un número válido.\n"
        "- Si ingresas 0: No puedes dividir por cero.\n\n"

        ),

            (
        "excepciones anidadas",
        "**Manejo de Excepciones Anidadas**\n"
        "Excepciones dentro de funciones llamadas.\n"
        "```python\n"
        "def dividir(a, b):\n"
        "    return a / b\n\n"
        "try:\n"
        "    print(dividir(10, 0))\n"
        "except ZeroDivisionError:\n"
        '    print("Error en la función dividir: división por cero.")\n'
        "```\n"
        "**Ejemplo Completo: Validación de Entrada**\n"
        "```python\n"
        "while True:\n"
        "    try:\n"
        '        edad = int(input("Ingresa tu edad: "))\n'
        "        if edad < 0:\n"
        '            raise ValueError("La edad no puede ser negativa.")\n'
        "        break\n"
        "    except ValueError:\n"
        '        print("Entrada inválida. Ingresa un número entero positivo.")\n\n'
        'print(f"Tu edad es: {edad}")\n'
        "```\n"            
        ),
        
        (
        "finally",
        "**finally en Manejo de Excepciones**\n"
        "Se ejecuta siempre, haya o no errores. Útil para liberar recursos (como cerrar archivos).\n"
        "```python\n"
        "try:\n"
        '    archivo = open("config.txt", "r")\n'
        "    print(archivo.read())\n"
        "except FileNotFoundError:\n"
        '    print("Archivo no encontrado.")\n'
        "finally:\n"
        "    archivo.close()  # Siempre se cierra el archivo\n"
        '    print("Proceso finalizado.")\n'
        "```\n"
        ),

        (
        "else",
        "**else en Manejo de Excepciones**\n"
        "Se ejecuta solo si no hubo errores en el bloque try.\n"
        "```python\n"
        "try:\n"
        '    archivo = open("datos.txt", "r")\n'
        "except FileNotFoundError:\n"
        '    print("El archivo no existe.")\n'
        "else:\n"
        "    contenido = archivo.read()\n"
        "    print(contenido)\n"
        "    archivo.close()  # Importante cerrar el archivo\n"
        "```\n"
        ),

        (
        "POO",
        "## ¿Qué es la Programación Orientada a Objetos (POO)?\n"
        "La POO es un paradigma de programación basado en la creación y manipulación de\n"
        "objetos, los cuales son instancias de clases. Este enfoque permite organizar el código\n"
        "de manera modular, facilitando la reutilización y el mantenimiento.\n\n"
        "Python es un lenguaje multiparadigma, lo que significa que admite programación\n"
        "orientada a objetos, funcional y procedural.\n\n"
        "### Conceptos Claves de la POO\n"
        "La POO en Python se basa en varios principios fundamentales:\n\n"
        "### Clases y Objetos\n"
        "**- Clase:** Es un molde o plantilla que define atributos (datos) y métodos (funcionalidad)\n "
        "comunes para todos los objetos que se creen a partir de ella.\n\n"
        "**- Objeto:** Es una instancia de una clase. Cada objeto tiene su propio estado y \n"
        "comportamiento basado en la clase que lo define.\n\n"
        "Ejemplo de una Clase y su Objeto en Python:\n"
        "```python\n"
        "class Persona:\n"
        "    def __init__(self, nombre, edad):\n"
        "        self.nombre = nombre\n"
        "        self.edad = edad\n\n"
        "    def saludar(self):\n"
        '        return f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años."\n\n'
        "# Crear un objeto de la clase Persona\n"
        'persona1 = Persona("Carlos", 30)\n'
        "print(persona1.saludar())  # Salida: Hola, mi nombre es Carlos y tengo 30 años.\n"
        "```\n"
        "\n"
        "### Encapsulamiento\n"
        "Es el mecanismo que restringe el acceso directo a los atributos y métodos de un\n"
        "objeto, protegiendo los datos. En Python:\n\n"
        "- Los atributos públicos se acceden sin restricciones (self.nombre).\n"
        "- Los atributos protegidos se indican con un guion bajo (self._nombre) y su uso es una convención, \n"
        "pero no es privado.\n"
        "- Los atributos privados se definen con doble guion bajo (self.__nombre), lo que impide su acceso directo.\n\n"
        "Ejemplo de encapsulamiento:\n"
        "```python\n"
        "class CuentaBancaria:\n"
        "    def __init__(self, titular, saldo):\n"
        "        self.titular = titular  # Público\n"
        "        self._saldo = saldo      # Protegido\n"
        '        self.__clave = "secreta" # Privado\n\n'
        "    def depositar(self, monto):\n"
        "        self._saldo += monto\n\n"
        "    def get_saldo(self):\n"
        "        return self._saldo\n\n"
        "# Crear objeto\n"
        'cuenta = CuentaBancaria("Luis", 1000)\n'
        "print(cuenta.titular)  # Acceso permitido\n"
        "print(cuenta.get_saldo())  # Método para acceder al saldo\n\n"
        "# print(cuenta.__clave)  # ERROR: No se puede acceder directamente a un atributo privado\n"
        "```\n"
        "\n"
        "### Herencia\n"
        "La herencia permite que una clase hija herede atributos y métodos de una clase\n"
        "padre, promoviendo la reutilización del código.\n"
        "Ejemplo de Herencia:\n"
        "```python\n"
        "class Vehiculo:\n"
        "    def __init__(self, marca, modelo):\n"
        "        self.marca = marca\n"
        "        self.modelo = modelo\n\n"
        "    def info(self):\n"
        '        return f"Marca: {self.marca}, Modelo: {self.modelo}"\n\n'
        "# Clase hija que hereda de Vehiculo\n"
        "class Coche(Vehiculo):\n"
        "    def __init__(self, marca, modelo, puertas):\n"
        '        super().__init__(marca, modelo)  # Llama al constructor de la clase padre\n'
        "        self.puertas = puertas\n\n"
        "    def info(self):\n"
        '        return f"{super().info()}, Puertas: {self.puertas}"\n\n'
        'coche1 = Coche("Toyota", "Corolla", 4)\n'
        "print(coche1.info())  # Salida: Marca: Toyota, Modelo: Corolla, Puertas: 4\n"
        "```\n"
        "\n"
        "### Polimorfismo\n"
        "El polimorfismo permite que un mismo método tenga diferentes comportamientos\n"
        "según la clase que lo implemente.\n"
        "Ejemplo de Polimorfismo:\n"
        "```python\n"
        "class Animal:\n"
        "    def hacer_sonido(self):\n"
        "        pass\n\n"
        "class Perro(Animal):\n"
        "    def hacer_sonido(self):\n"
        '        return "Guau!"\n\n'
        "class Gato(Animal):\n"
        '    def hacer_sonido(self):\n'
        '        return "Miau!"\n\n'
        "# Uso del polimorfismo\n"
        "animales = [Perro(), Gato()]\n"
        "for animal in animales:\n"
        "    print(animal.hacer_sonido())  # Salida: Guau! Miau!\n"
        "```\n"
        "\n"
        "### Abstracción\n"
        "La *abstracción* es el proceso de ocultar detalles internos y exponer solo lo necesario.\n"
        "En Python, la abstracción se logra usando clases abstractas con la ayuda del módulo abc.\n"
        "### Ejemplo de Abstracción:\n"
        "```python\n"
        "from abc import ABC, abstractmethod\n\n"
        "class Figura(ABC):  # Clase abstracta\n"
        "    @abstractmethod\n"
        "    def area(self):\n"
        "        pass\n\n"
        "class Cuadrado(Figura):\n"
        "    def __init__(self, lado):\n"
        "        self.lado = lado\n\n"
        "    def area(self):\n"
        "        return self.lado * self.lado\n\n"
        "cuadrado = Cuadrado(4)\n"
        "print(cuadrado.area())  # Salida: 16\n"
        "```\n"
        "\n"
        "### Beneficios de la POO en Python\n"
        "**- Modularidad:** Se puede dividir un problema grande en módulos reutilizables.\n"
        "**- Reutilización:** Se pueden reutilizar clases en diferentes partes del código.\n"
        "**- Mantenibilidad:** Es más fácil mantener y actualizar el código.\n"
        "**- Escalabilidad:** Permite que los programas crezcan sin que el código se vuelva caótico.\n"

        ),

        (
        "herencia",
        "## Herencia\n"
        "La herencia permite que una clase hija herede atributos y métodos de una clase\n"
        "padre, promoviendo la reutilización del código.\n"
        "# Ejemplo de Herencia:\n"
        "```python\n"
        "class Vehiculo:\n"
        "    def __init__(self, marca, modelo):\n"
        "        self.marca = marca\n"
        "        self.modelo = modelo\n\n"
        "    def info(self):\n"
        '        return f"Marca: {self.marca}, Modelo: {self.modelo}"\n\n'
        "# Clase hija que hereda de Vehiculo\n"
        "class Coche(Vehiculo):\n"
        "    def __init__(self, marca, modelo, puertas):\n"
        '        super().__init__(marca, modelo)  # Llama al constructor de la clase padre\n'
        "        self.puertas = puertas\n\n"
        "    def info(self):\n"
        '        return f"{super().info()}, Puertas: {self.puertas}"\n\n'
        'coche1 = Coche("Toyota", "Corolla", 4)\n'
        "print(coche1.info())  # Salida: Marca: Toyota, Modelo: Corolla, Puertas: 4\n"
        "```\n"
        ),

        (
        "polimorfismo",
        "## Polimorfismo\n"
        "El polimorfismo permite que un mismo método tenga diferentes comportamientos\n"
        "según la clase que lo implemente.\n"
        "### Ejemplo de Polimorfismo:\n"
        "```python\n"
        "class Animal:\n"
        "    def hacer_sonido(self):\n"
        "        pass\n\n"
        "class Perro(Animal):\n"
        "    def hacer_sonido(self):\n"
        '        return "Guau!"\n\n'
        "class Gato(Animal):\n"
        '    def hacer_sonido(self):\n'
        '        return "Miau!"\n\n'
        "# Uso del polimorfismo\n"
        "animales = [Perro(), Gato()]\n"
        "for animal in animales:\n"
        "    print(animal.hacer_sonido())  # Salida: Guau! Miau!\n"
        "```\n"        
        ),

        (
        "abstraccion",
        "## Abstracción\n"
        "La abstracción es el proceso de ocultar detalles internos y exponer solo lo necesario.\n"
        "En Python, la abstracción se logra usando clases abstractas con la ayuda del módulo abc.\n"
        "### Ejemplo de Abstracción:\n"
        "```python\n"
        "from abc import ABC, abstractmethod\n\n"
        "class Figura(ABC):  # Clase abstracta\n"
        "    @abstractmethod\n"
        "    def area(self):\n"
        "        pass\n\n"
        "class Cuadrado(Figura):\n"
        "    def __init__(self, lado):\n"
        "        self.lado = lado\n\n"
        "    def area(self):\n"
        "        return self.lado * self.lado\n\n"
        "cuadrado = Cuadrado(4)\n"
        "print(cuadrado.area())  # Salida: 16\n"
        "```\n"

        ),
    
    (
    "node",
    "# Para instalar Node.js en Windows, sigue estos pasos:\n\n"
    "### ✅ Paso 1: Descargar el instalador de Node.js\n\n"
    "**1. Ve al sitio oficial de Node.js:** [https://nodejs.org/](https://nodejs.org/)\n\n"
    "**2. Elige la versión:**\n\n"
    "   - **LTS (Long-Term Support)**: Recomendado para la mayoría de los usuarios (más estable para proyectos).\n\n"
    "   - **Current**: Última versión con las características más recientes (menos estable).\n\n"
    "### ✅ Paso 2: Ejecutar el instalador\n\n"
    "1. Haz doble clic en el archivo .msi que descargaste.\n\n"
    "2. Sigue las instrucciones del asistente:\n\n"
    "   - Acepta los términos de la licencia.\n\n"
    "   - Deja las opciones predeterminadas (recomendado).\n\n"
    '   - Asegúrate de marcar la opción *"Automatically install the necessary tools"* si aparece.\n\n'

    "### ✅ Paso 3: Verificar la instalación\n\n"
    "1. Abre Símbolo del sistema (CMD) o PowerShell:\n\n"
    "   - Presiona *Win + R*, escribe cmd y presiona *Enter*.\n\n"
    "2. Escribe los siguientes comandos para verificar la instalación:\n"
    "\n"
    "```\n\n"
    "node -v\n"
    "```\n\n"
    "✅ Te mostrará la versión de Node.js instalada.\n"
    "\n"
    "```\n\n"
    "npm -v\n"
    "```\n\n"
    "✅ Te mostrará la versión de npm (Node Package Manager).\n"

    "✅ **Paso 4: (Opcional) Actualizar Node.js**\n\n"
    "En el futuro, puedes actualizar Node.js usando el siguiente comando en PowerShell:\n"
    "\n"
    "```\n\n"
    "npm install -g n\n\n"
    "n latest\n"
    "```\n"
    "\n"
    "*¿Necesitas ayuda con algún paso más?* 🚀\n"
    "\n"
    ),

        (
        "django",
        "**¡Claro! Aquí tienes una explicación de Django junto con ejemplos en Markdown**:\n"
        "\n"
        " 🐍 **Django: El framework web en Python**\n"
        "\n"
        "Django es un **framework de desarrollo web** de alto nivel y código abierto, diseñado para crear aplicaciones web de manera rápida, segura y escalable. Sigue el patrón **MTV (Model-Template-View)**, similar al **MVC (Model-View-Controller)**.\n"
        "\n"
        " ✅ **Principales características de Django**\n\n"
        "- **Rápido**: Facilita un desarrollo ágil y limpio.\n\n"
        "- **Seguro**: Incluye protección contra inyecciones SQL, CSRF, XSS, etc.\n\n"
        "- **Escalable**: Adaptable a proyectos pequeños y grandes.\n\n"
        "- **DRY (Don't Repeat Yourself)**: Reutilización de código y optimización.\n"
        "\n"
        "\n"
        " 📁 **Estructura básica de un proyecto Django**\n"
        "```bash\n\n"
        "mi_proyecto/\n\n"
        "├── manage.py          # Utilidad para administrar el proyecto\n\n"
        "├── mi_proyecto/       # Configuración del proyecto\n\n"
        "│   ├── __init__.py\n\n"
        "│   ├── settings.py    # Configuración principal\n\n"
        "│   ├── urls.py        # Rutas del proyecto\n\n"
        "│   └── wsgi.py        # Interfaz WSGI para producción\n\n"
        "└── app/               # Una aplicación Django\n\n"
        "    ├── __init__.py\n\n"
        "    ├── admin.py      # Registro en el panel de administración\n\n"
        "    ├── apps.py       # Configuración de la aplicación\n\n"
        "    ├── models.py     # Definición de la base de datos (Modelos)\n\n"
        "    ├── tests.py      # Pruebas unitarias\n\n"
        "    └── views.py      # Lógica de las vistas\n"
        "```\n"
        "\n"
        "\n"
        " 🚀 **Cómo empezar con Django**\n\n"
        " 1. **Instalar Django**\n\n"
        "Asegúrate de tener Python instalado y ejecuta:\n"
        "```bash\n\n"
        "pip install django\n"
        "```\n"
        "\n"
        " 2. **Crear un proyecto Django**\n"
        "```bash\n\n"
        "django-admin startproject mi_proyecto\n\n"
        "cd mi_proyecto\n\n"
        "python manage.py runserver\n"
        "```\n\n"
        "Accede a `http://localhost:8000` para ver la página de bienvenida.\n"
        "\n"
        "\n"
        " 📊 **Ejemplo: Crear una aplicación en Django**\n\n"
        " 1. Crear una aplicación:\n"
        "```bash\n\n"
        "python manage.py startapp blog\n"
        "```\n"
        "\n"
        " 2. Registrar la app en `settings.py`:\n"
        "```python\n\n"
        "INSTALLED_APPS = [\n\n"
        "    ...\n\n"
        "    'blog',\n\n"
        "]\n"
        "```\n"
        "\n"
        " 3. Definir un modelo en `models.py`:\n"
        "```python\n\n"
        "from django.db import models\n"
        "\n"
        "class Post(models.Model):\n\n"
        "    titulo = models.CharField(max_length=200)\n\n"
        "    contenido = models.TextField()\n\n"
        "    fecha_publicacion = models.DateTimeField(auto_now_add=True)\n"
        "\n"
        "    def __str__(self):\n\n"
        "        return self.titulo\n"
        "```\n"
        "\n"
        " 4. Migrar la base de datos:\n"
        "```bash\n\n"
        "python manage.py makemigrations\n\n"
        "python manage.py migrate\n"
        "```\n"
        "\n"
        "5. Crear una vista en `views.py`:\n"
        "```python\n\n"
        "from django.http import HttpResponse\n"
        "\n"
        "def inicio(request):\n\n"
        '    return HttpResponse("¡Hola, Django!")\n'
        "```\n"
        "\n"
        "6. Configurar la URL en `urls.py`:\n"
        "```python\n\n"
        "from django.urls import path\n\n"
        "from blog.views import inicio\n"
        "\n"
        "urlpatterns = [\n\n"
        "    path('', inicio, name='inicio'),\n\n"
        "]\n"
        "```\n"
        "\n"
        "\n"
        " 🛠️ **Panel de administración de Django**\n\n"
        "1. Crear un superusuario:\n"
        "```bash\n\n"
        "python manage.py createsuperuser\n"
        "```\n"
        "\n"
        "2. Registrar el modelo en `admin.py`:\n"
        "```python\n\n"
        "from django.contrib import admin\n\n"
        "from .models import Post\n"
        "\n"
        "admin.site.register(Post)\n"
        "```\n"
        "\n"
        "3. Acceder al panel: `http://localhost:8000/admin`\n"
        "\n"
        "\n"
        " 📚 **Recursos adicionales**\n\n"
        "- 📘 [Documentación oficial de Django](https://docs.djangoproject.com/)\n\n"
        "- 🧰 **Comandos útiles**:\n"
        "    python manage.py runserver       # Ejecutar el servidor\n\n"
        "    python manage.py makemigrations  # Crear migraciones\n\n"
        "    python manage.py migrate         # Aplicar migraciones\n\n"
        "    python manage.py createsuperuser # Crear usuario administrador\n"
        "\n"
        "¿Quieres que profundice en alguna parte o te muestre más ejemplos? 🚀\n"
        "\n"
       
        ),

        (
        "flask",
            "# 🧪 Flask: Microframework Web en Python\n"
            "\n"
            "**Flask** es un *microframework web* escrito en *Python*. Es ligero, flexible y minimalista, lo que lo hace ideal para desarrollar aplicaciones web de pequeña a mediana escala.\n"
            "\n"
            "### 🐍 Relación entre Flask y Python\n\n"
            "- **Lenguaje base**: Flask está desarrollado en **Python**, lo que permite aprovechar toda la potencia y simplicidad de este lenguaje.\n\n"
            "- **Extensibilidad**: Usa bibliotecas de Python para gestionar bases de datos, autenticación, validación de formularios, etc.\n\n"
            "- **Sintaxis Pythonic**: Su estructura es sencilla y sigue las buenas prácticas de desarrollo en Python.\n"
            "\n"
            "### 🌟 Características principales de Flask\n\n"
            "- **Ligero y minimalista**: Solo incluye lo esencial para crear aplicaciones web.\n\n"
            "- **Modular**: Permite añadir extensiones según lo necesites (por ejemplo: Flask-SQLAlchemy para bases de datos).\n\n"
            "- **Rápido de aprender**: Ideal para principiantes en desarrollo web con Python.\n\n"
            "- **Flexible**: No impone una arquitectura rígida, puedes personalizarla a tu gusto.\n"
            "\n"
            "### 🚀 **Instalación de Flask**\n\n"
            "Asegúrate de tener Python instalado y ejecuta:\n"
            "```bash\n\n"
            "pip install Flask\n"
            "```\n"
            "\n"
            "### 📄 Ejemplo básico con Flask\n"
            "```python\n\n"
            "from flask import Flask\n"
            "\n"
            "app = Flask(__name__)\n"
            "\n"
            "@app.route('/')\n\n"
            "def home():\n\n"
            '    return "¡Hola, Flask!"\n'
            "\n"
            "if __name__ == '__main__':\n\n"
            "    app.run(debug=True)\n"
            "```\n\n"
            "**Cómo ejecutarlo**:\n"
            "```bash\n\n"
            "python app.py\n"
            "```\n\n"
            "Accede a `http://localhost:5000` en tu navegador.\n"
            "\n"
            "### 📚 Recursos adicionales\n\n"
            "- [Documentación oficial de Flask](https://flask.palletsprojects.com/)\n\n"
            "- Comandos útiles:\n"
            "    flask run          # Ejecutar la aplicación\n\n"
            "    export FLASK_ENV=development  # Activar modo desarrollo\n"
            "\n"
            "*¿Quieres que profundice en alguna parte o necesitas más ejemplos?* 🚀\n"
            "\n"
            "\n"          
                        
    ),

    (
        "sqlite",
        "Guía sencilla para implementar una *base de datos SQLite* con *Python*. SQLite es una base de datos ligera y embebida, perfecta para proyectos pequeños o medianos.\n"
        "\n"
        "# 📚 ¿Qué es SQLite?\n\n"
        "SQLite es una *base de datos relacional* que no necesita un servidor separado para funcionar. Python incluye *SQLite* de forma nativa con el módulo `sqlite3`.\n"
        "\n"
        "### 🛠️Pasos para implementar SQLite en Python\n"
        "\n"
        "### 1. Crear una conexión a SQLite\n"
        "```python\n"
        "import sqlite3\n"
        "\n"
        "# Conectar a la base de datos (crea el archivo si no existe)\n\n"
        'conexion = sqlite3.connect("mi_base_de_datos.db")\n'
        "\n"
        "# Crear un cursor para ejecutar comandos SQL\n\n"
        "cursor = conexion.cursor()\n"
        "```\n"
        "\n"
        "### 2. Crear una tabla\n"
        "```python\n"
        "# Crear una tabla llamada 'usuarios'\n\n"
        "cursor.execute('''\n\n"
        "CREATE TABLE IF NOT EXISTS usuarios (\n\n"
        "    id INTEGER PRIMARY KEY AUTOINCREMENT,\n\n"
        "    nombre TEXT NOT NULL,\n\n"
        "    edad INTEGER,\n\n"
        "    email TEXT UNIQUE\n\n"
        ")\n\n"
        "''')\n"
        "\n"
        'print("Tabla creada con éxito")\n'
        "\n"
        "# Guardar cambios y cerrar la conexión\n\n"
        "conexion.commit()\n\n"
        "conexion.close()\n"
        "```\n"
        "\n"
        "### 3. Insertar datos\n"
        "```python\n\n"
        'conexion = sqlite3.connect("mi_base_de_datos.db")\n\n'
        "cursor = conexion.cursor()\n"
        "\n"
        "# Insertar un registro\n\n"
        "cursor.execute('''\n\n"
        "INSERT INTO usuarios (nombre, edad, email)\n\n"
        "VALUES ('Juan Pérez', 30, 'juan@example.com')\n\n"
        "''')\n"
        "\n"
        "# Confirmar los cambios\n\n"
        "conexion.commit()\n\n"
        'print("Usuario insertado con éxito")\n'
        "\n"
        "conexion.close()\n"
        "```\n"
        "\n"
        "### 4. Consultar datos\n"
        "```python\n\n"
        'conexion = sqlite3.connect("mi_base_de_datos.db")\n\n'
        "cursor = conexion.cursor()\n"
        "\n"
        "# Consultar todos los registros\n\n"
        'cursor.execute("SELECT * FROM usuarios")\n\n'
        "usuarios = cursor.fetchall()\n"
        "\n"
        "for usuario in usuarios:\n\n"
        "    print(usuario)  # Muestra cada fila como una tupla\n"
        "\n"
        "conexion.close()\n"
        "```\n"
        "\n"
        "### 5. Actualizar registros\n"
        "```python\n\n"
        'conexion = sqlite3.connect("mi_base_de_datos.db")\n\n'
        "cursor = conexion.cursor()\n"
        "\n"
        "# Actualizar la edad de un usuario\n\n"
        "cursor.execute('''\n\n"
        "UPDATE usuarios\n\n"
        "SET edad = 35\n\n"
        "WHERE nombre = 'Juan Pérez'\n\n"
        "''')\n"
        "\n"
        "conexion.commit()\n\n"
        'print("Usuario actualizado con éxito")\n\n'
        "conexion.close()\n"
        "```\n"
        "\n"
        "### 6. Eliminar registros\n"
        "```python\n\n"
        'conexion = sqlite3.connect("mi_base_de_datos.db")\n\n'
        "cursor = conexion.cursor()\n"
        "\n"
        "# Eliminar un usuario por su nombre\n\n"
        "cursor.execute('''\n\n"
        "DELETE FROM usuarios\n\n"
        "WHERE nombre = 'Juan Pérez'\n\n"
        "''')\n"
        "\n"
        "conexion.commit()\n\n"
        'print("Usuario eliminado con éxito")\n\n'
        "conexion.close()\n"
        "```\n"
        "\n"
        "## 🔍 Consejos adicionales\n\n"
        "**1. Evitar inyección SQL**: Usa parámetros en las consultas.\n"
        "```python\n"
        '   cursor.execute("INSERT INTO usuarios (nombre, edad) VALUES (?, ?)", ("Ana", 25))\n'
        "   ```\n"
        "**2. Inspeccionar la base de datos**: Puedes usar herramientas como **DB Browser for SQLite**.\n"
        "\n"
        "*¿Quieres profundizar en transacciones, relaciones o algo más?* 🚀\n"
        "\n"
        "\n"
    ),

    (
        "md",
        "**Markdown** es un lenguaje ligero de marcado que se usa para dar formato a textos de manera sencilla. Aunque no está directamente relacionado con **Python**, puedes usar **Markdown** para documentar código Python en archivos como `README.md`, en **Jupyter Notebooks**, o en plataformas como **GitHub**. Aquí tienes una guía con los comandos más usados en **Markdown** y cómo aplicarlos para documentar tus proyectos en Python:\n"
        "\n"
        "## 📋 **Guía de comandos Markdown**\n"
        "\n"
        "### 1. **Encabezados (Títulos)**  \n\n"
        "Se crean usando el símbolo `#` seguido de un espacio.\n"
        "\n"
        "```markdown\n\n"
        "# Título de nivel 1\n\n"
        "## Título de nivel 2\n\n"
        "### Título de nivel 3\n"
        "```\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "# Proyecto de Python: Calculadora\n\n"
        "## Descripción\n\n"
        "Este programa realiza operaciones básicas: suma, resta, multiplicación y división.\n"
        "```\n"
        "\n"
        "### 2. **Negrita y Cursiva**\n\n"
        "- **Negrita**: Usa `**texto**` o `__texto__`\n\n"
        "- *Cursiva*: Usa `*texto*` o `_texto_`\n\n"
        "- ***Negrita y cursiva***: Usa `***texto***`\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "**Función principal**\n\n"
        "*Este programa está desarrollado en Python 3.*\n"
        "```\n"
        "\n"
        "### 3. **Código en línea y bloques de código**\n\n"
        "- **Código en línea**: Usa una comilla invertida \(`)\n\n"
        "- **Bloque de código**: Usa tres comillas invertidas (\`\`\`) con el lenguaje especificado.\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "Llama a la función con:\n"
        "\n"
        "```python\n\n"
        "suma(2, 3)\n"
        "```\n"
        "```\n"
        "\n"
        "### 4. **Listas**\n\n"
        "- **Lista no ordenada**: Usa `-`, `*` o `+`\n\n"
        "- **Lista ordenada**: Usa números seguidos de un punto (`1.`, `2.`, etc.)\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "### Funciones implementadas:\n"
        "\n"
        "- Sumar\n\n"
        "- Restar\n\n"
        "- Multiplicar\n\n"
        "- Dividir\n"
        "\n"
        "### Pasos para ejecutar:\n\n"
        "1. Clonar el repositorio\n\n"
        "2. Instalar dependencias\n\n"
        "3. Ejecutar `main.py`\n"
        "```\n"
        "\n"
        "### 5. **Enlaces e Imágenes**\n\n"
        "- **Enlace**: `[Texto del enlace](URL)`\n\n"
        "- **Imagen**: `![Texto alternativo](ruta/imagen.png)`\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "[Documentación oficial de Python](https://www.python.org)\n"
        "\n"
        "![Logo de Python](https://www.python.org/static/community_logos/python-logo.png)\n"
        "```\n"
        "\n"
        "### 6. **Tablas**\n\n"
        "Para crear tablas, usa el símbolo `|` para las columnas y `-` para dividir el encabezado del contenido.\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "| Función      | Descripción               |\n\n"
        "|--------------|---------------------------|\n\n"
        "| `suma()`     | Realiza una suma          |\n\n"
        "| `resta()`    | Realiza una resta         |\n\n"
        "| `multiplica()` | Multiplica dos números    |\n\n"
        "| `divide()`   | Divide dos números         |\n"
        "```\n"
        "\n"
        "### 7. **Citas (Blockquotes)**\n\n"
        "Usa el símbolo `>` al inicio de la línea.\n"
        "\n"
        "📝 **Ejemplo en Python**:\n"
        "```markdown\n\n"
        "> Este proyecto está basado en Python 3.10.\n"
        "```\n"
        "\n"
        "### 8. **Líneas divisorias**\n\n"
        "Se crean usando tres guiones `---`, asteriscos `***` o guiones bajos `___`.\n"
        "\n"
        "```markdown\n"
        "```\n"
        "\n"
        "### 📚 **Ejemplo Completo en Markdown para Python**\n"
        "```markdown\n\n"
        "# 📊 Calculadora en Python\n"
        "\n"
        "## 📌 Descripción\n\n"
        "Este proyecto es una calculadora básica en **Python** que realiza operaciones como:\n"
        "\n"
        "- Suma\n\n"
        "- Resta\n\n"
        "- Multiplicación\n\n"
        "- División\n"
        "\n"
        "## 🔧 Requisitos\n\n"
        "- Python 3.10 o superior\n\n"
        "- Librerías: Ninguna externa\n"
        "\n"
        "## 📋 Uso\n"
        "\n"
        "```python\n\n"
        "# Ejecutar la calculadora\n\n"
        "from calculadora import suma\n"
        "\n"
        "resultado = suma(5, 3)\n\n"
        'print(f"Resultado: {resultado}")\n'
        "```\n"
        "\n"
        "## 📄 Documentación\n\n"
        "Para más detalles, consulta la [documentación oficial de Python](https://www.python.org).\n"
        "```\n"
        "\n"
        "* ¿Quieres que te ayude a crear un **README.md** para tu proyecto en Python? * 🚀\n"
        "\n"
        "\n"
    ),

    (
        "prue2",
        "# h1 titulo\n"
        "## h2 subtitulo\n"
        "### h3 susubtitulo\n"
        "* texto en cursiva *\n"
        "**texto en negrita**\n"
        "Texto normal\n"
    ),

    (
        "spring boot",
        "## Introducción a Spring Boot\n"
        "\n"
        "Spring Boot es un framework de Java basado en Spring que facilita la creación de aplicaciones empresariales y microservicios. Su objetivo principal es simplificar la configuración y puesta en marcha de aplicaciones Spring, eliminando la necesidad de una configuración extensa.\n"
        "\n"
        "### Características principales:\n\n"
        "- **Autoconfiguración**: Spring Boot configura automáticamente los componentes según las dependencias presentes en el proyecto.\n\n"
        "- **Standalone**: No requiere un servidor de aplicaciones externo como Tomcat o Jetty.\n\n"
        "- **Manejo de dependencias**: Usa `Spring Boot Starter` para gestionar dependencias fácilmente.\n\n"
        "- **Spring Boot Actuator**: Proporciona monitoreo y métricas para aplicaciones en producción.\n"
        "\n"
        "## Ejemplo de uso\n"
        "\n"
        "A continuación, un ejemplo de una aplicación simple con Spring Boot que expone un servicio REST.\n"
        "\n"
        "### 1. Agregar dependencias en `pom.xml`\n"
        "\n"
        "```\n\n"
        "<dependencies>\n\n"
        "    <!-- Dependencia principal de Spring Boot -->\n\n"
        "    <dependency>\n\n"
        "        <groupId>org.springframework.boot</groupId>\n\n"
        "        <artifactId>spring-boot-starter-web</artifactId>\n\n"
        "    </dependency>\n"
        "    \n"
        "    <!-- Plugin de Spring Boot -->\n\n"
        "    <dependency>\n\n"
        "        <groupId>org.springframework.boot</groupId>\n\n"
        "        <artifactId>spring-boot-starter-test</artifactId>\n\n"
        "        <scope>test</scope>\n\n"
        "    </dependency>\n\n"
        "</dependencies>\n"
        "```\n"
        "\n"
        "### 2. Crear la clase principal `Application.java`\n"
        "\n"
        "```\n\n"
        "import org.springframework.boot.SpringApplication;\n\n"
        "import org.springframework.boot.autoconfigure.SpringBootApplication;\n"
        "\n"
        "@SpringBootApplication\n\n"
        "public class Application {\n\n"
        "    public static void main(String[] args) {\n\n"
        "        SpringApplication.run(Application.class, args);\n\n"
        "    }\n\n"
        "}\n"
        "```\n"
        "\n"
        "### 3. Crear un controlador REST `HelloController.java`\n"
        "\n"
        "```\n\n"
        "import org.springframework.web.bind.annotation.GetMapping;\n\n"
        "import org.springframework.web.bind.annotation.RequestMapping;\n\n"
        "import org.springframework.web.bind.annotation.RestController;\n"
        "\n"
        "@RestController\n\n"
        "@RequestMapping('/api')\n\n"
        "public class HelloController {\n"
        "\n"
        "    @GetMapping('/hello')\n\n"
        "    public String sayHello() {\n\n"
        "        return '¡Hola desde Spring Boot!';\n\n"
        "    }\n\n"
        "}\n"
        "```\n"
        "\n"
        "### 4. Ejecutar la aplicación\n"
        "\n"
        "Para iniciar la aplicación, usa el siguiente comando en la terminal:\n"
        "\n"
        "```\n\n"
        "mvn spring-boot:run\n"
        "```\n"
        "\n"
        "### 5. Probar el servicio\n"
        "\n"
        "Una vez en ejecución, puedes acceder a la API en:\n"
        "\n"
        "```\n\n"
        "http://localhost:8080/api/hello\n"
        "```\n"
        "\n"
        "Este endpoint responderá con:\n"
        "\n"
        "```\n\n"
        "¡Hola desde Spring Boot!\n"
        "```\n"
        "\n"
        "Este es un ejemplo básico de cómo se puede utilizar Spring Boot para crear una API REST. 🚀\n"
    ),
        
     (
        "funcion",
        "## ¿Qué es una función en Python?\n\n"
        "Una *función* es un bloque de código reutilizable que ejecuta una tarea específica. Se define con la palabra clave `def` y se puede invocar (llamar) en cualquier parte del programa.\n"
        "\n"
        "### **Pasos clave en el uso de funciones en Python**\n\n"
        "1. **Definir la función**  \n\n"
        "   Se usa la palabra clave `def`, seguida del nombre de la función y paréntesis (). \n"
        "```\n\n"
        "   def nombre_funcion():\n\n"
        "       # Código de la función\n"
        "```\n"
        "   \n"
        "2. **Parámetros (Opcional)**  \n\n"
        "   Se pueden definir parámetros dentro de los paréntesis para recibir valores externos.  \n"
        "```\n\n"
        '   def sumar(a, b):  # "a" y "b" son parámetros\n\n'
        "       return a + b\n"
        "```\n"
        "\n"
        "3. **Cuerpo de la función**  \n\n"
        "   Es el bloque de código que se ejecutará cuando se llame la función.  \n\n"
        "   Debe estar indentado con 4 espacios (según PEP 8).  \n"
        "\n"
        "4. **Valor de retorno (Opcional)**  \n\n"
        "   Se usa `return` para devolver un resultado al llamador.  \n"
        "```\n\n"
        "   def cuadrado(x):\n\n"
        "       return x * x\n"
        "```\n"
        "\n"
        "5. **Llamar a la función**  \n\n"
        "   Una vez definida, se puede invocar escribiendo su nombre y pasando argumentos si los requiere.  \n"
        "```\n\n"
        "   resultado = cuadrado(5)\n\n"
        "   print(resultado)  # Salida: 25\n"
        "```\n"
        "\n"
        "## **Ejemplo Completo**\n"
        "```\n\n"
        "def calcular_area_rectangulo(base, altura):\n\n"
        "    #Calcula el área de un rectángulo dado su base y altura.\n\n"
        "    area = base * altura\n\n"
        "    return area  # Devuelve el área calculada\n"
        "\n"
        "# Llamamos la función pasando valores\n\n"
        "resultado = calcular_area_rectangulo(5, 10)\n\n"
        "print(f'El área del rectángulo es: {resultado}')  # Salida: 50\n"
        "```\n"
        "\n"
        "## **Tipos de Funciones**\n\n"
        "### **1. Función sin parámetros ni retorno**\n"
        "```\n\n"
        "def mensaje():\n\n"
        "    print('Hola, bienvenido a la auditoría de código')\n"
        "\n"
        "mensaje()  # Salida: Hola, bienvenido a la auditoría de código\n"
        "```\n"
        "\n"
        "### **2. Función con parámetros**\n"
        "```\n\n"
        "def saludar(nombre):\n\n"
        "    print(f'Hola, {nombre}!')\n"
        "\n"
        "saludar('Ana')  # Salida: Hola, Ana!\n"
        "```\n"
        "\n"
        "### **3. Función con retorno**\n"
        "```\n\n"
        "def multiplicar(x, y):\n\n"
        "    return x * y\n"
        "\n"
        "resultado = multiplicar(3, 4)\n\n"
        "print(resultado)  # Salida: 12\n"
        "```\n"
        "\n"
        "### **4. Función con valores por defecto**\n"
        "```\n\n"
        "def potencia(base, exponente=2):\n\n"
        "    return base ** exponente\n"
        "\n"
        "print(potencia(5))      # Salida: 25 (porque el exponente por defecto es 2)\n\n"
        "print(potencia(5, 3))   # Salida: 125\n"
        "```\n"
        "\n"
        "### **5. Función con número variable de argumentos (`*args`)**\n"
        "```\n\n"
        "def suma(*numeros):\n\n"
        "    return sum(numeros)\n"
        "\n"
        "print(suma(1, 2, 3, 4))  # Salida: 10\n"
        "```\n"
        "\n"
        "### **6. Función con argumentos nombrados (`**kwargs`)**\n"
        "```\n\n"
        "def mostrar_info(**datos):\n\n"
        "    for clave, valor in datos.items():\n\n"
        "        print(f'{clave}: {valor}')\n"
        "\n"
        "mostrar_info(nombre='Carlos', edad=30, ciudad='Madrid')\n"
        "```\n\n"
        "**Salida:**\n"
        "```\n\n"
        "nombre: Carlos\n\n"
        "edad: 30\n\n"
        "ciudad: Madrid\n"
        "```\n"
        "\n"
        "## **Buenas prácticas para auditoría**\n\n"
        "1. **Nombres descriptivos**  \n\n"
        "   ✅ `calcular_promedio()` en vez de ❌ `calc()`\n"
        "\n"
        "2. **Documentar con `docstrings`**  \n"
        "```\n\n"
        "   def division(a, b):\n\n"
        "       #Devuelve el resultado de dividir a entre b.\n\n"
        "       return a / b\n"
        "```\n"
        "\n"
        "3. **Evitar efectos secundarios**  \n\n"
        "   - No modificar variables globales dentro de una función.\n\n"
        "   - Usar `return` en lugar de `print()` cuando se requiere un valor.\n"
        "\n"
        "4. **Evitar funciones demasiado largas**  \n\n"
        "   - Si una función hace muchas cosas, divídela en funciones más pequeñas.\n"
        "\n"
        "5. **Uso adecuado de excepciones**  \n"
        "```\n\n"
        "   def dividir(a, b):\n\n"
        "       try:\n\n"
        "           return a / b\n\n"
        "       except ZeroDivisionError:\n\n"
        "           return 'No se puede dividir entre cero'\n"
        "```\n"
        "\n"
        "*Si necesitas algo más específico para la auditoría, dime cómo quieres que lo enfoquemos.* 😊\n"
    ),

    (
        "modulo",
        "# 📌 1. ¿Qué es un módulo en Python?\n\n"
        "Un **módulo** es simplemente un archivo *.py* que contiene código Python (funciones, variables, clases, etc.). Los módulos permiten organizar el código en archivos reutilizables.\n"
        "\n\n"
        "### 🔹 Ejemplo de módulo en Python  \n\n"
        "Supongamos que creamos un archivo llamado `mimodulo.py` con la siguiente función:\n"
        "\n"
        "```\n\n"
        "# mimodulo.py\n\n"
        "def saludar(nombre):\n\n"
        "    return f'Hola, {nombre}!'\n"
        "```\n"
        "\n"
        "Ahora podemos importar este módulo en otro archivo y usar su función.\n"
        "\n"
        "```\n\n"
        "# script.py\n\n"
        "import mimodulo\n"
        "\n"
        "print(mimodulo.saludar('Carlos'))  # Output: Hola, Carlos!\n"
        "```\n"
        "\n"
        "También podemos importar solo una función específica:\n"
        "\n"
        "```\n\n"
        "from mimodulo import saludar\n"
        "\n"
        "print(saludar('Ana'))  # Output: Hola, Ana!\n"
        "```\n"
        "\n"
        "Si queremos cambiar el nombre de la función al importarla:\n"
        "\n"
        "```\n\n"
        "from mimodulo import saludar as mi_saludo\n"
        "\n"
        "print(mi_saludo('Luis'))  # Output: Hola, Luis!\n"
        "```\n"
        "\n"
        "# 📌 2. ¿Qué es un paquete en Python?\n\n"
        "Un **paquete** es una carpeta que contiene módulos organizados. Para que Python reconozca una carpeta como un paquete, debe incluir un archivo especial llamado `__init__.py`.  \n"
        "\n"
        "### 🔹 Estructura de un paquete\n\n"
        "Supongamos que tenemos la siguiente estructura de archivos:\n"
        "\n"
        "```\n\n"
        "mi_proyecto/\n\n"
        "│── main.py\n\n"
        "│── utilidades/\n\n"
        "│   │── __init__.py\n\n"
        "│   │── calculadora.py\n\n"
        "│   │── texto.py\n"
        "```\n"
        "\n"
        "### 🔹 Contenido de los módulos dentro del paquete  \n"
        "\n"
        "### Archivo :`calculadora.py`\n"
        "```\n\n"
        "# utilidades/calculadora.py\n\n"
        "def sumar(a, b):\n\n"
        "    return a + b\n"
        "\n"
        "def restar(a, b):\n\n"
        "    return a - b\n"
        "```\n"
        "\n"
        "### Archivo :`texto.py`\n"
        "```\n\n"
        "# utilidades/texto.py\n\n"
        "def contar_letras(texto):\n\n"
        "    return len(texto)\n"
        "```\n"
        "\n"
        "### Archivo :`__init__.py`\n\n"
        "Este archivo se usa para **indicar que la carpeta es un paquete** y puede estar vacío o contener código de inicialización.\n"
        "\n"
        "```\n\n"
        "# utilidades/__init__.py\n\n"
        "from .calculadora import sumar, restar\n\n"
        "from .texto import contar_letras\n"
        "```\n"
        "\n"
        "Ahora podemos usar nuestro paquete en : `main.py`:\n"
        "\n"
        "```\n\n"
        "# main.py\n\n"
        "from utilidades import sumar, contar_letras\n"
        "\n"
        "print(sumar(5, 3))  # Output: 8\n\n"
        "print(contar_letras('Python'))  # Output: 6\n"
        "```\n"
        "\n"
        "También podemos importar módulos específicos:\n"
        "\n"
        "```\n\n"
        "from utilidades.calculadora import restar\n"
        "\n"
        "print(restar(10, 4))  # Output: 6\n"
        "```\n"
        "\n"
        "# 📌 3. Diferentes formas de importación\n\n"
        "Python permite diferentes maneras de importar módulos:\n"
        "\n"
        "1. **Importación completa del módulo**\n"
        "```\n"
        "   import utilidades.calculadora\n\n"
        "   print(utilidades.calculadora.sumar(2, 3))  # Output: 5\n"
        "```\n"
        "\n"
        "2. **Importar solo funciones específicas**\n"
        "```\n\n"
        "   from utilidades.calculadora import sumar\n\n"
        "   print(sumar(2, 3))  # Output: 5\n"
        "```\n\n"
        "3. **Importar con alias**\n"
        "```\n\n"
        "   import utilidades.calculadora as calc\n\n"
        "   print(calc.sumar(2, 3))  # Output: 5\n"
        "```\n"
        "\n"
        "# 📌 4. Estructura recomendada para proyectos en Python\n\n"
        "Para mantener un código limpio y bien organizado en un proyecto real, se recomienda una estructura como esta:\n"
        "\n"
        "```\n\n"
        "mi_proyecto/\n\n"
        "│── src/\n\n"
        "│   │── __init__.py\n\n"
        "│   │── modulo1.py\n\n"
        "│   │── modulo2.py\n\n"
        "│── tests/\n\n"
        "│   │── test_modulo1.py\n\n"
        "│   │── test_modulo2.py\n\n"
        "│── docs/\n\n"
        "│── requirements.txt\n\n"
        "│── README.md\n\n"
        "│── setup.py\n"
        "```\n"
        "\n"
        "### 📌 Explicación de cada parte:\n\n"
        "- `src/` → Contiene el código fuente del proyecto.\n\n"
        "- `tests/` → Contiene pruebas unitarias para cada módulo.\n\n"
        "- `docs/` → Documentación del proyecto.\n\n"
        "- `requirements.txt` → Lista de dependencias del proyecto.\n\n"
        "- `README.md` → Información sobre el proyecto.\n\n"
        "- `setup.py` → Archivo de instalación si el proyecto es distribuible.\n"
        "\n"
        "### 📌 **5. Consideraciones finales**\n\n"
        "✅ Los módulos permiten organizar mejor el código y reutilizar funciones.  \n\n"
        "✅ Los paquetes ayudan a estructurar proyectos más grandes.  \n\n"
        "✅ Usar `__init__.py` facilita la inicialización de paquetes.  \n\n"
        "✅ Seguir una buena estructura de carpetas ayuda a mantener el orden en proyectos grandes.  \n"
    ),

    (
        "iterador",
        "# 📌 1. ¿Qué es un Iterador en Python?\n\n"
        "Un **iterador** es un objeto que implementa los métodos especiales:\n\n"
        "- `__iter__()` → Devuelve el objeto iterador.\n\n"
        "- `__next__()` → Devuelve el siguiente elemento de la secuencia.  \n"
        "\n"
        "Los iteradores permiten recorrer elementos **uno por uno**, sin necesidad de almacenar toda la secuencia en memoria.\n"
        "\n"
        "### 🔹 Ejemplo de un iterador en Python\n\n"
        "Podemos crear una clase que actúe como un iterador:\n"
        "\n"
        "```\n\n"
        "class Contador:\n\n"
        "    def __init__(self, inicio, fin):\n\n"
        "        self.actual = inicio\n\n"
        "        self.fin = fin\n"
        "\n"
        "    def __iter__(self):\n\n"
        "        return self  # Un iterador debe devolver `self`\n"
        "\n"
        "    def __next__(self):\n\n"
        "        if self.actual > self.fin:\n\n"
        "            raise StopIteration  # Detiene la iteración\n\n"
        "        valor = self.actual\n\n"
        "        self.actual += 1\n\n"
        "        return valor\n"
        "\n"
        "# Usando el iterador\n\n"
        "mi_contador = Contador(1, 5)\n\n"
        "for numero in mi_contador:\n\n"
        "    print(numero)  # Output: 1, 2, 3, 4, 5\n"
        "```\n"
        "\n"
        "## 📌 2. ¿Qué es un Generador en Python?\n\n"
        "Un **generador** es una función especial que utiliza `yield` en lugar de `return`.  \n\n"
        "La diferencia clave entre una función normal y un generador es que **el estado del generador se guarda entre llamadas**.\n"
        "\n"
        "### 🔹 Ejemplo básico de generador\n"
        "```\n\n"
        "def contar(inicio, fin):\n\n"
        "    while inicio <= fin:\n\n"
        "        yield inicio  # Guarda el estado y devuelve el valor\n\n"
        "        inicio += 1\n"
        "\n"
        "# Usando el generador\n\n"
        "for numero in contar(1, 5):\n\n"
        "    print(numero)  # Output: 1, 2, 3, 4, 5\n"
        "```\n"
        "\n"
        "Aquí, `yield` permite **pausar y reanudar** la ejecución de la función sin perder el estado.\n"
        "\n"
        "## 📌 3. Creación de Generadores Personalizados\n\n"
        "Los generadores son muy útiles cuando se trabaja con **grandes cantidades de datos**, porque no almacenan toda la secuencia en memoria.\n"
        "\n"
        "### 🔹 Ejemplo: Generador de números pares\n"
        "```\n\n"
        "def numeros_pares(limite):\n\n"
        "    num = 0\n\n"
        "    while num <= limite:\n\n"
        "        yield num\n\n"
        "        num += 2\n"
        "\n"
        "# Usando el generador\n\n"
        "for par in numeros_pares(10):\n\n"
        "    print(par)  # Output: 0, 2, 4, 6, 8, 10\n"
        "```\n"
        "\n"
        "### 🔹 **Ejemplo: Generador de Fibonacci**\n"
        "```\n\n"
        "def fibonacci(n):\n\n"
        "    a, b = 0, 1\n\n"
        "    for _ in range(n):\n\n"
        "        yield a\n\n"
        "        a, b = b, a + b\n"
        "\n"
        "# Usando el generador\n\n"
        "for num in fibonacci(6):\n\n"
        "    print(num)  # Output: 0, 1, 1, 2, 3, 5\n"
        "```\n"
        "\n"
        "## 📌 4. Uso de yield from para Delegar Generadores\n\n"
        "Si queremos llamar a otro generador desde dentro de un generador, podemos usar `yield from`:\n"
        "\n"
        "```\n\n"
        "def sub_generador():\n\n"
        "    yield 'Hola'\n\n"
        "    yield 'Mundo'\n"
        "\n"
        "def generador_principal():\n\n"
        "    yield from sub_generador()\n\n"
        "    yield 'Python'\n"
        "\n"
        "for palabra in generador_principal():\n\n"
        "    print(palabra)  # Output: Hola, Mundo, Python\n"
        "```\n"
        "\n"
        "`yield from` **delegará** la ejecución al subgenerador antes de continuar con el código del generador principal.\n"
        "\n"
        "## 📌 5. Creación de un Iterador Personalizado con Generadores\n\n"
        "También podemos combinar iteradores y generadores para una solución más eficiente:\n"
        "\n"
        "```\n\n"
        "class Rango:\n\n"
        "    def __init__(self, inicio, fin):\n\n"
        "        self.inicio = inicio\n\n"
        "        self.fin = fin\n"
        "\n"
        "    def __iter__(self):\n\n"
        "        return self.generador()\n"
        "\n"
        "    def generador(self):\n\n"
        "        num = self.inicio\n\n"
        "        while num <= self.fin:\n\n"
        "            yield num\n\n"
        "            num += 1\n"
        "\n"
        "# Usando la clase iteradora con generadores\n\n"
        "for numero in Rango(1, 5):\n\n"
        "    print(numero)  # Output: 1, 2, 3, 4, 5\n"
        "```\n"
        "\n"
        "## 📌 6. Casos de Uso Comunes de Generadores\n\n"
        "✅ **Lectura de archivos grandes línea por línea**  \n"
        "```\n\n"
        "def leer_lineas(archivo):\n\n"
        "    with open(archivo, 'r') as f:\n\n"
        "        for linea in f:\n\n"
        "            yield linea.strip()\n"
        "\n"
        "for linea in leer_lineas('archivo.txt'):\n\n"
        "    print(linea)\n"
        "```\n"
        "\n"
        "✅ **Generación infinita de números (se detiene manualmente)**  \n"
        "```\n\n"
        "def numeros_infinitos():\n\n"
        "    num = 0\n\n"
        "    while True:\n\n"
        "        yield num\n\n"
        "        num += 1\n"
        "\n"
        "gen = numeros_infinitos()\n\n"
        "print(next(gen))  # Output: 0\n\n"
        "print(next(gen))  # Output: 1\n\n"
        "print(next(gen))  # Output: 2\n"
        "```\n"
        "\n"
        "✅ **Procesamiento eficiente de datos en streams**  \n\n"
        "Generadores son útiles para **procesar datos en tiempo real sin cargar todo en memoria**.\n"
        "\n"
        "# 📌 **7. Conclusión**\n\n"
        "✔️ **Los iteradores** nos permiten recorrer estructuras de datos mediante `__iter__()` y `__next__()`.  \n\n"
        "✔️ **Los generadores** simplifican el manejo de iteraciones con `yield`.  \n\n"
        "✔️ **Usar generadores** es más eficiente en términos de memoria y rendimiento.  \n\n"
        "✔️ **Con `yield from`** podemos delegar la generación de valores en otros generadores.  \n"
    ),

    (
        "decoradores",
        "# 📌 1. ¿Qué es un Decorador en Python?\n\n"
        "Un **decorador** en Python es una función que **modifica el comportamiento de otra función** sin cambiar su código fuente. Se usa con el símbolo `@` antes de la función a decorar.\n"
        "\n"
        "Los decoradores son útiles para:\n\n"
        "✅ **Añadir funcionalidades** sin modificar la función original.  \n\n"
        "✅ **Aplicar lógica antes y/o después** de la ejecución de una función.  \n\n"
        "✅ **Reutilizar código** en múltiples funciones.  \n"
        "\n"
        "## 📌 2. Creación de un Decorador en Python\n\n"
        "Un decorador es una **función que recibe otra función** como argumento, añade funcionalidad y devuelve una nueva función.\n"
        "\n"
        "### 🔹 Ejemplo básico de decorador\n"
        "```\n\n"
        "def mi_decorador(funcion):\n\n"
        "    def funcion_modificada():\n\n"
        "        print('Antes de ejecutar la función')\n\n"
        "        funcion()\n\n"
        "        print('Después de ejecutar la función')\n\n"
        "    return funcion_modificada\n"
        "\n"
        "@mi_decorador  # Aplicando el decorador\n\n"
        "def saludo():\n\n"
        "    print('Hola, mundo!')\n"
        "\n"
        "saludo()\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "Antes de ejecutar la función\n\n"
        "Hola, mundo!\n\n"
        "Después de ejecutar la función\n"
        "```\n\n"
        "✅ **El decorador añade mensajes antes y después de ejecutar la función original.**  \n"
        "\n"
        "## 📌 3. Uso de args y kwargs en Decoradores\n\n"
        "Para permitir decoradores en funciones con cualquier número de argumentos, usamos `*args` y `**kwargs`.\n"
        "\n"
        "### 🔹 Ejemplo de decorador con argumentos variables\n"
        "```\n\n"
        "def decorador(func):\n\n"
        "    def funcion_modificada(*args, **kwargs):\n\n"
        "        print('Inicio de la función')\n\n"
        "        resultado = funcion(*args, **kwargs)\n\n"
        "        print('Fin de la función')\n\n"
        "        return resultado\n\n"
        "    return funcion_modificada\n"
        "\n"
        "@decorador\n\n"
        "def suma(a, b):\n\n"
        "    return a + b\n"
        "\n"
        "print(suma(3, 5))  # Output: Inicio de la función, Fin de la función, 8\n"
        "```\n\n"
        "✅ **El decorador puede aplicarse a cualquier función sin importar sus parámetros.**\n"
        "\n"
        "## 📌 4. Decoradores con Parámetros\n\n"
        "Si queremos que un decorador acepte parámetros, usamos una **función que devuelve un decorador**.\n"
        "\n"
        "### 🔹 Ejemplo de decorador con parámetros\n"
        "```\n\n"
        "def repetir(n):\n\n"
        "    def decorador(func):\n\n"
        "        def funcion_modificada(*args, **kwargs):\n\n"
        "            for _ in range(n):\n\n"
        "                func(*args, **kwargs)\n\n"
        "        return funcion_modificada\n\n"
        "    return decorador\n"
        "\n"
        "@repetir(3)  # Ejecutará la función 3 veces\n\n"
        "def mensaje():\n\n"
        "    print('Hola!')\n"
        "\n"
        "mensaje()\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "Hola!\n\n"
        "Hola!\n\n"
        "Hola!\n"
        "```\n\n"
        "✅ El decorador `@repetir(3)` permite repetir la ejecución de la función.\n"
        "\n"
        "## 📌 5. Decoradores Múltiples\n\n"
        "Podemos aplicar **varios decoradores** a una misma función. Se ejecutan de arriba hacia abajo.\n"
        "\n"
        "### 🔹 Ejemplo con múltiples decoradores\n"
        "```\n\n"
        "def mayusculas(func):\n\n"
        "    def funcion_modificada():\n\n"
        "        return func().upper()\n\n"
        "    return funcion_modificada\n"
        "\n"
        "def exclamacion(func):\n\n"
        "    def funcion_modificada():\n\n"
        "        return func() + '!!!'\n\n"
        "    return funcion_modificada\n"
        "\n"
        "@mayusculas\n\n"
        "@exclamacion\n\n"
        "def saludo():\n\n"
        "    return 'hola'\n"
        "\n"
        "print(saludo())  # Output: HOLA!!!\n"
        "```\n\n"
        "✅ **El decorador `@mayusculas` convierte el texto en mayúsculas y `@exclamacion` añade '!!!'.**  \n"
        "\n"
        "## 📌 6. Decoradores en Clases:\n"
        "*@property*\n"
        "*@classmethod*\n"
        "*@staticmethod*\n"
        "\n"
        "Python tiene decoradores incorporados para clases.\n"
        "\n"
        "### 🔹 Ejemplo con @property\n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre):\n\n"
        "        self._nombre = nombre\n"
        "\n"
        "    @property\n\n"
        "    def nombre(self):\n\n"
        "        return self._nombre\n"
        "\n"
        "    @nombre.setter\n\n"
        "    def nombre(self, nuevo_nombre):\n\n"
        "        self._nombre = nuevo_nombre\n"
        "\n"
        "persona = Persona('Carlos')\n\n"
        "print(persona.nombre)  # Output: Carlos\n\n"
        "persona.nombre = 'Ana'\n\n"
        "print(persona.nombre)  # Output: Ana\n"
        "```\n\n"
        "✅ **@property permite acceder a un método como si fuera un atributo.**  \n"
        "\n"
        "## 📌 7. Aplicaciones Prácticas de Decoradores\n\n"
        "Los decoradores se usan en **registros de ejecución, validaciones, control de acceso, caching, etc.**  \n"
        "\n"
        "### 🔹 Ejemplo: Registro de ejecución\n"
        "```\n\n"
        "def log(func):\n\n"
        "    def funcion_modificada(*args, **kwargs):\n\n"
        "        print(f'Llamando a {func.__name__} con argumentos {args} {kwargs}')\n\n"
        "        resultado = func(*args, **kwargs)\n\n"
        "        print(f'{func.__name__} retornó {resultado}')\n\n"
        "        return resultado\n\n"
        "    return funcion_modificada\n"
        "\n"
        "@log\n\n"
        "def multiplicar(a, b):\n\n"
        "    return a * b\n"
        "\n"
        "multiplicar(4, 3)\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "Llamando a multiplicar con argumentos (4, 3) {}\n\n"
        "multiplicar retornó 12\n"
        "```\n\n"
        "✅ **El decorador `@log` permite registrar las llamadas a funciones.**  \n"
        "\n"
        "## 📌 8. Decoradores en Flask y Django\n\n"
        "Los frameworks web como **Flask y Django** usan decoradores para definir rutas y vistas.\n"
        "\n"
        "### 🔹 Ejemplo en Flask\n"
        "```\n\n"
        "from flask import Flask\n"
        "\n"
        "app = Flask(__name__)\n"
        "\n"
        "@app.route('/')\n\n"
        "def inicio():\n\n"
        "    return 'Bienvenido a mi API'\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    app.run()\n"
        "```\n\n"
        "✅ **Aquí `@app.route('/')` define la ruta del servidor web.**  \n"
        "\n"
        "## 📌 9. Decoradores en Librerías Estándar de Python\n"
        "\n"
        "### 🔹 Ejemplo con @lru_cache\n"
        "```\n\n"
        "from functools import lru_cache\n"
        "\n"
        "@lru_cache(maxsize=5)\n\n"
        "def factorial(n):\n\n"
        "    if n == 0:\n\n"
        "        return 1\n\n"
        "    return n * factorial(n - 1)\n"
        "\n"
        "print(factorial(5))  # Calcula y cachea el resultado\n\n"
        "print(factorial(5))  # Recupera de la caché\n"
        "```\n\n"
        "✅ **`@lru_cache` almacena los valores calculados para evitar recomputaciones.**\n"
        "\n"
        "### 📌 10. Conclusión\n\n"
        "✔️ **Los decoradores** permiten modificar funciones sin cambiar su código.  \n\n"
        "✔️ **Son reutilizables** y mejoran la organización del código.  \n\n"
        "✔️ **Existen decoradores nativos** (`@staticmethod`, `@classmethod`, `@property`, etc.).  \n\n"
        "✔️ **Se usan en frameworks** como Flask y Django para definir rutas y permisos.  \n"
    ),

    (
        "context managers",
        "# 📌 1. ¿Qué es un Context Manager en Python?\n\n"
        "Un **Context Manager** (o **Administrador de Contexto**) es una estructura en Python que permite **gestionar recursos** (como archivos, conexiones, bloqueos de hilos, etc.) de forma eficiente, asegurando su correcta apertura y cierre.\n"
        "\n"
        "Se usan con la palabra clave **with**, lo que garantiza que los recursos se liberen correctamente, incluso si ocurre una excepción.\n"
        "\n"
        "## 📌 2. Uso de with: Context Managers en Archivos\n\n"
        "La forma más común de un Context Manager es el manejo de archivos:\n"
        "\n"
        "### 🔹 **Ejemplo básico: Lectura de archivos**\n"
        "```\n\n"
        "with open('archivo.txt', 'r') as archivo:\n\n"
        "    contenido = archivo.read()\n\n"
        "    print(contenido)\n\n"
        "# El archivo se cierra automáticamente después del bloque `with`\n"
        "```\n\n"
        "✅ **Ventajas**:\n\n"
        "- No es necesario llamar a `close()`, Python lo hace automáticamente.\n\n"
        "- Evita fugas de memoria y errores si el archivo no se cierra correctamente.\n\n"
        "- Hace que el código sea más limpio y seguro.\n"
        "\n"
        "## 📌 3. Creación de un Context Manager con una Clase\n\n"
        "Podemos definir un Context Manager personalizado usando una **clase con los métodos `__enter__()` y `__exit__()`**.\n"
        "\n"
        "### 🔹 Ejemplo: Creación de un Context Manager con una clase\n"
        "```\n\n"
        "class GestorDeArchivo:\n\n"
        "    def __init__(self, nombre_archivo, modo):\n\n"
        "        self.nombre_archivo = nombre_archivo\n\n"
        "        self.modo = modo\n"
        "\n"
        "    def __enter__(self):\n\n"
        "        self.archivo = open(self.nombre_archivo, self.modo)\n\n"
        "        return self.archivo  # Devuelve el recurso\n"
        "\n"
        "    def __exit__(self, tipo, valor, traceback):\n\n"
        "        self.archivo.close()  # Cierra el archivo automáticamente\n"
        "\n"
        "# Uso del Context Manager\n\n"
        "with GestorDeArchivo('archivo.txt', 'w') as archivo:\n\n"
        "    archivo.write('Hola, este es un archivo de prueba.')\n"
        "```\n\n"
        "✅ **Explicación**:\n\n"
        "- `__enter__()` → Abre el archivo y lo devuelve.\n\n"
        "- `__exit__()` → Se ejecuta al salir del bloque `with`, cerrando el archivo.\n"
        "\n"
        "## 📌 4. Uso de contextlib: Creación de un Context Manager con @contextmanager\n\n"
        "El módulo contextlib permite crear **Context Managers de manera más sencilla** sin necesidad de definir una clase.\n"
        "\n"
        "### 🔹 Ejemplo con @contextmanager\n"
        "```\n\n"
        "from contextlib import contextmanager\n"
        "\n"
        "@contextmanager\n\n"
        "def gestor_archivo(nombre, modo):\n\n"
        "    archivo = open(nombre, modo)\n\n"
        "    try:\n\n"
        "        yield archivo  # Entrega el recurso\n\n"
        "    finally:\n\n"
        "        archivo.close()  # Se ejecuta siempre, incluso en caso de error\n"
        "\n"
        "# Uso del Context Manager\n\n"
        "with gestor_archivo('archivo.txt', 'w') as archivo:\n\n"
        "    archivo.write('Texto de prueba.')\n"
        "```\n\n"
        "✅ **Ventajas de `@contextmanager`**:\n\n"
        "- Código más corto y limpio.\n\n"
        "- No necesita definir una clase con `__enter__()` y `__exit__()`.\n\n"
        "- Garantiza el cierre seguro del recurso.\n"
        "\n"
        "## 📌 5. Manejo de Excepciones en un Context Manager\n\n"
        "El método *__exit__()* permite manejar **excepciones dentro del Context Manager**.\n"
        "\n"
        "### 🔹 Ejemplo con manejo de errores\n"
        "```\n\n"
        "class GestorSeguridad:\n\n"
        "    def __enter__(self):\n\n"
        "        print('Entrando en la sección segura')\n\n"
        "        return self\n"
        "\n"
        "    def __exit__(self, tipo, valor, traceback):\n\n"
        "        if tipo:\n\n"
        "            print(f'Se ha producido un error: {valor}')\n\n"
        "        print('Saliendo de la sección segura')\n\n"
        "        return True  # Evita que la excepción se propague\n"
        "\n"
        "# Uso del Context Manager con error controlado\n\n"
        "with GestorSeguridad():\n\n"
        "    print('Ejecutando código...')\n\n"
        "    raise ValueError('¡Algo salió mal!')  # Error intencional\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "Entrando en la sección segura\n\n"
        "Ejecutando código...\n\n"
        "Se ha producido un error: ¡Algo salió mal!\n\n"
        "Saliendo de la sección segura\n"
        "```\n\n"
        "✅ **Ventajas**:\n\n"
        "- `__exit__()` puede capturar excepciones sin interrumpir el programa.\n\n"
        "- Se puede decidir si la excepción debe propagarse (`return False`) o manejarse internamente (`return True`).\n"
        "\n"
        "# 📌 **6. Ejemplo: Context Manager para Manejo de Conexiones**\n\n"
        "Podemos usar un Context Manager para **manejar conexiones a bases de datos**.\n"
        "\n"
        "```\n\n"
        "import sqlite3\n\n"
        "from contextlib import contextmanager\n"
        "\n"
        "@contextmanager\n\n"
        "def gestor_bd(nombre_bd):\n\n"
        "    conexion = sqlite3.connect(nombre_bd)\n\n"
        "    try:\n\n"
        "        yield conexion.cursor()  # Devuelve el cursor\n\n"
        "        conexion.commit()  # Guarda cambios al salir del bloque `with`\n\n"
        "    finally:\n\n"
        "        conexion.close()  # Cierra la conexión\n"
        "\n"
        "# Uso del Context Manager\n\n"
        "with gestor_bd('mi_base.db') as cursor:\n\n"
        "    cursor.execute('CREATE TABLE IF NOT EXISTS usuarios (id INTEGER PRIMARY KEY, nombre TEXT)')\n\n"
        "    cursor.execute('INSERT INTO usuarios (nombre) VALUES ('Carlos')')\n"
        "```\n\n"
        "✅ **Ventajas**:\n\n"
        "- La conexión se cierra automáticamente.\n\n"
        "- Se asegura el `commit()` si no hay errores.\n\n"
        "- Se evita código repetitivo.\n"
        "\n"
        "## 📌 7. Decorador @contextmanager con Bloqueo de Hilos (threading.Lock)\n\n"
        "En aplicaciones concurrentes, podemos usar threading.Lock con @contextmanager para **evitar condiciones de carrera**.\n"
        "\n"
        "```\n\n"
        "import threading\n\n"
        "from contextlib import contextmanager\n"
        "\n"
        "bloqueo = threading.Lock()\n"
        "\n"
        "@contextmanager\n\n"
        "def acceso_seguro():\n\n"
        "    bloqueo.acquire()  # Bloquea el acceso\n\n"
        "    try:\n\n"
        "        yield\n\n"
        "    finally:\n\n"
        "        bloqueo.release()  # Libera el acceso\n"
        "\n"
        "# Uso del Context Manager\n\n"
        "with acceso_seguro():\n\n"
        "    print('Ejecutando código de manera segura en hilos')\n"
        "```\n\n"
        "✅ **Evita que múltiples hilos accedan simultáneamente a recursos compartidos.**\n"
        "\n"
        "### 📌 8. Conclusión\n\n"
        "✔️ **Los Context Managers** simplifican la gestión de recursos en Python.  \n\n"
        "✔️ **El uso de `with`** garantiza el cierre seguro de archivos, conexiones y bloqueos.  \n\n"
        "✔️ **Podemos crearlos con clases (`__enter__()` y `__exit__()`) o `@contextmanager`** para un código más limpio.  \n\n"
        "✔️ **Son esenciales para programación concurrente**, bases de datos y conexiones de red.  \n"
        "\n"
        "\n"
        "\n"
        " 🚀 ¿Necesitas algo más? 😊\n"
    ),

    (
        "metaclase",
        "# 📌 1. ¿Qué es una Metaclase en Python?\n\n"
        "Una **metaclase** en Python es una **clase que define cómo se crean otras clases**. Es decir, **las clases en Python son instancias de una metaclase**.  \n"
        "- En Python, **todo es un objeto**, incluidas las clases.\n\n"
        "- Las clases son creadas por **metaclases**, del mismo modo que los objetos son creados por clases.\n\n"
        "✅ **Metaclases permiten modificar la creación de clases, agregar métodos o atributos automáticamente y controlar la herencia.**  \n"
        "\n"
        "### 📌 2. type: La Metaclase por Defecto\n\n"
        "En Python, **`type` es la metaclase predeterminada** que se encarga de la creación de clases.\n"
        "\n"
        "### 🔹 Ejemplo: Creando una clase con type manualmente\n"
        "```\n\n"
        "# Definiendo una clase de forma normal\n\n"
        "class MiClase:\n\n"
        "    atributo = 'Hola'\n"
        "\n"
        "# Definiendo la misma clase con `type`\n\n"
        "MiClaseDinamica = type('MiClaseDinamica', (), {'atributo': 'Hola'})\n"
        "\n"
        "# Creando instancias\n\n"
        "obj1 = MiClase()\n\n"
        "obj2 = MiClaseDinamica()\n"
        "\n"
        "print(obj1.atributo)  # Hola\n\n"
        "print(obj2.atributo)  # Hola\n"
        "```\n\n"
        "✅ **Aquí type recibe**:\n\n"
        "1. **El nombre de la clase** (MiClaseDinamica).\n\n"
        "2. **Las clases padre (herencia)** (en este caso () indica que no hereda de ninguna clase).\n\n"
        "3. **Un diccionario de atributos/métodos**.\n"
        "\n"
        "### 📌 3. Creando una Metaclase Personalizada\n\n"
        "Podemos **crear nuestra propia metaclase** heredando de `type` y redefiniendo `__new__()` o `__init__()` para modificar el comportamiento de la creación de clases.\n"
        "\n"
        "### 🔹 Ejemplo: Metaclase que imprime cuando se crea una clase\n"
        "```\n\n"
        "class Meta(type):\n\n"
        "    def __new__(cls, nombre, bases, diccionario):\n\n"
        "        print(f'Creando la clase: {nombre}')\n\n"
        "        return super().__new__(cls, nombre, bases, diccionario)\n"
        "\n"
        "# Usamos la metaclase en una nueva clase\n\n"
        "class MiClase(metaclass=Meta):\n\n"
        "    pass\n"
        "\n"
        "# Se imprime automáticamente cuando la clase se define\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "Creando la clase: MiClase\n"
        "```\n\n"
        "✅ **`__new__()` se ejecuta antes de crear la clase**, permitiéndonos modificar su comportamiento.\n"
        "\n"
        "### 📌 4. Modificando Atributos con una Metaclase\n\n"
        "Podemos usar una metaclase para **forzar convenciones**, como convertir automáticamente los atributos en mayúsculas.\n"
        "\n"
        "### 🔹 Ejemplo: Metaclase que convierte atributos en mayúsculas\n"
        "```\n\n"
        "class UpperAttrMeta(type):\n\n"
        "    def __new__(cls, nombre, bases, diccionario):\n\n"
        "        nuevo_diccionario = {k.upper(): v for k, v in diccionario.items()}\n\n"
        "        return super().__new__(cls, nombre, bases, nuevo_diccionario)\n"
        "\n"
        "# Aplicamos la metaclase\n\n"
        "class Prueba(metaclass=UpperAttrMeta):\n\n"
        "    nombre = 'python'\n\n"
        "    version = 3.10\n"
        "\n"
        "# Verificamos los atributos\n\n"
        "print(hasattr(Prueba, 'nombre'))   # False\n\n"
        "print(hasattr(Prueba, 'NOMBRE'))   # True\n\n"
        "print(Prueba.NOMBRE)               # python\n\n"
        "print(Prueba.VERSION)              # 3.10\n"
        "```\n\n"
        "✅ **Ahora todos los atributos se transforman a mayúsculas automáticamente.**\n"
        "\n"
        "### 📌 5. Control de Herencia con Metaclases\n\n"
        "Podemos usar metaclases para **restringir la herencia de clases**, asegurando que una clase no sea modificada indebidamente.\n"
        "\n"
        "### 🔹 Ejemplo: Bloquear herencia\n"
        "```\n\n"
        "class NoHerenciaMeta(type):\n\n"
        "    def __new__(cls, nombre, bases, diccionario):\n\n"
        "        if bases:\n\n"
        "            raise TypeError(f'No está permitido heredar de {nombre}')\n\n"
        "        return super().__new__(cls, nombre, bases, diccionario)\n"
        "\n"
        "# Clase base con la metaclase\n\n"
        "class Base(metaclass=NoHerenciaMeta):\n\n"
        "    pass\n"
        "\n"
        "# Intentar heredar genera un error\n\n"
        "class SubClase(Base):  # Esto lanzará una excepción\n\n"
        "    pass\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        "TypeError: No está permitido heredar de Base\n"
        "```\n\n"
        "✅ **Este mecanismo es útil para definir clases que no deben ser extendidas.**\n"
        "\n"
        "### 📌 6. Ejemplo: Registro Automático de Clases con Metaclases\n\n"
        "Podemos usar una metaclase para **registrar automáticamente todas las clases creadas**.\n"
        "\n"
        "```\n\n"
        "class RegistroMeta(type):\n\n"
        "    clases_registradas = {}\n"
        "\n"
        "    def __new__(cls, nombre, bases, diccionario):\n\n"
        "        nueva_clase = super().__new__(cls, nombre, bases, diccionario)\n\n"
        "        cls.clases_registradas[nombre] = nueva_clase\n\n"
        "        return nueva_clase\n"
        "\n"
        "# Aplicamos la metaclase\n\n"
        "class Base(metaclass=RegistroMeta):\n\n"
        "    pass\n"
        "\n"
        "class Clase1(Base):\n\n"
        "    pass\n"
        "\n"
        "class Clase2(Base):\n\n"
        "    pass\n"
        "\n"
        "print(RegistroMeta.clases_registradas)\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n"
        "```\n\n"
        '{"Base": <class "__main__.Base">, "Clase1": <class "__main__.Clase1">, "Clase2": <class "__main__.Clase2">}\n'
        "```\n\n"
        "✅ **Esto permite registrar automáticamente todas las clases que heredan de Base.**\n"
        "\n"
        "### 📌 7. Conclusión\n\n"
        "✔️ **Las metaclases son clases que crean otras clases.**  \n\n"
        "✔️ **`type` es la metaclase predeterminada en Python.**  \n\n"
        "✔️ **Podemos personalizar metaclases redefiniendo `__new__()` y `__init__()`.**  \n\n"
        "✔️ **Se usan en frameworks como Django y SQLAlchemy para definir modelos dinámicos.**  \n\n"
        "✔️ **Son herramientas avanzadas, pero muy útiles cuando se necesitan modificaciones profundas en la estructura de las clases.**  \n"
        "\n"
        "\n"
        "\n"
        " 🚀 ¿Necesitas algo más? 😊\n"
    ),

    (
        "GIL",
        "# 📌 1. ¿Qué es el GIL (Global Interpreter Lock)?\n\n"
        "El **GIL (Global Interpreter Lock)** es un mecanismo de Python que limita la ejecución concurrente de hilos en el intérprete estándar de Python (**CPython**).\n"
        "\n"
        "- **Solo un hilo puede ejecutarse a la vez**, incluso en sistemas con múltiples núcleos.\n\n"
        "- El GIL es un bloqueo global que **evita que múltiples hilos de Python ejecuten código de manera realmente paralela** en CPUs multicore.\n\n"
        "- Aunque los hilos pueden ejecutarse en paralelo a nivel de I/O (operaciones con archivos, red, bases de datos), el código de CPU intensivo **no aprovecha múltiples núcleos**.\n"
        "\n"
        "### 📌 2. ¿Por qué existe el GIL en Python?\n\n"
        "El GIL **simplifica la gestión de memoria** en CPython, evitando problemas de concurrencia como:\n\n"
        "- **Condiciones de carrera** (cuando múltiples hilos acceden a la misma memoria sin sincronización).\n\n"
        "- **Accesos inconsistentes a variables compartidas**.\n\n"
        "- **Problemas con el recolector de basura** de Python.\n"
        "\n"
        "✅ **El GIL hace que Python sea más seguro en ejecución concurrente, pero limita el rendimiento en tareas CPU-intensivas.**\n"
        "\n"
        "### 📌 3. Cómo afecta el GIL al Multithreading\n\n"
        "El GIL **afecta el rendimiento de Python cuando se usan hilos para procesamiento intensivo de CPU**.\n"
        "\n"
        "### 🔹 **Ejemplo: Hilos en Python con el GIL**\n"
        "```\n\n"
        "import threading\n"
        "\n"
        "def tarea():\n\n"
        "    for _ in range(10**7):\n\n"
        "        pass  # Simulamos una tarea pesada\n"
        "\n"
        "# Creamos dos hilos\n\n"
        "hilo1 = threading.Thread(target=tarea)\n\n"
        "hilo2 = threading.Thread(target=tarea)\n"
        "\n"
        "# Medimos el tiempo de ejecución\n\n"
        "import time\n\n"
        "inicio = time.time()\n"
        "\n"
        "hilo1.start()\n\n"
        "hilo2.start()\n\n"
        "hilo1.join()\n\n"
        "hilo2.join()\n"
        "\n"
        "fin = time.time()\n\n"
        "print(f'Tiempo total con hilos: {fin - inicio:.2f} segundos')\n"
        "```\n\n"
        "🔹 **Salida esperada**:\n\n"
        "El tiempo **será casi el mismo que si ejecutamos la tarea en un solo hilo**, porque el GIL **hace que los hilos se ejecuten de manera secuencial en lugar de aprovechar múltiples núcleos.**\n"
        "\n"
        "### 📌 4. Cómo Mitigar el Impacto del GIL\n\n"
        "Aunque el GIL no se puede eliminar en CPython, hay estrategias para minimizar su impacto:\n"
        "\n"
        "## **Opción 1: Usar Multiprocessing en Lugar de Multithreading**\n\n"
        "El módulo `multiprocessing` **crea procesos en lugar de hilos**, evitando el GIL porque cada proceso tiene su propia memoria y espacio de ejecución.\n"
        "\n"
        "### 🔹 **Ejemplo: Uso de `multiprocessing` para aprovechar múltiples núcleos**\n"
        "```\n\n"
        "import multiprocessing\n"
        "\n"
        "def tarea():\n\n"
        "    for _ in range(10**7):\n\n"
        "        pass  # Simulamos una tarea pesada\n"
        "\n"
        "# Creamos dos procesos en lugar de hilos\n\n"
        "proceso1 = multiprocessing.Process(target=tarea)\n\n"
        "proceso2 = multiprocessing.Process(target=tarea)\n"
        "\n"
        "inicio = time.time()\n"
        "\n"
        "proceso1.start()\n\n"
        "proceso2.start()\n\n"
        "proceso1.join()\n\n"
        "proceso2.join()\n"
        "\n"
        "fin = time.time()\n\n"
        "print(f'Tiempo total con multiprocessing: {fin - inicio:.2f} segundos')\n"
        "```\n\n"
        "✅ **Ahora la tarea sí se ejecuta en paralelo en diferentes núcleos**, reduciendo el tiempo total.\n"
        "\n"
        "## **Opción 2: Usar Extensiones en C**\n\n"
        "Otra forma de evitar el GIL es usar **extensiones en C** como **NumPy**, que ejecuta operaciones fuera del control del GIL.\n"
        "\n"
        "### 🔹 **Ejemplo con NumPy**\n"
        "```\n\n"
        "import numpy as np\n"
        "\n"
        "a = np.random.rand(10**6)\n\n"
        "b = np.random.rand(10**6)\n"
        "\n"
        "resultado = a * b  # Se ejecuta en C sin el GIL\n"
        "```\n\n"
        "✅ **NumPy y otras bibliotecas como TensorFlow y Pandas ejecutan código optimizado en C/C++ sin restricciones del GIL.**\n"
        "\n"
        "## **Opción 3: Usar Implementaciones de Python sin GIL**\n\n"
        "Algunas variantes de Python eliminan el GIL:\n\n"
        "- **Jython** (Python sobre la JVM) y **IronPython** (Python sobre .NET) no tienen GIL.\n\n"
        "- **PyPy** tiene un mejor rendimiento de ejecución en algunos casos.\n"
        "\n"
        "### 📌 5. Cuándo el GIL No es un Problema\n\n"
        "El GIL **no afecta tareas de I/O**, como:\n\n"
        "- **Lectura y escritura de archivos**.\n\n"
        "- **Conexiones de red** (servidores web, peticiones HTTP).\n\n"
        "- **Bases de datos**.\n"
        "\n"
        "### 🔹 **Ejemplo: Hilos en tareas de I/O**\n"
        "```\n\n"
        "import threading\n\n"
        "import requests\n"
        "\n"
        "def descargar(url):\n\n"
        "    respuesta = requests.get(url)\n\n"
        "    print(f'Descargado {url} - {len(respuesta.content)} bytes')\n"
        "\n"
        "urls = ['https://www.example.com'] * 5  # Simulamos 5 descargas\n"
        "\n"
        "hilos = [threading.Thread(target=descargar, args=(url,)) for url in urls]\n"
        "\n"
        "for h in hilos:\n\n"
        "    h.start()\n"
        "\n"
        "for h in hilos:\n\n"
        "    h.join()\n"
        "```\n\n"
        "✅ **Aquí los hilos sí mejoran el rendimiento**, porque el GIL se libera durante las operaciones de I/O.\n"
        "\n"
        "### 📌 6. Conclusión\n\n"
        "✔️ **El GIL limita la ejecución concurrente de hilos en CPython, impidiendo el uso eficiente de múltiples núcleos.**  \n\n"
        "✔️ **El multithreading en Python es útil solo para tareas de I/O, pero no para procesamiento intensivo de CPU.**  \n\n"
        "✔️ **Para tareas de CPU, `multiprocessing` es la mejor opción, ya que permite ejecutar código en múltiples núcleos.**  \n\n"
        "✔️ **Bibliotecas como NumPy y TensorFlow evitan el GIL ejecutando código en C/C++.**  \n\n"
        "✔️ **Python no es ideal para procesamiento paralelo puro, pero hay estrategias para mitigar sus limitaciones.**  \n"
        "\n"
        "\n"
        " 🚀 ¿Necesitas algo más? 😊\n"
    ),

    (
        "gestion de memoria",
        "# 📌 1. ¿Cómo maneja Python la memoria?\n\n"
        "Python administra la memoria automáticamente mediante:\n\n"
        "1. **Asignación de memoria dinámica**: Python reserva memoria cuando se crean objetos.\n\n"
        "2. **Recolección de basura (Garbage Collection, GC)**: Python libera memoria automáticamente cuando los objetos ya no se usan.\n\n"
        "3. **Pila (Stack) y Montículo (Heap)**: \n\n"
        "   - **Stack**: Almacena variables locales y llamadas a funciones.\n\n"
        "   - **Heap**: Almacena objetos dinámicos.\n"
        "\n"
        "✅ **Python tiene su propio administrador de memoria, el cual se encarga de asignar y liberar memoria sin intervención manual.**\n"
        "\n"
        "### 📌 2. Pila (Stack) y Montículo (Heap) en Python\n\n"
        "Python organiza la memoria en **dos zonas principales**:\n"
        "\n"
        "- **Stack (Pila)**:  \n\n"
        "  - Almacena variables locales y llamadas a funciones.\n\n"
        "  - Su tamaño es limitado.\n\n"
        "  - Se maneja automáticamente mediante el **modelo de ejecución LIFO (Last In, First Out).**\n"
        "\n"
        "- **Heap (Montículo)**:  \n\n"
        "  - Almacena objetos creados dinámicamente (listas, diccionarios, instancias de clases).\n\n"
        "  - Es gestionado por el **Recolector de Basura**.\n"
        "\n"
        "🔹 **Ejemplo: Variables en Stack y Heap**\n"
        "```\n\n"
        "def funcion():\n\n"
        "    x = 10  # Se almacena en el stack (variable local)\n\n"
        "    y = [1, 2, 3]  # Se almacena en el heap (lista dinámica)\n"
        "\n"
        "funcion()\n"
        "```\n\n"
        "✅ `x` (un entero) se almacena en la pila, mientras que `y` (una lista) se almacena en el montículo.\n"
        "\n"
        "### 📌 3. Referencias y Contadores de Referencia\n\n"
        "Python usa **contadores de referencia** para administrar la memoria.  \n\n"
        "Cada objeto en Python tiene un **contador de referencia** que indica cuántas veces está siendo usado.\n"
        "\n"
        "🔹 **Ejemplo de Contador de Referencia**\n"
        "```\n\n"
        "import sys\n"
        "\n"
        "x = [1, 2, 3]\n\n"
        'print(sys.getrefcount(x))  # 2 (una referencia en "x", otra en la función getrefcount)\n'
        "\n"
        'y = x  # Ahora "y" también referencia la misma lista\n\n'
        "print(sys.getrefcount(x))  # 3\n"
        "```\n\n"
        "✅ Cuando un objeto ya no tiene referencias activas, **Python lo elimina automáticamente**.\n"
        "\n"
        "### 📌 4. Recolector de Basura en Python\n\n"
        "Python usa **Garbage Collection (GC)** para liberar memoria cuando los objetos ya no son usados.\n"
        "\n"
        "### 🔹 **¿Cómo funciona?**\n\n"
        "1. Python elimina objetos cuando su **contador de referencias llega a 0**.\n\n"
        "2. Usa un **algoritmo de detección de ciclos** para evitar pérdidas de memoria.\n\n"
        "3. Se ejecuta automáticamente, pero **puede forzarse manualmente**.\n"
        "\n"
        "### 🔹 **Ejemplo: Recolector de Basura**\n"
        "```\n\n"
        "import gc\n"
        "\n"
        "class MiClase:\n\n"
        "    def __del__(self):  # Método especial que se llama al eliminar un objeto\n\n"
        "        print('Objeto eliminado')\n"
        "\n"
        "obj = MiClase()\n\n"
        "del obj  # Se libera la memoria\n\n"
        "gc.collect()  # Forzamos la recolección de basura\n"
        "```\n\n"
        "✅ **`del obj` elimina la referencia y `gc.collect()` fuerza la limpieza de memoria.**\n"
        "\n"
        "### 📌 5. Problema de Referencias Cíclicas\n\n"
        "Un problema en la gestión de memoria es cuando **dos o más objetos se refieren entre sí**, formando un **ciclo** que impide que su contador de referencias llegue a 0.\n"
        "\n"
        "🔹 **Ejemplo de Ciclo de Referencias**\n"
        "```\n\n"
        "import gc\n"
        "\n"
        "class A:\n\n"
        "    def __init__(self):\n\n"
        "        self.ref = None\n"
        "\n"
        "obj1 = A()\n\n"
        "obj2 = A()\n"
        "\n"
        "obj1.ref = obj2\n\n"
        "obj2.ref = obj1  # Se crea un ciclo de referencias\n"
        "\n"
        "del obj1\n\n"
        "del obj2\n"
        "\n"
        "gc.collect()  # Python detecta el ciclo y libera la memoria\n"
        "```\n\n"
        "✅ **Python detecta automáticamente estos ciclos y los elimina con el recolector de basura.**\n"
        "\n"
        "### 📌 6. Optimización de Memoria en Python\n\n"
        "Python tiene mecanismos para optimizar el uso de memoria:\n"
        "\n"
        "## **🔹 6.1 Interning de Cadenas**\n\n"
        "Python reutiliza cadenas cortas para reducir el uso de memoria.\n"
        "\n"
        "```\n\n"
        "a = 'hola'\n\n"
        "b = 'hola'\n"
        "\n"
        "print(a is b)  # True (mismo objeto en memoria)\n"
        "```\n\n"
        "✅ **Python optimiza el almacenamiento de strings repetidos.**\n"
        "\n"
        "## **🔹 6.2 Slots en Clases**\n\n"
        "Por defecto, los objetos en Python almacenan sus atributos en un **diccionario**, lo que consume memoria.  \n\n"
        "Podemos reducir esto con **`__slots__`**, que restringe los atributos permitidos.\n"
        "\n"
        "🔹 **Ejemplo con `__slots__`**\n"
        "```\n\n"
        "class Persona:\n\n"
        '    __slots__ = ["nombre", "edad"]  # Solo permite estos atributos\n'
        "\n"
        "    def __init__(self, nombre, edad):\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "p = Persona('Carlos', 30)\n\n"
        "# p.direccion = 'México'  # Esto generará un error porque no está en __slots__\n"
        "```\n\n"
        "✅ **`__slots__` reduce el uso de memoria al evitar la creación de un diccionario por objeto.**\n"
        "\n"
        "## **🔹 6.3 Uso de Generadores para Ahorrar Memoria**\n\n"
        "Los **generadores** permiten procesar datos sin cargarlos completamente en memoria.\n"
        "\n"
        "🔹 **Ejemplo: Lista vs Generador**\n"
        "```\n\n"
        "import sys\n"
        "\n"
        "lista = [x for x in range(10**6)]  # Lista ocupa más memoria\n\n"
        "generador = (x for x in range(10**6))  # Generador usa memoria eficiente\n"
        "\n"
        "print(sys.getsizeof(lista))  # Mucho más grande\n\n"
        "print(sys.getsizeof(generador))  # Mucho más pequeño\n"
        "```\n\n"
        "✅ **Los generadores son útiles para procesar grandes volúmenes de datos sin agotar la memoria.**\n"
        "\n"
        "## **🔹 6.4 Uso de `del` para Liberar Memoria**\n\n"
        "Podemos usar `del` para eliminar variables manualmente.\n"
        "\n"
        "🔹 **Ejemplo: Eliminando Variables**\n"
        "```\n\n"
        "x = [1, 2, 3]\n\n"
        "del x  # El objeto se libera de la memoria\n"
        "```\n\n"
        "✅ **`del` ayuda a liberar memoria de grandes estructuras de datos cuando ya no se necesitan.**\n"
        "\n"
        "### 📌 7. Conclusión\n\n"
        "✔️ **Python gestiona la memoria automáticamente con contadores de referencia y recolección de basura.**  \n\n"
        "✔️ **Los objetos se almacenan en el Heap, y las variables locales en el Stack.**  \n\n"
        "✔️ **El Garbage Collector elimina memoria de objetos sin referencias, incluso en ciclos.**  \n\n"
        "✔️ **Para optimizar memoria, se pueden usar `__slots__`, generadores y `del`.**  \n\n"
        "✔️ **Python reutiliza objetos internamente para mejorar el rendimiento.**  \n"
        "\n"
        "\n"
        "\n"
        "🚀 ¿Seguimos con otro tema? 😊\n"
    ),

    (
        "protocolo",
        "# 📌 1. ¿Qué son los Protocolos y los Métodos Mágicos en Python?\n\n"
        "Los **protocolos** en Python son reglas que definen cómo deben comportarse los objetos para interactuar con ciertas estructuras del lenguaje. Se implementan mediante **métodos mágicos** (*dunder methods*), que comienzan y terminan con `__` (doble guion bajo). Python los llama automáticamente en situaciones específicas, como creación de objetos, operaciones matemáticas o comparaciones.\n"
        "\n"
        "✅ **Ejemplo de un método mágico (__init__)**\n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre, edad):  # Se ejecuta al instanciar la clase\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "p = Persona('Carlos', 30)  # Se ejecuta automáticamente __init__\n"
        "```\n\n"
        "Aquí, `__init__` inicializa el objeto al ser creado.\n"
        "\n"
        "### 📌 2. Métodos Mágicos Comunes\n"
        "\n"
        "## **Métodos de Inicialización y Representación**\n\n"
        "Cuando creamos una clase, podemos definir cómo debe representarse al imprimirla o visualizarla en la consola.  \n"
        "\n"
        "- **__init__**: Se ejecuta cuando se crea una instancia de la clase.  \n\n"
        "- **__str__**: Define cómo se muestra el objeto cuando usamos `print(objeto)`.  \n\n"
        "- **__repr__**: Proporciona una representación más técnica del objeto, útil para depuración.  \n"
        "\n"
        "🔹 **Ejemplo**\n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre, edad):\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "    def __str__(self):\n\n"
        "        return f'Persona: {self.nombre}, {self.edad} años'\n"
        "\n"
        "    def __repr__(self):\n\n"
        "        return f'Persona('{self.nombre}', {self.edad})'\n"
        "\n"
        "p = Persona('Carlos', 30)\n\n"
        "print(str(p))  # Se llama a __str__\n\n"
        "print(repr(p))  # Se llama a __repr__\n"
        "```\n\n"
        "✅ `__str__` es más amigable para usuarios, mientras que `__repr__` es útil para depuración.\n"
        "\n"
        "## **Métodos para Operaciones Aritméticas**\n\n"
        "Si queremos que nuestros objetos soporten operaciones matemáticas, podemos definir los métodos mágicos correspondientes.  \n"
        "\n"
        "- __add__ (+)  \n\n"
        "- __sub__ (-)  \n\n"
        "- __mul__ (*)  \n\n"
        "- __truediv__ (/) \n"
        "\n"
        "🔹 **Ejemplo: Sobrecarga del operador +**\n"
        "```\n\n"
        "class Vector:\n\n"
        "    def __init__(self, x, y):\n\n"
        "        self.x = x\n\n"
        "        self.y = y\n"
        "\n"
        "    def __add__(self, otro):\n\n"
        "        return Vector(self.x + otro.x, self.y + otro.y)\n"
        "\n"
        "    def __str__(self):\n\n"
        "        return f'({self.x}, {self.y})'\n"
        "\n"
        "v1 = Vector(3, 4)\n\n"
        "v2 = Vector(1, 2)\n\n"
        "v3 = v1 + v2  # Llama a __add__\n\n"
        "print(v3)  # (4, 6)\n"
        "```\n\n"
        "✅ Ahora podemos sumar objetos `Vector` con `+`.\n"
        "\n"
        "## **Métodos de Comparación**\n\n"
        "Para permitir que los objetos sean comparados, se deben definir los métodos correspondientes:\n"
        "\n"
        "- **__eq__ (==)**  \n\n"
        "- **__ne__ (!=)**  \n\n"
        "- **__lt__ (<)**  \n\n"
        "- **__le__ (<=)**  \n\n"
        "- **__gt__ (>)**  \n\n"
        "- **__ge__ (>=)**  \n"
        "\n"
        "🔹 **Ejemplo: Comparación de Objetos**\n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre, edad):\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "    def __lt__(self, otro):\n\n"
        "        return self.edad < otro.edad\n"
        "\n"
        "p1 = Persona('Carlos', 30)\n\n"
        "p2 = Persona('Ana', 25)\n"
        "\n"
        "print(p1 < p2)  # False (30 no es menor que 25)\n"
        "```\n\n"
        "✅ Esto permite comparar instancias de Persona con <, >, etc.\n"
        "\n"
        "## **Métodos para Acceso a Atributos**\n\n"
        "Podemos personalizar cómo se acceden y manipulan los atributos de un objeto.  \n"
        "\n"
        "- **__getattr__**: Se ejecuta cuando se intenta acceder a un atributo inexistente.  \n\n"
        "- **__setattr__**: Controla la asignación de atributos.  \n"
        "\n"
        "🔹 **Ejemplo: __getattr__ para manejar atributos inexistentes**\n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre):\n\n"
        "        self.nombre = nombre\n"
        "\n"
        "    def __getattr__(self, nombre):\n\n"
        "        return f'{nombre} no existe en Persona'\n"
        "\n"
        "p = Persona('Carlos')\n\n"
        "print(p.edad)  # edad no existe en Persona\n"
        "```\n\n"
        "✅ Evita errores cuando se intenta acceder a atributos no definidos.\n"
        "\n"
        "## **Métodos para Iteradores**\n\n"
        "Para hacer una clase iterable (para usarla en for o list()), debemos definir:  \n"
        "\n"
        "- **__iter__**: Retorna el iterador del objeto.  \n\n"
        "- **__next__**: Define cómo obtener el siguiente elemento de la iteración.  \n"
        "\n"
        "🔹 **Ejemplo: Clase iterable**\n"
        "```\n\n"
        "class Contador:\n\n"
        "    def __init__(self, inicio, fin):\n\n"
        "        self.actual = inicio\n\n"
        "        self.fin = fin\n"
        "\n"
        "    def __iter__(self):\n\n"
        "        return self\n"
        "\n"
        "    def __next__(self):\n\n"
        "        if self.actual >= self.fin:\n\n"
        "            raise StopIteration\n\n"
        "        self.actual += 1\n\n"
        "        return self.actual - 1\n"
        "\n"
        "for num in Contador(1, 5):\n\n"
        "    print(num)\n"
        "```\n\n"
        "✅ Ahora `Contador` se puede recorrer con un `for`.\n"
        "\n"
        "## **Métodos para Manejo de Contexto (`with`)**\n\n"
        "Si queremos que un objeto pueda ser usado dentro de un bloque `with`, debemos definir:  \n"
        "\n"
        "- **__enter__**: Se ejecuta al entrar en el bloque `with`.  \n\n"
        "- **__exit__**: Se ejecuta al salir del bloque `with`.  \n"
        "\n"
        "🔹 **Ejemplo: Uso de with para manejar archivos**\n"
        "```\n\n"
        "class Archivo:\n\n"
        "    def __init__(self, nombre):\n\n"
        "        self.nombre = nombre\n"
        "\n"
        "    def __enter__(self):\n\n"
        '        self.archivo = open(self.nombre, "w")\n\n'
        "        return self.archivo\n"
        "\n"
        "    def __exit__(self, exc_type, exc_value, traceback):\n\n"
        "        self.archivo.close()\n"
        "\n"
        "with Archivo('test.txt') as f:\n\n"
        "    f.write('Hola, mundo!')\n"
        "```\n\n"
        "✅ Esto asegura que el archivo se cierre correctamente sin importar si ocurre un error.\n"
        "\n"
        "### 📌 3. Conclusión\n\n"
        "✔️ **Los Métodos Mágicos permiten personalizar el comportamiento de los objetos en Python.**  \n\n"
        "✔️ **Hacen que los objetos sean más expresivos y puedan interactuar con operadores (+, ==), estructuras (for, with) y funciones nativas (print()).**  \n\n"
        "✔️ **Son clave para escribir código más limpio, reutilizable y eficiente.**  \n"
        "\n"
        "\n"
        "\n"
        "\n"
        "🚀 ¿Seguimos con otro tema? 😊\n"
    ),

    (
        "pytest",
        "# 📌 Pytest en Python \n"
        "\n"
        "Pytest es un **framework de pruebas para Python** que facilita la escritura y ejecución de pruebas unitarias y funcionales. Se usa para **verificar que el código funcione correctamente** y ayuda a detectar errores antes de que afecten a los usuarios o a un entorno de producción.  \n"
        "\n"
        "✅ **Ventajas de usar pytest**:  \n\n"
        "- Sintaxis sencilla y clara.  \n\n"
        "- No requiere escribir clases de prueba (a diferencia de unittest).  \n\n"
        "- Permite ejecutar múltiples pruebas con un solo comando.  \n\n"
        "- Admite **fixtures** para configurar datos antes de cada prueba.  \n\n"
        "- Genera informes detallados de los resultados.  \n"
        "\n"
        "## **📌 Instalación de pytest**  \n\n"
        "Para empezar, necesitas instalar `pytest` en tu entorno de Python. Puedes hacerlo con:  \n"
        "```\n\n"
        "pip install pytest\n"
        "```\n"
        "\n"
        "Para ejecutar las pruebas, simplemente usa:  \n"
        "```\n\n"
        "pytest nombre_del_archivo.py\n"
        "```\n\n"
        "o para ejecutar todas las pruebas en un proyecto:  \n"
        "```\n\n"
        "pytest\n"
        "```\n"
        "\n"
        "## 📌 1. Primera prueba con pytest\n\n"
        "El siguiente ejemplo muestra una **prueba básica** para una función que suma dos números.\n"
        "\n"
        "🔹 **Código principal (`calculadora.py`)**\n"
        "```\n\n"
        "def sumar(a, b):\n\n"
        "    return a + b\n"
        "```\n"
        "\n"
        "🔹 **Prueba con pytest (test_calculadora.py)**\n"
        "```\n\n"
        "from calculadora import sumar\n"
        "\n"
        "def test_sumar():\n\n"
        "    resultado = sumar(2, 3)\n\n"
        "    assert resultado == 5  # Verifica que el resultado es el esperado\n"
        "```\n\n"
        "✅ Ejecutamos la prueba con:  \n"
        "```\n\n"
        "pytest\n"
        "```\n\n"
        "Si el resultado es correcto, veremos un mensaje como:  \n"
        "```\n\n"
        "1 passed in 0.01s\n"
        "```\n\n"
        "Si la prueba falla, `pytest` mostrará una comparación entre el valor esperado y el obtenido.\n"
        "\n"
        "## 📌 2. Uso de pytest.mark.parametrize para probar múltiples casos  \n\n"
        "Podemos probar **varios casos de una función sin escribir varias pruebas** usando `@pytest.mark.parametrize`.\n"
        "\n"
        "🔹 **Ejemplo**\n"
        "```\n\n"
        "import pytest\n\n"
        "from calculadora import sumar\n"
        "\n"
        "@pytest.mark.parametrize('a, b, resultado_esperado', [\n\n"
        "    (2, 3, 5),\n\n"
        "    (-1, 1, 0),\n\n"
        "    (0, 0, 0),\n\n"
        "    (100, 200, 300)\n\n"
        "])\n\n"
        "def test_sumar_parametrizado(a, b, resultado_esperado):\n\n"
        "    assert sumar(a, b) == resultado_esperado\n"
        "```\n\n"
        "✅ `pytest` ejecutará la prueba para cada conjunto de valores automáticamente.\n"
        "\n"
        "## 📌 3. Pruebas de funciones que pueden generar errores\n\n"
        "Podemos usar `pytest.raises` para verificar si una función **genera una excepción esperada**.\n"
        "\n"
        "🔹 **Ejemplo: División por cero**\n"
        "```\n\n"
        "def dividir(a, b):\n\n"
        "    if b == 0:\n\n"
        "        raise ValueError('No se puede dividir por cero')\n\n"
        "    return a / b\n"
        "```\n"
        "\n"
        "🔹 **Prueba con `pytest.raises`**\n"
        "```\n\n"
        "import pytest\n\n"
        "from calculadora import dividir\n"
        "\n"
        "def test_dividir_por_cero():\n\n"
        "    with pytest.raises(ValueError, match='No se puede dividir por cero'):\n\n"
        "        dividir(10, 0)\n"
        "```\n\n"
        "✅ Si la función lanza la excepción esperada, la prueba pasará.\n"
        "\n"
        "## 📌 4. Uso de pytest.fixture para configurar datos antes de cada prueba\n\n"
        "Los **fixtures** permiten configurar datos antes de ejecutar las pruebas, lo que evita repetición de código.\n"
        "\n"
        "🔹 **Ejemplo con una clase Usuario**\n"
        "```\n\n"
        "class Usuario:\n\n"
        "    def __init__(self, nombre, edad):\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "    def es_mayor_de_edad(self):\n\n"
        "        return self.edad >= 18\n"
        "```\n"
        "\n"
        "🔹 **Prueba con fixture**\n"
        "```\n\n"
        "import pytest\n\n"
        "from usuario import Usuario\n"
        "\n"
        "@pytest.fixture\n\n"
        "def usuario_ejemplo():\n\n"
        "    return Usuario('Carlos', 25)\n"
        "\n"
        "def test_usuario_mayor_de_edad(usuario_ejemplo):\n\n"
        "    assert usuario_ejemplo.es_mayor_de_edad() == True\n"
        "```\n\n"
        "✅ pytest.fixture crea un objeto reutilizable (usuario_ejemplo) que se pasa como argumento a las pruebas.\n"
        "\n"
        "## 📌 5. Ejecución avanzada de pruebas\n\n"
        "Para mejorar el uso de `pytest`, podemos ejecutar pruebas de distintas formas:\n"
        "\n"
        "✅ **Ejecutar pruebas con salida detallada**  \n"
        "```\n\n"
        "pytest -v\n"
        "```\n"
        "\n"
        "✅ **Ejecutar solo pruebas de un archivo específico**  \n"
        "```\n\n"
        "pytest test_calculadora.py\n"
        "```\n"
        "\n"
        "✅ **Ejecutar solo una función de prueba específica**  \n"
        "```\n\n"
        "pytest test_calculadora.py::test_sumar\n"
        "```\n"
        "\n"
        "✅ **Ejecutar solo las pruebas que fallaron en la ejecución anterior**  \n"
        "```\n\n"
        "pytest --lf\n"
        "```\n"
        "\n"
        "✅ **Ejecutar pruebas con información de cobertura de código**  \n"
        "```\n\n"
        "pip install pytest-cov\n\n"
        "pytest --cov=nombre_del_paquete\n"
        "```\n\n"
        "Esto muestra qué porcentaje del código ha sido ejecutado en las pruebas.\n"
        "\n"
        "## **📌 6. Conclusión**\n\n"
        "✔️ `pytest` es un **framework potente y fácil de usar** para pruebas en Python.  \n\n"
        "✔️ Permite escribir **pruebas simples y reutilizables**.  \n\n"
        "✔️ Soporta **parametrización**, **manejo de excepciones**, **fixtures**, y más.  \n\n"
        "✔️ Ayuda a **detectar errores antes de que lleguen a producción**.  \n"
    ),

    (
        "unittest",
        "# 📌 unittest en Python: Uso y Ejemplos Prácticos  \n"
        "\n"
        "unittest es el **módulo estándar de pruebas en Python**. A diferencia de pytest, unittest usa una estructura basada en clases y métodos específicos para definir pruebas. Es útil para crear **pruebas unitarias y de integración** de manera organizada.  \n"
        "\n"
        "## 📌 1. Instalación y Estructura Básica  \n\n"
        "`unittest` viene incluido en Python, por lo que no es necesario instalarlo.  \n"
        "\n"
        "✅ **Estructura básica de una prueba con `unittest`**  \n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "def sumar(a, b):\n\n"
        "    return a + b\n"
        "\n"
        "class TestCalculadora(unittest.TestCase):\n\n"
        "    def test_sumar(self):\n\n"
        "        self.assertEqual(sumar(2, 3), 5)  # Comprueba si 2 + 3 es igual a 5\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    unittest.main()\n"
        "```\n\n"
        "✅ Para ejecutar la prueba, guarda el archivo y ejecuta en la terminal:  \n"
        "```\n\n"
        "python test_calculadora.py\n"
        "```\n\n"
        "Si la prueba pasa, se verá algo como:  \n"
        "```\n\n"
        ".\n\n"
        "----------------------------------------------------------------------\n\n"
        "Ran 1 test in 0.001s\n"
        "\n"
        "OK\n"
        "```\n\n"
        "Si falla, mostrará el error esperado y el valor obtenido.\n"
        "\n"
        "## 📌 2. Métodos de unittest.TestCase\n\n"
        "Dentro de una clase de prueba, podemos usar **métodos de aserción** que verifican si una condición se cumple.  \n"
        "\n"
        "🔹 **Ejemplo con aserciones comunes**\n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "class TestAserciones(unittest.TestCase):\n\n"
        "    def test_aserciones(self):\n\n"
        "        self.assertEqual(10, 10)   # Verifica igualdad\n\n"
        "        self.assertNotEqual(10, 5) # Verifica desigualdad\n\n"
        "        self.assertTrue(True)      # Verifica si es True\n\n"
        "        self.assertFalse(False)    # Verifica si es False\n\n"
        "        self.assertIsNone(None)    # Verifica si es None\n\n"
        "        self.assertIn(3, [1, 2, 3]) # Verifica si 3 está en la lista\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    unittest.main()\n"
        "```\n\n"
        "✅ Si alguna afirmación no se cumple, la prueba fallará mostrando un mensaje de error detallado.\n"
        "\n"
        "## 📌 3. Pruebas con setUp y tearDown\n\n"
        "A veces es necesario **preparar datos antes de ejecutar cada prueba** y limpiarlos después. Para esto, usamos `setUp()` y `tearDown()`.\n"
        "\n"
        "🔹 **Ejemplo con setUp y tearDown**\n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "class TestEjemplo(unittest.TestCase):\n\n"
        "    def setUp(self):\n\n"
        "        print('\n\n"
        "Preparando prueba...')\n"
        "\n"
        "    def tearDown(self):\n\n"
        "        print('Finalizando prueba...')\n"
        "\n"
        "    def test_ejemplo(self):\n\n"
        "        self.assertEqual(2 + 2, 4)\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    unittest.main()\n"
        "```\n\n"
        "✅ setUp() se ejecuta antes de cada prueba y tearDown() después. Esto es útil para inicializar bases de datos o archivos temporales.\n"
        "\n"
        "## 📌 4. Pruebas de Excepciones con assertRaises\n\n"
        "Si una función debe lanzar una **excepción específica**, podemos verificarlo con assertRaises().\n"
        "\n"
        "🔹 **Ejemplo: Verificar ZeroDivisionError**\n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "def dividir(a, b):\n\n"
        "    if b == 0:\n\n"
        "        raise ValueError('No se puede dividir por cero')\n\n"
        "    return a / b\n"
        "\n"
        "class TestDivision(unittest.TestCase):\n\n"
        "    def test_division_por_cero(self):\n\n"
        "        with self.assertRaises(ValueError):\n\n"
        "            dividir(10, 0)\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    unittest.main()\n"
        "```\n\n"
        "✅ Si la excepción `ValueError` no ocurre, la prueba fallará.\n"
        "\n"
        "## 📌 5. Ejecutar Múltiples Casos con subTest\n\n"
        "Cuando queremos probar varios valores sin detener la ejecución en el primer error, podemos usar `subTest()`.\n"
        "\n"
        "🔹 **Ejemplo: Pruebas con diferentes valores**\n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "def cuadrado(x):\n\n"
        "    return x * x\n"
        "\n"
        "class TestCuadrado(unittest.TestCase):\n\n"
        "    def test_varios_valores(self):\n\n"
        "        valores = [(2, 4), (3, 9), (-1, 1), (0, 0)]\n\n"
        "        for entrada, esperado in valores:\n\n"
        "            with self.subTest(entrada=entrada, esperado=esperado):\n\n"
        "                self.assertEqual(cuadrado(entrada), esperado)\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    unittest.main()\n"
        "```\n\n"
        "✅ Esto ejecuta cada caso sin detenerse en el primero que falle.\n"
        "\n"
        "## 📌 6. Organización de Pruebas con unittest.TestSuite\n\n"
        "Si tenemos muchas pruebas, podemos organizarlas en un **TestSuite** y ejecutarlas juntas.\n"
        "\n"
        "🔹 **Ejemplo de TestSuite**\n"
        "```\n\n"
        "import unittest\n"
        "\n"
        "class TestUno(unittest.TestCase):\n\n"
        "    def test_prueba1(self):\n\n"
        "        self.assertEqual(1 + 1, 2)\n"
        "\n"
        "class TestDos(unittest.TestCase):\n\n"
        "    def test_prueba2(self):\n\n"
        "        self.assertTrue(5 > 3)\n"
        "\n"
        "if __name__ == '__main__':\n\n"
        "    suite = unittest.TestSuite()\n\n"
        "    suite.addTest(TestUno('test_prueba1'))\n\n"
        "    suite.addTest(TestDos('test_prueba2'))\n"
        "\n"
        "    runner = unittest.TextTestRunner()\n\n"
        "    runner.run(suite)\n"
        "```\n\n"
        "✅ TestSuite permite agrupar varias clases de prueba y ejecutarlas juntas.\n"
        "\n"
        "## 📌 7. Ejecutar Solo Pruebas Específicas\n\n"
        "Si un archivo contiene muchas pruebas, podemos ejecutar solo una específica:\n"
        "\n"
        "✅ **Ejecutar un solo test**  \n"
        "```\n\n"
        "python -m unittest test_calculadora.TestCalculadora.test_sumar\n"
        "```\n"
        "\n"
        "✅ **Ejecutar todas las pruebas de un archivo**  \n"
        "```\n\n"
        "python -m unittest test_calculadora\n"
        "```\n"
        "\n"
        "✅ **Ejecutar todas las pruebas del directorio actual**  \n"
        "```\n\n"
        "python -m unittest discover\n"
        "```\n"
        "\n"
        "✅ **Ejecutar pruebas con más detalles**  \n"
        "```\n\n"
        "python -m unittest -v\n"
        "```\n"
        "\n"
        "### 📌 8. Conclusión\n\n"
        "✔️ `unittest` es una **herramienta robusta** para escribir pruebas en Python.  \n\n"
        "✔️ Usa una estructura basada en **clases y métodos** (`unittest.TestCase`).  \n\n"
        "✔️ Permite probar **excepciones, múltiples valores y ejecutar pruebas en conjunto**.  \n\n"
        "✔️ Es ideal para **proyectos grandes o código que requiere pruebas detalladas**.  \n"
        "\n"
        "🚀 **Ahora puedes usar `unittest` para garantizar que tu código funcione correctamente antes de desplegarlo.**  \n"
    
    ),

    (
        "debugging",
        "# 📌 Debugging en Python: Uso de pdb, ipdb y herramientas de IDE \n"
        "\n"
        "El **debugging (depuración)** es el proceso de encontrar y corregir errores en el código. En Python, hay varias herramientas para hacer esto, como pdb, ipdb y los depuradores integrados en **VSCode y PyCharm**.  \n"
        "\n"
        "### 📌 1. Uso de pdb (Python Debugger)  \n\n"
        "pdb es el depurador estándar de Python. Permite **pausar la ejecución**, **inspeccionar variables** y **avanzar paso a paso** por el código.  \n"
        "\n"
        "✅ **Ejemplo básico con pdb**  \n"
        "```\n\n"
        "import pdb\n"
        "\n"
        "def dividir(a, b):\n\n"
        "    pdb.set_trace()  # Pausa aquí\n\n"
        "    return a / b\n"
        "\n"
        "resultado = dividir(10, 2)\n\n"
        "print(resultado)\n"
        "```\n\n"
        "🔹 Al ejecutar el código, pdb abrirá una consola interactiva. Podemos usar los siguientes comandos:  \n"
        "\n"
        "- n (**next**) → Ejecuta la siguiente línea.  \n\n"
        "- s (**step**) → Entra en una función llamada en la línea actual.  \n\n"
        "- c (**continue**) → Continúa la ejecución hasta el final o el próximo `set_trace()`.  \n\n"
        "- q (**quit**) → Sale del depurador.  \n\n"
        "- p variable (**print**) → Muestra el valor de una variable.  \n\n"
        "- h (**help**) → Muestra ayuda sobre comandos disponibles.  \n"
        "\n"
        "✅ **Depuración sin set_trace()**  \n\n"
        "También podemos ejecutar un script en modo depuración desde la terminal:  \n"
        "```\n\n"
        "python -m pdb mi_script.py\n"
        "```\n"
        "\n"
        "### 📌 2. Uso de ipdb (Mejorado sobre pdb)  \n\n"
        "`ipdb` es una versión mejorada de `pdb` con autocompletado y mejor visualización de datos.  \n"
        "\n"
        "✅ **Instalación**  \n"
        "```\n\n"
        "pip install ipdb\n"
        "```\n\n"
        "✅ **Uso en código**  \n"
        "```\n\n"
        "import ipdb\n"
        "\n"
        "def multiplicar(a, b):\n\n"
        "    ipdb.set_trace()  # Pausa aquí\n\n"
        "    return a * b\n"
        "\n"
        "resultado = multiplicar(4, 5)\n\n"
        "print(resultado)\n"
        "```\n\n"
        "🔹 Los comandos son los mismos que pdb, pero con mejor experiencia de usuario.\n"
        "\n"
        "✅ **Depuración sin `set_trace()`**  \n\n"
        "Podemos ejecutar un script con `ipdb` desde la terminal:  \n"
        "```\n\n"
        "python -m ipdb mi_script.py\n"
        "```\n"
        "\n"
        "### 📌 3. Debugging con VSCode\n\n"
        "VSCode tiene un depurador integrado que facilita la identificación de errores de manera visual.  \n"
        "\n"
        "✅ **Pasos para usar el depurador en VSCode:**  \n\n"
        "1. **Abrir VSCode** y el archivo Python que queremos depurar.  \n\n"
        "2. **Agregar un punto de interrupción**: Haz clic en el margen izquierdo de la línea donde quieres detener la ejecución.  \n\n"
        "3. **Iniciar el depurador**:  \n\n"
        "   - Ir a **Ejecutar y depurar** (`Ctrl + Shift + D` en Windows/Linux, `Cmd + Shift + D` en macOS).  \n\n"
        "   - Seleccionar **Python: Archivo actual**.  \n\n"
        "4. **Usar los controles**:  \n\n"
        "   - ▶️ **Continuar** → Sigue hasta el próximo breakpoint.  \n\n"
        "   - ⏭️ **Paso a paso** → Ejecuta línea por línea.  \n\n"
        "   - 🛑 **Detener** → Finaliza la depuración.  \n\n"
        "   - 📌 **Ver variables** en la sección de variables locales.  \n"
        "\n"
        "✅ **Depuración con breakpoint()**  \n\n"
        "Desde Python 3.7, se puede usar breakpoint() en lugar de pdb.set_trace(), y VSCode lo reconoce automáticamente.  \n"
        "```\n\n"
        "def sumar(a, b):\n\n"
        "    breakpoint()  # Pausa aquí\n\n"
        "    return a + b\n"
        "\n"
        "resultado = sumar(10, 20)\n\n"
        "print(resultado)\n"
        "```\n"
        "\n"
        "### 📌 4. Debugging con PyCharm  \n\n"
        "PyCharm tiene un depurador muy potente y fácil de usar.  \n"
        "\n"
        "✅ **Pasos para depurar en PyCharm:**  \n\n"
        "1. **Abrir PyCharm** y el script que queremos depurar.  \n\n"
        "2. **Agregar un breakpoint**: Haz clic en el margen izquierdo de la línea donde quieres pausar la ejecución.  \n\n"
        "3. **Iniciar el depurador**:  \n\n"
        "   - Hacer clic en el botón 🐞 **Debug** (o Shift + F9).  \n\n"
        "4. **Usar las herramientas de depuración**:  \n\n"
        "   - **Step Over (F8)** → Ejecuta la siguiente línea sin entrar en funciones.  \n\n"
        "   - **Step Into (F7)** → Entra dentro de una función llamada en la línea actual.  \n\n"
        "   - **Resume (F9)** → Continúa hasta el siguiente breakpoint.  \n\n"
        "   - **Inspect Variables** → Inspecciona variables en tiempo real.  \n"
        "\n"
        "✅ **Depuración con breakpoint() en PyCharm**  \n\n"
        "PyCharm también reconoce breakpoint() sin necesidad de pdb.  \n"
        "\n"
        "### 📌 5. Conclusión  \n\n"
        "✔️ pdb y ipdb permiten depurar desde la terminal, pero **VSCode y PyCharm** ofrecen herramientas más visuales.  \n\n"
        "✔️ breakpoint() es una alternativa moderna y funciona en todos los entornos.  \n\n"
        "✔️ **Aprender a depurar bien ahorra horas de trabajo** y ayuda a entender mejor el código.  \n"
        "\n"
        "🚀 **Con estas herramientas, puedes encontrar y corregir errores más rápido y eficientemente.**  \n"
        "\n"
        "¿Quieres que profundice en alguna herramienta en particular o seguimos con otro tema? 😊\n"
    ),

    (
        "logging",
        "# 📌 Logging en Python: Registro de eventos y mensajes  \n"
        "\n"
        "El módulo logging de Python permite **registrar mensajes de depuración, advertencias y errores** en archivos o en la consola. Es una alternativa a print(), pero mucho más potente y flexible.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar logging en lugar de print()?\n\n"
        "✔️ Permite guardar logs en archivos para futuras revisiones.  \n\n"
        "✔️ Se pueden definir **diferentes niveles de mensajes** (info, warning, error, etc.).  \n\n"
        "✔️ Funciona en **aplicaciones grandes** sin saturar la salida con `print()`.  \n\n"
        "✔️ Se puede configurar para **diferentes formatos y destinos** (consola, archivos, servidores remotos, etc.).  \n"
        "\n"
        "### 📌 2. Configuración Básica de logging  \n\n"
        "Para empezar, podemos configurar `logging` con un formato simple.  \n"
        "\n"
        "✅ **Ejemplo básico:**  \n"
        "```\n\n"
        "import logging\n"
        "\n"
        "logging.basicConfig(level=logging.INFO)\n"
        "\n"
        "logging.debug('Esto es un mensaje de depuración')\n\n"
        "logging.info('Esto es un mensaje informativo')\n\n"
        "logging.warning('¡Esto es una advertencia!')\n\n"
        "logging.error('¡Esto es un error!')\n\n"
        "logging.critical('¡Esto es un error crítico!')\n"
        "```\n\n"
        "🔹 La salida mostrará solo los mensajes a partir de `INFO`, porque `DEBUG` está por debajo del nivel configurado.  \n"
        "\n"
        "🔹 **Salida esperada:**  \n"
        "```\n\n"
        "WARNING:root:¡Esto es una advertencia!\n\n"
        "ERROR:root:¡Esto es un error!\n\n"
        "CRITICAL:root:¡Esto es un error crítico!\n"
        "```\n"
        "\n"
        "✅ **Para mostrar mensajes DEBUG, cambia el nivel:**  \n"
        "```\n\n"
        "logging.basicConfig(level=logging.DEBUG)\n"
        "```\n"
        "\n"
        "## **📌 3. Niveles de Logging**  \n\n"
        "Python define **cinco niveles de severidad** en los mensajes:  \n"
        "\n"
        "| Nivel       | Descripción |\n\n"
        "|------------|------------|\n\n"
        "| DEBUG    | Información detallada para depuración. |\n\n"
        "| INFO     | Información general del programa. |\n\n"
        "| WARNING  | Algo inusual, pero no crítico. |\n\n"
        "| ERROR    | Un error que afecta una parte del programa. |\n\n"
        "| CRITICAL | Un fallo grave que podría detener la aplicación. |\n"
        "\n"
        "✅ **Ejemplo: Filtrar logs según el nivel**  \n"
        "```\n\n"
        "logging.basicConfig(level=logging.WARNING)\n"
        "\n"
        "logging.debug('Este mensaje no se verá.')\n\n"
        "logging.info('Este tampoco.')\n\n"
        "logging.warning('Este sí se mostrará.')\n\n"
        "logging.error('Este también.')\n\n"
        "logging.critical('Este también.')\n"
        "```\n\n"
        "🔹 Solo se muestran WARNING, ERROR y CRITICAL porque el nivel mínimo configurado es WARNING.\n"
        "\n"
        "### 📌 4. Guardar Logs en un Archivo  \n\n"
        "Podemos almacenar los logs en un archivo en lugar de mostrarlos en la consola.  \n"
        "\n"
        "✅ **Ejemplo de log en un archivo:**  \n"
        "```\n\n"
        "logging.basicConfig(filename='app.log', level=logging.DEBUG, \n\n"
        "                    format='%(asctime)s - %(levelname)s - %(message)s')\n"
        "\n"
        "logging.info('Este mensaje se guardará en app.log')\n\n"
        "logging.error('¡Error detectado!')\n"
        "```\n\n"
        "🔹 **Ejemplo del contenido del archivo `app.log`**:  \n"
        "```\n\n"
        "2025-03-20 10:45:12,345 - INFO - Este mensaje se guardará en app.log\n\n"
        "2025-03-20 10:45:12,346 - ERROR - ¡Error detectado!\n"
        "```\n"
        "\n"
        "### 📌 5. Formatear Mensajes de Log  \n\n"
        "Podemos personalizar el formato de los logs para incluir **fecha, nivel, módulo y mensaje**.  \n"
        "\n"
        "✅ **Ejemplo con formato personalizado:**  \n"
        "```\n\n"
        "logging.basicConfig(level=logging.DEBUG, format='%(levelname)s | %(asctime)s | %(message)s',\n\n"
        "                    datefmt='%Y-%m-%d %H:%M:%S')\n"
        "\n"
        "logging.info('Mensaje informativo con formato.')\n\n"
        "logging.error('Error con formato personalizado.')\n"
        "```\n\n"
        "🔹 **Salida en consola:**  \n"
        "```\n\n"
        "INFO | 2025-03-20 10:50:30 | Mensaje informativo con formato.\n\n"
        "ERROR | 2025-03-20 10:50:30 | Error con formato personalizado.\n"
        "```\n"
        "\n"
        "### 📌 6. Uso de Logger para Configuraciones Avanzadas\n\n"
        "logging permite crear múltiples **logger personalizados** en una misma aplicación.  \n"
        "\n"
        "✅ **Ejemplo con Logger y FileHandler para múltiples logs**  \n"
        "```\n\n"
        "import logging\n"
        "\n"
        "# Crear un logger\n\n"
        "logger = logging.getLogger('mi_logger')\n\n"
        "logger.setLevel(logging.DEBUG)\n"
        "\n"
        "# Crear un manejador de archivo\n\n"
        "file_handler = logging.FileHandler('mi_log.log')\n\n"
        "file_handler.setLevel(logging.DEBUG)\n"
        "\n"
        "# Definir formato del log\n\n"
        "formatter = logging.Formatter('%(levelname)s | %(asctime)s | %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n\n"
        "file_handler.setFormatter(formatter)\n"
        "\n"
        "# Agregar el manejador al logger\n\n"
        "logger.addHandler(file_handler)\n"
        "\n"
        "# Registrar mensajes\n\n"
        "logger.debug('Esto es un mensaje DEBUG en el archivo.')\n\n"
        "logger.info('Mensaje INFO en el archivo.')\n\n"
        "logger.warning('Advertencia guardada en el archivo.')\n\n"
        "logger.error('Error registrado en el archivo.')\n\n"
        "logger.critical('Mensaje CRÍTICO en el archivo.')\n"
        "```\n\n"
        "🔹 Ahora, los logs se guardarán en **`mi_log.log`** con el formato definido.  \n"
        "\n"
        "### 📌 7. Capturar Errores con logging.exception()\n\n"
        "Cuando ocurre una excepción, podemos registrar **el mensaje de error y el traceback** automáticamente.  \n"
        "\n"
        "✅ **Ejemplo capturando errores con exception()**  \n"
        "```\n\n"
        "try:\n\n"
        "    1 / 0  # Error de división por cero\n\n"
        "except ZeroDivisionError:\n\n"
        "    logging.exception('¡Se intentó dividir por cero!')\n"
        "```\n\n"
        "🔹 **Salida en consola:**  \n"
        "```\n\n"
        "ERROR:root:¡Se intentó dividir por cero!\n\n"
        "Traceback (most recent call last):\n\n"
        "  File 'script.py', line 2, in <module>\n\n"
        "    1 / 0\n\n"
        "ZeroDivisionError: division by zero\n"
        "```\n\n"
        "🔹 `logging.exception()` captura automáticamente la traza del error.\n"
        "\n"
        "### 📌 8. Desactivar Logging en Librerías Externas  \n\n"
        "Algunas librerías generan demasiados logs, podemos desactivarlos así:  \n"
        "\n"
        "```\n\n"
        "import logging\n"
        "\n"
        "logging.getLogger('urllib3').setLevel(logging.WARNING)\n"
        "```\n\n"
        "🔹 Esto **oculta los logs de urllib3** si son de nivel menor a WARNING.\n"
        "\n"
        "### 📌 9. Conclusión\n\n"
        "✔️ logging permite **controlar y almacenar registros de eventos** en nuestros programas.  \n\n"
        "✔️ Se pueden **filtrar mensajes** por nivel (`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`).  \n\n"
        "✔️ Permite **guardar logs en archivos** y personalizar su formato.  \n\n"
        "✔️ exception() ayuda a **registrar errores automáticamente** con su traza completa.  \n\n"
        "✔️ Se pueden **desactivar logs innecesarios** de librerías externas.  \n"
        "\n"
        "🚀 **Con logging, podemos monitorear el estado de nuestras aplicaciones y encontrar errores más rápido.**  \n"
        "\n"
        "¿Quieres que exploremos alguna funcionalidad más en detalle o seguimos con otro tema? 😊\n"
    ),

    (
        "flake8",
        "# 📌 Flake8: Análisis de Estilo y Calidad de Código en Python  \n"
        "\n"
        "flake8 es una herramienta que analiza código Python para verificar su **estilo, calidad y detección de errores potenciales**. Combina varias herramientas en una sola, lo que la hace muy útil para mantener un código limpio y profesional.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar flake8?  \n"
        "✔️ Asegura que el código siga el estándar **PEP 8**.  \n"
        "✔️ Detecta **errores de sintaxis** y posibles fallos en el código.  \n"
        "✔️ Identifica **código redundante o innecesario**.  \n"
        "✔️ Facilita la colaboración en equipos con un estilo de código uniforme.  \n"
        "\n"
        "### 📌 2. Instalación de flake8  \n\n"
        "Se puede instalar fácilmente con pip:  \n"
        "```\n\n"
        "pip install flake8\n"
        "```\n\n"
        "Para verificar si la instalación fue exitosa:  \n"
        "```\n\n"
        "flake8 --version\n"
        "```\n"
        "\n"
        "### 📌 3. Uso Básico de flake8  \n\n"
        "Para analizar un archivo Python:  \n"
        "```\n\n"
        "flake8 mi_script.py\n"
        "```\n\n"
        "🔹 Esto generará una lista de advertencias y errores en el código.  \n"
        "\n"
        "Ejemplo de salida:  \n"
        "```\n\n"
        "mi_script.py:3:1: E302 expected 2 blank lines, found 1\n\n"
        'mi_script.py:5:10: E231 missing whitespace after ","\n'
        "```\n\n"
        "Cada error tiene un código identificador (`E302`, `E231`), que indica el tipo de problema encontrado.\n"
        "\n"
        "### 📌 4. Configurar flake8  \n\n"
        "Podemos personalizar flake8 creando un archivo de configuración .flake8 o setup.cfg en el directorio del proyecto.  \n"
        "\n"
        "Ejemplo de archivo .flake8:  \n"
        "```\n\n"
        "[flake8]\n\n"
        "max-line-length = 100\n\n"
        "ignore = E203, E266, W503\n"
        "```\n\n"
        "🔹 `max-line-length = 100` permite líneas más largas de lo normal (por defecto, 79 caracteres).  \n\n"
        "🔹 `ignore = E203, E266, W503` desactiva ciertas reglas específicas.  \n"
        "\n"
        "Para ignorar archivos o carpetas específicas, podemos añadir:  \n"
        "```\n\n"
        "exclude = migrations, tests\n"
        "```\n"
        "\n"
        "### 📌 5. Integración con Editores y Git  \n\n"
        "✔️ **VSCode**: Instalar la extensión **Python** y activar flake8 en la configuración.  \n\n"
        "✔️ **PyCharm**: Configurar flake8 en **Preferences > Tools > External Tools**.  \n\n"
        "✔️ **Git Hooks**: Evitar commits con código incorrecto:  \n"
        "```\n\n"
        "flake8 --exit-zero && git commit -m 'Código limpio'\n"
        "```\n"
        "\n"
        "### 📌 6. Ejemplo Práctico con Errores  \n\n"
        "Código con errores de estilo:  \n"
        "```\n\n"
        "def sumar(a,b):return a+b\n\n"
        "print(sumar(3,4))\n"
        "```\n\n"
        "Al ejecutar flake8 mi_script.py, veremos:  \n"
        "```\n\n"
        'mi_script.py:1:10: E231 missing whitespace after ","\n\n'
        "mi_script.py:1:18: E701 multiple statements on one line\n"
        "```\n\n"
        "Corrección según PEP 8:  \n"
        "```\n\n"
        "def sumar(a, b):\n\n"
        "    return a + b\n"
        "\n"
        "print(sumar(3, 4))\n"
        "```\n\n"
        "Ahora, flake8 no mostrará errores.\n"
        "\n"
        "### 📌 7. Conclusión  \n\n"
        "✔️ flake8 ayuda a mantener **un código limpio y de alta calidad**.  \n\n"
        "✔️ Es fácil de usar y **se integra con editores y Git**.  \n\n"
        "✔️ Permite **personalizar reglas** según las necesidades del proyecto.  \n\n"
        "✔️ **Evita errores comunes** antes de ejecutar el código.  \n"
        "\n"
        "🚀 **Usar `flake8` mejora la calidad del código y facilita la colaboración en equipo.**  \n"
        "\n"
        "Un Saludo de RuXx 😊\n"
    ),

    (
        "black",
        "# 📌 Black: Formateador de Código en Python  \n"
        "\n"
        "**Black** es una herramienta que **formatea automáticamente** el código Python siguiendo convenciones estandarizadas. A diferencia de flake8, que solo analiza y señala errores de estilo, **Black modifica el código directamente para que cumpla con las mejores prácticas**.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar Black?  \n\n"
        "✔️ **Formateo automático:** No hay que preocuparse por los espacios, comas o saltos de línea.  \n\n"
        "✔️ **Código uniforme:** Mantiene el mismo estilo en todo el proyecto.  \n\n"
        "✔️ **Compatible con PEP 8:** Sigue el estándar oficial de Python.  \n\n"
        "✔️ **Ahorra tiempo:** No necesitas corregir manualmente el formato del código.  \n"
        "\n"
        "### 📌 2. Instalación de Black  \n\n"
        "Para instalarlo, simplemente usa `pip`:  \n"
        "```\n\n"
        "pip install black\n"
        "```\n\n"
        "Para comprobar que está instalado correctamente:  \n"
        "```\n\n"
        "black --version\n"
        "```\n"
        "\n"
        "### 📌 3. Uso Básico de Black  \n\n"
        "Para formatear un archivo Python, simplemente ejecuta:  \n"
        "```\n\n"
        "black mi_script.py\n"
        "```\n\n"
        "Esto modificará automáticamente el código en `mi_script.py`, aplicando un formato estandarizado.  \n"
        "\n"
        "Si queremos ver los cambios antes de aplicarlos, usamos `--check`:  \n"
        "```\n\n"
        "black --check mi_script.py\n"
        "```\n\n"
        "Esto nos dirá si el archivo necesita ser reformateado sin modificarlo.\n"
        "\n"
        "### 📌 4. Ejemplo Paso a Paso de Formateo con Black  \n\n"
        "Supongamos que tenemos el siguiente código mal formateado en `mi_script.py`:  \n"
        "```\n\n"
        "def calcular_precio(base, impuesto, descuento):\n\n"
        "  precio_final = base + base*impuesto - descuento\n\n"
        "  return precio_final\n"
        "```\n\n"
        "Si ejecutamos black mi_script.py, Black automáticamente lo reformatea así:  \n"
        "```\n\n"
        "def calcular_precio(base, impuesto, descuento):\n\n"
        "    precio_final = base + base * impuesto - descuento\n\n"
        "    return precio_final\n"
        "```\n\n"
        "🔹 **Cambios realizados por Black:**  \n\n"
        "- **Corrigió la indentación**: Usó 4 espacios en lugar de 2.  \n\n"
        "- **Añadió espacios alrededor de operadores (`*`, `-`)** para mejorar la legibilidad.  \n\n"
        "- **Aplicó un estilo consistente** en todo el código.  \n"
        "\n"
        "### 📌 5. Formateo de Código Extenso  \n\n"
        "Si tenemos una línea demasiado larga:  \n"
        "```\n\n"
        "def funcion_muy_larga(nombre, edad, direccion, telefono, email, ocupacion, empresa, salario, estado_civil):\n\n"
        "    print(f'Nombre: {nombre}, Edad: {edad}, Dirección: {direccion}, Teléfono: {telefono}, Email: {email}')\n"
        "```\n\n"
        "Black lo dividirá automáticamente en varias líneas para mejorar la legibilidad:  \n"
        "```\n\n"
        "def funcion_muy_larga(\n\n"
        "    nombre,\n\n"
        "    edad,\n\n"
        "    direccion,\n\n"
        "    telefono,\n\n"
        "    email,\n\n"
        "    ocupacion,\n\n"
        "    empresa,\n\n"
        "    salario,\n\n"
        "    estado_civil,\n\n"
        "):\n\n"
        "    print(\n\n"
        "        f'Nombre: {nombre}, Edad: {edad}, Dirección: {direccion}, Teléfono: {telefono}, Email: {email}'\n\n"
        "    )\n"
        "```\n\n"
        "🔹 **Cambios hechos por Black:**  \n\n"
        "- **Dividió los parámetros en varias líneas**.  \n\n"
        "- **Aplicó saltos de línea inteligentes** para evitar que la línea supere el límite recomendado.  \n"
        "\n"
        "### 📌 6. Personalización de Black  \n\n"
        "Por defecto, Black usa un **límite de 88 caracteres por línea**, pero podemos cambiarlo con --line-length.  \n"
        "```\n\n"
        "black --line-length 100 mi_script.py\n"
        "```\n\n"
        "Si queremos excluir ciertos archivos, podemos crear un archivo pyproject.toml en el proyecto:  \n"
        "```\n\n"
        "[tool.black]\n\n"
        "line-length = 100\n\n"
        "exclude = 'migrations/'\n"
        "```\n\n"
        "Esto hará que Black ignore archivos dentro de la carpeta migrations/.\n"
        "\n"
        "### 📌 7. Integración con Editores y Git  \n\n"
        "✔️ **VSCode**: Instala la extensión **Python** y selecciona `black` como formateador en la configuración.  \n\n"
        "✔️ **PyCharm**: Se puede configurar en **Preferences > Tools > Black**.  \n\n"
        "✔️ **Pre-commit con Git**: Para evitar commits con código mal formateado, podemos usar un hook:  \n"
        "```\n\n"
        "pip install pre-commit\n\n"
        "pre-commit install\n"
        "```\n\n"
        "Luego, agregamos `black` en `.pre-commit-config.yaml`:  \n"
        "```\n\n"
        "repos:\n\n"
        "  - repo: https://github.com/psf/black\n\n"
        "    rev: stable\n\n"
        "    hooks:\n\n"
        "      - id: black\n"
        "```\n\n"
        "Ahora, cada vez que intentemos hacer `git commit`, Black corregirá automáticamente el código.\n"
        "\n"
        "### 📌 8. Conclusión**  \n\n"
        "✔️ black **automatiza el formateo** del código Python.  \n\n"
        "✔️ Asegura un **estilo consistente** y profesional.  \n\n"
        "✔️ Se puede **personalizar** según las necesidades del proyecto.  \n\n"
        "✔️ Facilita el trabajo en equipo al eliminar debates sobre formato.  \n"
        "\n"
        "🚀 **Usar Black te permite centrarte en la lógica del código y no en los espacios o comas.**  \n"
        "\n"
        "¿Seguimos con otro tema? 😊\n"
    ),

    (
        "Mypy",
        "# 📌 Mypy: Verificación Estática de Tipos en Python  \n"
        "\n"
        "**Mypy** es una herramienta que permite **verificar tipos en Python** de manera estática. Aunque Python es un lenguaje dinámico, Mypy ayuda a detectar errores de tipo **antes de ejecutar el código**, mejorando la seguridad y mantenibilidad.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar Mypy?  \n\n"
        "✔️ **Evita errores en tiempo de ejecución** detectando problemas de tipo.  \n\n"
        "✔️ **Facilita la lectura del código** con anotaciones de tipo explícitas.  \n\n"
        "✔️ **Mejora la mantenibilidad** en proyectos grandes.  \n\n"
        "✔️ **Compatible con código Python estándar**, sin afectar su ejecución.  \n"
        "\n"
        "### 📌 2. Instalación de Mypy  \n\n"
        "Para instalarlo, simplemente usa pip:  \n"
        "```\n\n"
        "pip install mypy\n"
        "```\n\n"
        "Para verificar la instalación:  \n"
        "```\n\n"
        "mypy --version\n"
        "```\n"
        "\n"
        "### 📌 3. Uso Básico de Mypy  \n\n"
        "Supongamos que tenemos este código en `mi_script.py`:  \n"
        "```\n\n"
        "def sumar(a, b):\n\n"
        "    return a + b\n"
        "```\n\n"
        "Si ejecutamos:  \n"
        "```\n\n"
        "mypy mi_script.py\n"
        "```\n\n"
        "No mostrará errores porque Python permite operaciones sin definir tipos.  \n"
        "\n"
        "Sin embargo, si queremos **hacerlo más seguro**, podemos agregar anotaciones de tipo:  \n"
        "```\n\n"
        "def sumar(a: int, b: int) -> int:\n\n"
        "    return a + b\n"
        "```\n\n"
        "Ahora, si llamamos `sumar('10', 5)`, Mypy detectará un error sin ejecutar el código:  \n"
        "```\n\n"
        "mi_script.py:4: error: Argument 1 to 'sumar' has incompatible type 'str'; expected 'int'\n"
        "```\n"
        "\n"
        "### 📌 4. Detección de Errores con Mypy  \n\n"
        "Mypy detecta errores comunes de tipo como:  \n"
        "\n"
        "🔹 **Uso incorrecto de tipos**:  \n"
        "```\n\n"
        "def dividir(a: int, b: int) -> float:\n\n"
        "    return a / b\n"
        "\n"
        "resultado: int = dividir(10, 2)  # Error: dividir() devuelve float, no int\n"
        "```\n\n"
        "Al ejecutar `mypy mi_script.py`, obtendremos:  \n"
        "```\n\n"
        "mi_script.py:5: error: Incompatible types in assignment (expression has type 'float', variable has type 'int')\n"
        "```\n"
        "\n"
        "🔹 **Retorno incorrecto**:  \n"
        "```\n\n"
        "def mensaje() -> str:\n\n"
        "    return 123  # Error: Se espera str, pero retorna int\n"
        "```\n\n"
        "Mypy mostrará:  \n"
        "```\n\n"
        "mi_script.py:2: error: Incompatible return value type (got 'int', expected 'str')\n"
        "```\n"
        "\n"
        "### 📌 5. Tipado en Listas y Diccionarios  \n\n"
        "Mypy también verifica estructuras de datos como listas y diccionarios:  \n"
        "\n"
        "🔹 **Ejemplo correcto:**  \n"
        "```\n\n"
        "from typing import List, Dict\n"
        "\n"
        "numeros: List[int] = [1, 2, 3, 4]\n\n"
        "edades: Dict[str, int] = {'Alice': 30, 'Bob': 25}\n"
        "```\n\n"
        "🔹 **Ejemplo con error:**  \n"
        "```\n\n"
        "numeros: List[int] = [1, 'dos', 3]  # Error: 'dos' es un str, no un int\n"
        "```\n\n"
        "Mypy mostrará:  \n"
        "```\n\n"
        "mi_script.py:1: error: List item 1 has incompatible type 'str'; expected 'int'\n"
        "```\n"
        "\n"
        "### 📌 6. Tipos Opcionales y None  \n\n"
        "Si una variable puede ser `None`, debemos usar `Optional`:  \n"
        "```\n\n"
        "from typing import Optional\n"
        "\n"
        "def obtener_nombre(id: int) -> Optional[str]:\n\n"
        "    if id == 1:\n\n"
        "        return 'Carlos'\n\n"
        "    return None  # Correcto, porque el retorno puede ser None\n"
        "```\n\n"
        "Si intentamos usar obtener_nombre(2).upper(), Mypy advertirá:  \n"
        "```\n\n"
        "error: Item 'None' has no attribute 'upper'\n"
        "```\n\n"
        "Para solucionarlo, verificamos primero si el valor es None:  \n"
        "```\n\n"
        "nombre = obtener_nombre(2)\n\n"
        "if nombre is not None:\n\n"
        "    print(nombre.upper())  # Ahora no hay error\n"
        "```\n"
        "\n"
        "### 📌 7. Tipado en Clases  \n\n"
        "Mypy también verifica tipos en clases:  \n"
        "```\n\n"
        "class Persona:\n\n"
        "    def __init__(self, nombre: str, edad: int):\n\n"
        "        self.nombre = nombre\n\n"
        "        self.edad = edad\n"
        "\n"
        "    def saludar(self) -> str:\n\n"
        "        return f'Hola, soy {self.nombre} y tengo {self.edad} años.'\n"
        "\n"
        "p = Persona('Ana', 25)\n\n"
        "print(p.saludar())\n"
        "```\n\n"
        "Si intentamos crear una persona con valores incorrectos:  \n"
        "```\n\n"
        "p = Persona(123, 'veinticinco')  # Error: nombre debe ser str y edad un int\n"
        "```\n\n"
        "Mypy nos avisará antes de ejecutarlo.\n"
        "\n"
        "### 📌 8. Ignorar Errores de Mypy  \n\n"
        "Si queremos que Mypy ignore una línea específica, usamos # type: ignore:  \n"
        "```\n\n"
        "def sumar(a: int, b: int) -> int:\n\n"
        "    return a + b\n"
        "\n"
        "resultado: int = sumar('10', 5)  # type: ignore\n"
        "```\n\n"
        "Esto **omitirá la advertencia**, pero no es recomendable abusar de esta práctica.\n"
        "\n"
        "### 📌 9. Integración con VSCode y Git  \n\n"
        "✔️ **VSCode**: Instalar la extensión **Pylance** y activar 'Type Checking Mode'.  \n\n"
        "✔️ **Pre-commit con Git**: Para evitar commits con errores de tipo:  \n"
        "```\n\n"
        "pip install pre-commit\n\n"
        "pre-commit install\n"
        "```\n\n"
        "Luego, agregamos Mypy en `.pre-commit-config.yaml`:  \n"
        "```\n\n"
        "repos:\n\n"
        "  - repo: https://github.com/pre-commit/mirrors-mypy\n\n"
        "    rev: v1.0\n\n"
        "    hooks:\n\n"
        "      - id: mypy\n"
        "```\n\n"
        "Cada vez que intentemos hacer `git commit`, Mypy verificará el código antes de enviarlo.\n"
        "\n"
        "### 📌 10. Conclusión  \n\n"
        "✔️ `mypy` **detecta errores de tipo antes de la ejecución**, mejorando la seguridad del código.  \n\n"
        "✔️ Compatible con **anotaciones de tipo (`int`, `str`, `List`, `Optional`, etc.)**.  \n\n"
        "✔️ Útil para **proyectos grandes y colaborativos**.  \n\n"
        "✔️ Se integra fácilmente con **VSCode, Git y otras herramientas**.  \n"
        "\n"
        "🚀 **Mypy hace que Python sea más seguro sin perder su flexibilidad.**  \n"
    ),

    (
        "isort",
        "# 📌 isort: Ordenando Importaciones en Python  \n"
        "**isort** es una herramienta que **ordena automáticamente las importaciones** en Python de manera estructurada y siguiendo buenas prácticas. Esto mejora la legibilidad del código y evita problemas con importaciones desordenadas o duplicadas.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar isort?  \n\n"
        "✔️ **Ordena las importaciones** automáticamente en bloques lógicos.  \n\n"
        "✔️ **Evita importaciones duplicadas** o desorganizadas.  \n\n"
        "✔️ **Mejora la legibilidad** y mantiene un estilo uniforme.  \n\n"
        "✔️ **Se integra con herramientas como `black`, `flake8` y `pre-commit`**.  \n"
        "\n"
        "### 📌 2. Instalación de isort  \n\n"
        "Para instalarlo, simplemente usa `pip`:  \n"
        "```\n\n"
        "pip install isort\n"
        "```\n\n"
        "Para verificar que está instalado correctamente:  \n"
        "```\n\n"
        "isort --version\n"
        "```\n"
        "\n"
        "### 📌 3. Uso Básico de isort  \n\n"
        "Supongamos que tenemos un archivo `mi_script.py` con las importaciones desordenadas:  \n"
        "```\n\n"
        "import sys\n\n"
        "import os\n\n"
        "import json\n\n"
        "import requests\n\n"
        "from datetime import datetime\n\n"
        "from collections import defaultdict\n"
        "```\n\n"
        "Para ordenarlas automáticamente, ejecutamos:  \n"
        "```\n\n"
        "isort mi_script.py\n"
        "```\n\n"
        "Después de aplicar `isort`, el código quedará estructurado así:  \n"
        "```\n\n"
        "import json\n\n"
        "import os\n\n"
        "import sys\n"
        "\n"
        "from collections import defaultdict\n\n"
        "from datetime import datetime\n"
        "\n"
        "import requests\n"
        "```\n\n"
        "🔹 **Cambios realizados por isort:**  \n\n"
        "- **Agrupó las importaciones** en tres bloques:  \n\n"
        "  1. **Módulos estándar de Python** (json, os, sys).  \n\n"
        "  2. **Módulos de la biblioteca estándar organizados por submódulos** (collections, datetime).  \n\n"
        "  3. **Módulos de terceros** (requests).  \n\n"
        "- **Ordenó alfabéticamente dentro de cada grupo**.  \n"
        "\n"
        "## **📌 4. Verificar sin Modificar Código**  \n\n"
        "Si queremos comprobar si las importaciones están desordenadas sin cambiarlas, usamos:  \n"
        "```\n\n"
        "isort --check-only mi_script.py\n"
        "```\n\n"
        "Si hay problemas, mostrará un mensaje indicando qué cambios serían necesarios.\n"
        "\n"
        "## **📌 5. Personalización de isort**  \n\n"
        "Podemos configurar isort mediante un archivo `pyproject.toml`:  \n"
        "```\n\n"
        "[tool.isort]\n\n"
        "profile = 'black'\n\n"
        "multi_line_output = 3\n\n"
        "line_length = 100\n"
        "```\n\n"
        "🔹 profile = 'black' hace que isort sea compatible con black.  \n\n"
        "🔹 multi_line_output = 3 cambia el estilo de las importaciones largas.  \n\n"
        "🔹 line_length = 100 define el límite de caracteres por línea.  \n"
        "\n"
        "Para aplicar la configuración personalizada en el código, ejecutamos:  \n"
        "```\n\n"
        "isort .\n"
        "```\n\n"
        "Esto aplicará isort a **todos los archivos del proyecto**.\n"
        "\n"
        "### 📌 6. Uso en Proyectos Grandes  \n\n"
        "Si queremos ordenar todas las importaciones en un proyecto, ejecutamos:  \n"
        "```\n\n"
        "isort .\n"
        "```\n\n"
        "🔹 Esto recorrerá **todos los archivos Python** en el directorio actual y los formateará.  \n"
        "\n"
        "También podemos excluir ciertas carpetas si no queremos que isort las toque:  \n"
        "```\n\n"
        "isort . --skip migrations\n"
        "```\n\n"
        "🔹 Esto evitará modificar la carpeta `migrations`, que suele usarse en proyectos Django.\n"
        "\n"
        "### 📌 7. Integración con Editores y Git  \n\n"
        "✔️ **VSCode**: Instalar la extensión **Python** y habilitar isort en la configuración.  \n\n"
        "✔️ **PyCharm**: Agregar isort en **Preferences > Tools > External Tools**.  \n\n"
        "✔️ **Pre-commit con Git**: Para aplicar isort antes de cada commit, añadimos esto a .pre-commit-config.yaml:  \n"
        "```\n\n"
        "repos:\n\n"
        "  - repo: https://github.com/pycqa/isort\n\n"
        "    rev: 5.12.0\n\n"
        "    hooks:\n\n"
        "      - id: isort\n"
        "```\n\n"
        "Ahora, cada vez que intentemos hacer `git commit`, isort ordenará las importaciones antes de guardar los cambios.\n"
        "\n"
        "### 📌 8. Conclusión  \n\n"
        "✔️ isort **automatiza el orden de importaciones**, evitando código desordenado.  \n\n"
        "✔️ Se integra fácilmente con **`black`, `flake8`, `mypy` y `pre-commit`**.  \n\n"
        "✔️ Permite **personalización** con pyproject.toml.  \n\n"
        "✔️ Facilita la colaboración en equipos manteniendo **un código uniforme y legible**.  \n"
        "\n"
        "🚀 **Usar isort mejora la organización del código y hace que trabajar en equipo sea más fácil.**  \n"
        "\n"
        "¡Listo! ¿Quieres repasar algún otro tema? 😃\n"
    ),

    (
        "gestor de dependencias",
        "# 📌 **Gestor de Dependencias en Python**  \n"
        "Un **gestor de dependencias** en Python es una herramienta que **automatiza la instalación, actualización y administración de paquetes** en un proyecto. Su objetivo es garantizar que todas las bibliotecas necesarias estén disponibles y en versiones compatibles.  \n"
        "\n"
        "### 📌 1. ¿Por qué usar un gestor de dependencias?  \n\n"
        "✔️ **Evita conflictos de versiones** entre paquetes.  \n\n"
        "✔️ **Facilita la instalación** de todas las bibliotecas necesarias con un solo comando.  \n\n"
        "✔️ **Mantiene un entorno controlado** para cada proyecto.  \n\n"
        "✔️ **Permite compartir el entorno** con otros desarrolladores mediante archivos de requerimientos.  \n"
        "\n"
        "### 📌 2. Tipos de Gestores de Dependencias en Python  \n\n"
        "En Python existen varios gestores de dependencias, pero los más comunes son:  \n"
        "\n"
        "🔹 **pip**: El gestor oficial de Python.  \n\n"
        "🔹 **pipenv**: Gestiona dependencias y entornos virtuales al mismo tiempo.  \n\n"
        "🔹 **poetry**: Un gestor más avanzado que facilita la gestión de proyectos.  \n\n"
        "🔹 **conda**: Usado en ciencia de datos, administra paquetes y entornos virtuales.  \n"
        "\n"
        "Aquí nos enfocaremos en `pip` y `pipenv`, que son los más utilizados en desarrollo estándar.  \n"
        "\n"
        "### 📌 3. Uso de pip: El Gestor de Dependencias Oficial  \n"
        "\n"
        "📌 **Instalación de paquetes con pip**  \n\n"
        "Para instalar un paquete, usamos:  \n"
        "```\n\n"
        "pip install requests\n"
        "```\n\n"
        "Esto instalará la biblioteca `requests`, usada para hacer peticiones HTTP.  \n"
        "\n"
        "Si queremos instalar una versión específica:  \n"
        "```\n\n"
        "pip install requests==2.26.0\n"
        "```\n\n"
        "🔹 Esto asegurará que usamos exactamente la versión `2.26.0`.  \n"
        "\n"
        " **📌 Guardar Dependencias en un Archivo (requirements.txt)**  \n\n"
        "Para compartir nuestro entorno con otros desarrolladores, podemos guardar las dependencias en un archivo `requirements.txt`:  \n"
        "```\n\n"
        "pip freeze > requirements.txt\n"
        "```\n\n"
        "🔹 Esto generará un archivo con todas las bibliotecas instaladas en el proyecto, por ejemplo:  \n"
        "```\n\n"
        "requests==2.26.0\n\n"
        "numpy==1.21.2\n\n"
        "flask==2.0.2\n"
        "```\n\n"
        "Para instalar todas las dependencias de un proyecto en otro equipo, simplemente usamos:  \n"
        "```\n\n"
        "pip install -r requirements.txt\n"
        "```\n\n"
        "🔹 Esto instalará automáticamente todas las bibliotecas con sus versiones exactas.  \n"
        "\n"
        "### 📌 4. Uso de pipenv: Administración de Dependencias y Entornos Virtuales  \n"
        "\n"
        "pipenv combina la gestión de paquetes con la administración de entornos virtuales.  \n"
        "\n"
        " **📌 Instalación de pipenv**  \n"
        "```\n\n"
        "pip install pipenv\n"
        "```\n\n"
        "Para inicializar un nuevo proyecto con `pipenv`, usamos:  \n"
        "```\n\n"
        "pipenv install\n"
        "```\n\n"
        "Esto creará un entorno virtual y dos archivos importantes:  \n"
        "\n"
        "🔹 Pipfile: Contiene las dependencias del proyecto.  \n\n"
        "🔹 Pipfile.lock: Asegura que se usen las mismas versiones en cualquier entorno.  \n"
        "\n"
        "**📌 Instalación de paquetes con pipenv**  \n"
        "```\n\n"
        "pipenv install flask\n"
        "```\n\n"
        "🔹 Esto instala flask y lo agrega al Pipfile.  \n"
        "\n"
        "Si queremos instalar un paquete solo para desarrollo (ejemplo: pytest):  \n"
        "```\n\n"
        "pipenv install pytest --dev\n"
        "```\n\n"
        "🔹 Esto lo agregará en la sección [dev-packages] del Pipfile.  \n"
        "\n"
        " **📌 Activar el entorno virtual con pipenv**  \n"
        "```\n\n"
        "pipenv shell\n"
        "```\n\n"
        "🔹 Esto inicia un entorno aislado donde solo están las dependencias del proyecto.  \n"
        "\n"
        "Para salir del entorno virtual:  \n"
        "```\n\n"
        "exit\n"
        "```\n"
        "\n"
        " **📌 Desinstalar un paquete con pipenv**  \n\n"
        "Si queremos eliminar un paquete:  \n"
        "```\n\n"
        "pipenv uninstall flask\n"
        "```\n\n"
        "🔹 Esto lo eliminará y actualizará el `Pipfile`.  \n"
        "\n"
        "### 📌 5. Diferencia entre pip y pipenv  \n"
        "\n"
        "- `pip` solo instala paquetes y necesita un entorno virtual separado (`venv`).  \n\n"
        "- `pipenv` gestiona tanto las dependencias como el entorno virtual en un solo paso.  \n\n"
        "- `pip` usa `requirements.txt`, mientras que `pipenv` usa `Pipfile` y `Pipfile.lock`.  \n"
        "\n"
        "Si trabajas en **proyectos grandes**, `pipenv` es más conveniente. Si solo necesitas **instalar paquetes rápidamente**, `pip` es suficiente.  \n"
        "\n"
        "### 📌 6. Eliminación de Dependencias No Usadas  \n\n"
        "Si queremos eliminar paquetes no utilizados en el proyecto, podemos usar:  \n"
        "```\n\n"
        "pipenv clean\n"
        "```\n\n"
        "🔹 Esto elimina cualquier paquete instalado que no esté en el `Pipfile`.  \n"
        "\n"
        "### 📌 7. Uso de poetry (Alternativa Moderna a pipenv)  \n\n"
        "poetry es otra herramienta que facilita la gestión de paquetes y dependencias. Para instalarlo:  \n"
        "```\n\n"
        "pip install poetry\n"
        "```\n\n"
        "Para iniciar un nuevo proyecto con poetry:  \n"
        "```\n\n"
        "poetry init\n"
        "```\n\n"
        "Para instalar un paquete:  \n"
        "```\n\n"
        "poetry add requests\n"
        "```\n\n"
        "🔹 poetry es más rápido y eficiente que pipenv, pero todavía no es tan popular.  \n"
        "\n"
        "### 📌 8. Conclusión \n\n"
        "✔️ Un **gestor de dependencias** facilita la instalación y actualización de paquetes.  \n\n"
        "✔️ pip es la opción más sencilla y funciona con requirements.txt.  \n\n"
        "✔️ pipenv combina gestión de dependencias y entornos virtuales con `Pipfile`.  \n\n"
        "✔️ poetry es una alternativa más moderna y eficiente a pipenv.  \n"
        "\n"
        "🚀 **Usar un buen gestor de dependencias evita problemas y mejora la organización del proyecto.**  \n"
    ),

    (
        "packaging",
        "# 📌 Packaging en Python: Creación y Distribución de Paquetes  \n"
        "El **packaging** en Python se refiere al proceso de **empaquetar código** para que pueda ser reutilizado e instalado fácilmente en otros proyectos o compartido con la comunidad.  \n"
        "\n"
        "Cuando creamos un paquete en Python, podemos distribuirlo a través de **PyPI (Python Package Index)** o compartirlo dentro de una empresa o equipo.  \n"
        "### 📌 1. ¿Por qué hacer un paquete en Python?  \n\n"
        "✔️ **Reutilización de código** en múltiples proyectos.  \n\n"
        "✔️ **Distribución sencilla** a otros desarrolladores mediante pip.  \n\n"
        "✔️ **Modularización** para facilitar el mantenimiento del código.  \n\n"
        "✔️ **Publicación en PyPI** para compartir la biblioteca con la comunidad.  \n"
        "\n"
        "### 📌 2. Estructura de un Paquete en Python  \n\n"
        "Un paquete en Python es un directorio que contiene un archivo especial __init__.py. Este archivo indica que la carpeta es un **paquete importable**.  \n"
        "\n"
        "Ejemplo de estructura de un paquete llamado mi_paquete:  \n"
        "```\n\n"
        "mi_paquete/\n\n"
        "│── mi_paquete/\n\n"
        "│   ├── __init__.py\n\n"
        "│   ├── modulo1.py\n\n"
        "│   ├── modulo2.py\n\n"
        "│── setup.py\n\n"
        "│── README.md\n\n"
        "│── pyproject.toml\n"
        "```\n\n"
        "🔹 mi_paquete/ → Carpeta principal del paquete.  \n\n"
        "🔹 __init__.py → Indica que es un paquete Python.  \n\n"
        "🔹 modulo1.py, modulo2.py → Archivos con funcionalidad.  \n\n"
        "🔹 setup.py → Archivo de configuración para empaquetar el proyecto.  \n\n"
        "🔹 README.md → Documentación del paquete.  \n\n"
        "🔹 pyproject.toml → Configuración moderna del paquete.  \n"
        "\n"
        "### 📌 3. Creación de un Paquete  \n"
        "\n"
        " **📌 Paso 1: Crear la Carpeta del Paquete**  \n\n"
        "Primero, creamos la carpeta del paquete:  \n"
        "```\n\n"
        "mkdir mi_paquete\n\n"
        "cd mi_paquete\n"
        "```\n"
        "\n"
        "Dentro, creamos la carpeta del código:  \n"
        "```\n\n"
        "mkdir mi_paquete\n\n"
        "touch mi_paquete/__init__.py\n"
        "```\n\n"
        "🔹 `touch` crea el archivo vacío __init__.py.  \n"
        "\n"
        "**📌 Paso 2: Agregar Código al Paquete**  \n\n"
        "Creamos un archivo modulo1.py dentro de mi_paquete/:  \n"
        "```\n\n"
        "# mi_paquete/modulo1.py\n\n"
        "def saludar(nombre):\n\n"
        "    return f'Hola, {nombre}!'\n"
        "```\n\n"
        "Esto define una función `saludar()` que podemos importar desde el paquete.\n"
        "\n"
        "**📌 Paso 3: Configurar setup.py (Método Clásico)**  \n\n"
        "Creamos un archivo setup.py en la raíz del paquete:  \n"
        "```\n\n"
        "from setuptools import setup, find_packages\n"
        "\n"
        "setup(\n\n"
        "    name='mi_paquete',\n\n"
        "    version='0.1',\n\n"
        "    packages=find_packages(),\n\n"
        "    install_requires=[],\n\n"
        "    author='Tu Nombre',\n\n"
        "    description='Un paquete de ejemplo en Python',\n\n"
        "    long_description=open('README.md').read(),\n\n"
        ")\n"
        "```\n\n"
        "🔹 name → Nombre del paquete.  \n\n"
        "🔹 version → Versión del paquete.  \n\n"
        "🔹 packages=find_packages() → Detecta automáticamente todos los submódulos.  \n\n"
        "🔹 install_requires=[] → Lista de dependencias requeridas (vacía en este caso).  \n"
        "\n"
        "Para instalar este paquete localmente, ejecutamos:  \n"
        "```\n\n"
        "pip install .\n"
        "```\n\n"
        "🔹 Esto instala mi_paquete en nuestro entorno y podemos importarlo desde cualquier script.  \n"
        "\n"
        "### 📌 4. Creación con pyproject.toml (Método Moderno con setuptools o poetry)**  \n\n"
        "El archivo pyproject.toml es la forma moderna de definir un paquete. Creamos este archivo:  \n"
        "```\n\n"
        "[build-system]\n\n"
        "requires = ['setuptools']\n\n"
        "build-backend = 'setuptools.build_meta'\n"
        "\n"
        "[project]\n\n"
        "name = 'mi_paquete'\n\n"
        "version = '0.1.0'\n\n"
        "description = 'Un paquete de ejemplo en Python'\n\n"
        "authors = [{name = 'Tu Nombre'}]\n\n"
        "dependencies = []\n"
        "```\n\n"
        "Ahora podemos construir el paquete con:  \n"
        "```\n\n"
        "python -m build\n"
        "```\n\n"
        "🔹 Esto generará los archivos .whl y .tar.gz listos para distribución.\n"
        "\n"
        "### 📌 5. Subir un Paquete a PyPI**  \n"
        "\n"
        "**📌 Instalamos las herramientas necesarias**  \n"
        "```\n\n"
        "pip install twine build\n"
        "```\n"
        "\n"
        "**📌 Construimos el paquete**  \n"
        "```\n\n"
        "python -m build\n"
        "```\n\n"
        "Esto generará dos archivos dentro de dist/, por ejemplo:  \n"
        "```\n\n"
        "dist/\n\n"
        "│── mi_paquete-0.1.0-py3-none-any.whl\n\n"
        "│── mi_paquete-0.1.0.tar.gz\n"
        "```\n"
        "\n"
        "**📌 Subimos el paquete a PyPI**  \n\n"
        "Si es la primera vez, registramos nuestra cuenta en **https://pypi.org/**.  \n\n"
        "Luego, subimos el paquete con:  \n"
        "```\n\n"
        "twine upload dist/*\n"
        "```\n\n"
        "Esto pedirá las credenciales de PyPI y subirá el paquete.\n"
        "\n"
        "## **📌 6. Instalar el Paquete desde PyPI**  \n\n"
        "Una vez publicado, cualquier usuario puede instalarlo con:  \n"
        "```\n\n"
        "pip install mi_paquete\n"
        "```\n"
        "\n"
        "### 📌 7. Distribuir un Paquete de Forma Privada**  \n\n"
        "Si no queremos subirlo a PyPI, podemos compartir el paquete con otros desarrolladores usando un archivo .whl:  \n"
        "```\n\n"
        "pip install mi_paquete-0.1.0-py3-none-any.whl\n"
        "```\n\n"
        "También podemos publicarlo en un **repositorio privado** usando herramientas como **GitHub Packages o Nexus**.\n"
        "\n"
        "### 📌 8. Conclusión  \n\n"
        "✔️ **El packaging permite crear y distribuir bibliotecas reutilizables.**  \n\n"
        "✔️ **Usar setup.py o pyproject.toml facilita la gestión del paquete.**  \n\n"
        "✔️ **Podemos instalarlo localmente o subirlo a PyPI para compartirlo.**  \n"
        "\n"
        "🚀 **Ahora ya puedes crear y publicar tu propio paquete en Python!**  \n"  
    ),

    (
        "documentacion",
        "# 📌 Documentación en Python: Sphinx, MkDocs y Docstrings  \n"
        "La documentación es una parte fundamental en cualquier proyecto de software. Un código bien documentado facilita la comprensión, el mantenimiento y la colaboración con otros desarrolladores.  \n"
        "Python ofrece múltiples herramientas para documentar código, entre ellas:  \n\n"
        "✔️ **Docstrings** → Comentarios en el código para documentar funciones, clases y módulos.  \n\n"
        "✔️ **Sphinx** → Generación de documentación en formato HTML/PDF.  \n\n"
        "✔️ **MkDocs** → Creación de documentación estática con Markdown.  \n"
        "\n"
        "### 📌 1. Uso de Docstrings en Python  \n"
        "\n"
        "\n"
        "**📌 Ejemplo de docstring básico en una función**  \n"
        "```\n\n"
        "def suma(a, b):\n\n"
        "    #Suma dos números y devuelve el resultado.\n\n"
        "    return a + b\n"
        "```\n"
        "\n"
        "Para acceder al docstring desde el código, usamos:  \n"
        "```\n\n"
        "print(suma.__doc__)\n"
        "```\n\n"
        "Salida:  \n"
        "```\n\n"
        "Suma dos números y devuelve el resultado.\n"
        "```\n"
        "\n"
        "### 📌 2. Estilos de Docstrings (Google, NumPy, reStructuredText)  \n"
        "\n"
        "Para escribir docstrings bien estructurados, se siguen convenciones como **Google Style**, **NumPy Style** o **reStructuredText (reST)**.  \n"
        "\n"
        "**📌 a) Google Style**  \n\n"
        "Es un formato limpio y fácil de leer.  \n"
        "\n"
        "```\n\n"
        "def dividir(a: int, b: int) -> float:\n\n"
        "    #Divide dos números.\n"
        "\n"
        "    #Args:\n\n"
        "        #a (int): Numerador.\n\n"
        "        #b (int): Denominador.\n"
        "\n"
        "    #Returns:\n\n"
        "        #float: Resultado de la división.\n"
        "\n"
        "    #Raises:\n\n"
        "        #ValueError: Si `b` es cero.\n"
        "    \n"
        "    if b == 0:\n\n"
        "        raise ValueError('El divisor no puede ser cero.')\n\n"
        "    return a / b\n"
        "```\n"
        "\n"
        "**📌 b) NumPy Style**  \n\n"
        "Muy usado en proyectos científicos y matemáticos.  \n"
        "\n"
        "```\n\n"
        "def multiplicar(a, b):\n\n"
        "    Multiplica dos números.\n"
        "\n"
        "    Parameters\n\n"
        "    ----------\n\n"
        "    a : int\n\n"
        "        Primer número.\n\n"
        "    b : int\n\n"
        "        Segundo número.\n"
        "\n"
        "    Returns\n\n"
        "    -------\n\n"
        "    int\n\n"
        "        Producto de `a` y `b`.\n"
        "    \n"
        "    return a * b\n"
        "```\n"
        "\n"
        "**📌 c) reStructuredText (reST)**\n\n"
        "Formato usado en **Sphinx**.  \n"
        "\n"
        "```\n\n"
        "def restar(a, b):\n\n"
        "    Resta dos números.\n"
        "\n"
        "    :param a: Primer número.\n\n"
        "    :type a: int\n\n"
        "    :param b: Segundo número.\n\n"
        "    :type b: int\n\n"
        "    :return: Resultado de la resta.\n\n"
        "    :rtype: int\n"
        "    \n"
        "    return a - b\n"
        "```\n"
        "\n"
        "### 📌 3. Uso de Sphinx para Documentación Avanzada  \n"
        "\n"
        "**Sphinx** es una herramienta que genera documentación en **HTML, PDF o EPUB** a partir de docstrings en formato reST o Markdown.  \n"
        "\n"
        "**📌 Instalación de Sphinx**  \n"
        "```\n\n"
        "pip install sphinx\n"
        "```\n"
        "\n"
        "**📌 Inicializar un Proyecto con Sphinx**  \n"
        "```\n\n"
        "sphinx-quickstart\n"
        "```\n\n"
        "Este comando crea una estructura de proyecto con archivos básicos de configuración.  \n"
        "\n"
        "**📌 Generar Documentación Automática**  \n\n"
        "Si tenemos un módulo llamado mi_modulo.py, podemos generar su documentación automáticamente:  \n"
        "\n"
        "```\n\n"
        "sphinx-apidoc -o docs/ .\n"
        "```\n\n"
        "Esto creará archivos en la carpeta docs/.  \n"
        "\n"
        "Luego, para compilar la documentación:  \n"
        "```\n\n"
        "cd docs\n\n"
        "make html\n"
        "```\n\n"
        "La documentación en HTML se guardará en `docs/_build/html/index.html`.\n"
        "\n"
        "🔹 **Sphinx** es ideal para proyectos grandes y con muchas dependencias.\n"
        "\n"
        "### 📌 4. Uso de MkDocs para Documentación Estática \n"
        "\n"
        "**MkDocs** permite crear documentación en sitios web estáticos usando **Markdown**. Es más ligero y fácil de usar que Sphinx.  \n"
        "\n"
        "**📌 Instalación de MkDocs**  \n"
        "```\n\n"
        "pip install mkdocs\n"
        "```\n"
        "\n"
        "**📌 Crear un Nuevo Proyecto con MkDocs**  \n"
        "```\n\n"
        "mkdocs new mi_documentacion\n\n"
        "cd mi_documentacion\n"
        "```\n"
        "\n"
        "Esto generará una estructura como esta:  \n"
        "```\n\n"
        "mi_documentacion/\n\n"
        "│── docs/\n\n"
        "│   ├── index.md  # Página principal en Markdown\n\n"
        "│── mkdocs.yml    # Archivo de configuración\n"
        "```\n"
        "\n"
        "**📌 Iniciar un Servidor Local para Ver la Documentación**  \n"
        "```\n\n"
        "mkdocs serve\n"
        "```\n\n"
        "🔹 Esto iniciará un servidor en `http://127.0.0.1:8000/` donde podemos ver la documentación en vivo.\n"
        "\n"
        "**📌 Publicar la Documentación en GitHub Pages**  \n"
        "```\n\n"
        "mkdocs build\n\n"
        "mkdocs gh-deploy\n"
        "```\n\n"
        "🔹 Con este comando, la documentación se sube automáticamente a **GitHub Pages**.\n"
        "\n"
        "### 📌 5. ¿Cuándo Usar Sphinx vs MkDocs?  \n"
        "\n"
        "✔️ **Sphinx** → Si necesitas documentación **generada automáticamente** desde docstrings y soporte para múltiples formatos (HTML, PDF, EPUB).  \n\n"
        "✔️ **MkDocs** → Si quieres documentación **ligera, rápida y fácil de mantener** con Markdown.  \n"
        "\n"
        "### 📌 6. Conclusión  \n\n"
        "✔️ **Docstrings** permiten documentar funciones, clases y módulos en el código.  \n\n"
        "✔️ **Existen varios estilos de docstrings**: Google, NumPy y reST.  \n\n"
        "✔️ **Sphinx** genera documentación profesional en HTML/PDF a partir de docstrings.  \n\n"
        "✔️ **MkDocs** crea documentación ligera con Markdown y la publica en GitHub Pages.  \n"
        "\n"
        "🚀 **Documentar el código correctamente mejora la calidad y facilita su mantenimiento!**  \n"
        "\n"
        "¿Quieres ejemplos más detallados de Sphinx o MkDocs? 😃\n"
    ),

    (
        "fastAPI",
        "# 🚀 FastAPI: Creación de APIs Rápidas y Modernas en Python  \n"
        "\n"
        "FastAPI es un **framework web** moderno y de alto rendimiento para construir **APIs REST** en Python. Se basa en **Starlette** y **Pydantic**, lo que permite una fácil validación de datos y una documentación automática.  \n"
        "### 📌 1. ¿Por qué usar FastAPI?  \n"
        "\n"
        "✔️ **Alto rendimiento**: Es tan rápido como frameworks en Node.js y Go.  \n\n"
        "✔️ **Validación automática**: Usa **Pydantic** para validar datos sin escribir código extra.  \n\n"
        "✔️ **Swagger y ReDoc**: Genera documentación automática interactiva para la API.  \n\n"
        "✔️ **Compatible con ASGI**: Soporta *WebSockets* y tareas en segundo plano.  \n\n"
        "✔️ **Tipado estático**: Usa *type hints* de Python para definir modelos de datos.  \n"
        "\n"
        "### 📌 2. Instalación de FastAPI y Uvicorn  \n"
        "\n"
        "Para comenzar, instalamos **FastAPI** y **Uvicorn** (servidor ASGI):  \n"
        "```\n\n"
        "pip install fastapi uvicorn\n"
        "```\n"
        "\n"
        "###  3. Creación de una API con FastAPI  \n"
        "\n"
        "Vamos a crear un **servidor API básico** con un endpoint que devuelve un mensaje de bienvenida.  \n"
        "\n"
        "**📌 Paso 1: Crear el archivo main.py**  \n"
        "```\n\n"
        "from fastapi import FastAPI\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "@app.get('/')\n\n"
        "def read_root():\n\n"
        "    return {'mensaje': '¡Bienvenido a FastAPI!'}\n"
        "```\n"
        "\n"
        "**📌 Paso 2: Ejecutar el servidor con Uvicorn**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n\n"
        "🔹 main:app → Indica que app está en main.py.  \n\n"
        "🔹 --reload → Reinicia el servidor automáticamente en cambios.  \n"
        "\n"
        "Ahora podemos acceder a la API en:  \n\n"
        "📌 **http://127.0.0.1:8000/**  \n"
        "\n"
        "### 📌 4. Creación de Rutas con Parámetros \n"
        "\n"
        "Podemos definir rutas con **parámetros dinámicos**:  \n"
        "\n"
        "```\n\n"
        "@app.get('/saludo/{nombre}')\n\n"
        "def saludar(nombre: str):\n\n"
        "    return {'mensaje': f'Hola, {nombre}!'}\n"
        "```\n\n"
        "📌 **Ejemplo de uso**:  \n\n"
        "Si visitamos **http://127.0.0.1:8000/saludo/Juan**, obtenemos:  \n"
        "```\n\n"
        "{'mensaje': 'Hola, Juan!'}\n"
        "```\n"
        "\n"
        "### 📌 5. Validación de Datos con Pydantic  \n"
        "\n"
        "FastAPI permite validar **datos de entrada** con **modelos de Pydantic**.  \n"
        "\n"
        "```\n\n"
        "from pydantic import BaseModel\n"
        "\n"
        "class Usuario(BaseModel):\n\n"
        "    nombre: str\n\n"
        "    edad: int\n\n"
        "    email: str\n"
        "\n"
        "@app.post('/usuario/')\n\n"
        "def crear_usuario(usuario: Usuario):\n\n"
        "    return {'mensaje': f'Usuario {usuario.nombre} creado correctamente!'}\n"
        "```\n\n"
        "📌 **Prueba con un JSON** en **POST**:  \n"
        "```\n\n"
        "{\n\n"
        "    'nombre': 'Carlos',\n\n"
        "    'edad': 30,\n\n"
        "    'email': 'carlos@example.com'\n\n"
        "}\n"
        "```\n\n"
        "🔹 Si enviamos datos incorrectos, FastAPI **rechaza la solicitud automáticamente**.  \n"
        "\n"
        "### 📌 6. Documentación Automática con Swagger  \n"
        "\n"
        "FastAPI genera automáticamente una **documentación interactiva**:  \n"
        "\n"
        "📌 **Swagger UI** → [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)  \n\n"
        "📌 **Redoc UI** → [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc)  \n"
        "\n"
        "### 📌 7. Manejo de Errores y Respuestas Personalizadas  \n"
        "\n"
        "Podemos manejar errores con **HTTPException**:  \n"
        "\n"
        "```\n\n"
        "from fastapi import HTTPException\n"
        "\n"
        "@app.get('/usuario/{id}')\n\n"
        "def obtener_usuario(id: int):\n\n"
        "    if id != 1:\n\n"
        "        raise HTTPException(status_code=404, detail='Usuario no encontrado')\n\n"
        "    return {'id': id, 'nombre': 'Carlos'}\n"
        "```\n"
        "\n"
        "Si solicitamos **http://127.0.0.1:8000/usuario/2**, obtenemos:  \n"
        "```\n\n"
        "{'detail': 'Usuario no encontrado'}\n"
        "```\n"
        "\n"
        "### 📌 8. Conexión con Base de Datos (Ejemplo con SQLite y SQLAlchemy)  \n"
        "\n"
        "**📌 Instalamos SQLAlchemy y SQLite**  \n"
        "```\n\n"
        "pip install sqlalchemy sqlite\n"
        "```\n"
        "\n"
        "**📌 Creamos el Modelo de Base de Datos**  \n"
        "```\n\n"
        "from sqlalchemy import Column, Integer, String, create_engine\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "\n"
        "DATABASE_URL = 'sqlite:///./test.db'\n"
        "\n"
        "engine = create_engine(DATABASE_URL)\n\n"
        "SessionLocal = sessionmaker(bind=engine)\n"
        "\n"
        "Base = declarative_base()\n"
        "\n"
        "class UsuarioDB(Base):\n\n"
        "    __tablename__ = 'usuarios'\n\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    email = Column(String, unique=True, index=True)\n"
        "\n"
        "Base.metadata.create_all(bind=engine)\n"
        "```\n"
        "\n"
        "### 📌 9. Conclusión  \n\n"
        "✔️ **FastAPI es rápido, seguro y fácil de usar**.  \n\n"
        "✔️ **Ofrece documentación automática y validación de datos**.  \n\n"
        "✔️ **Ideal para crear APIs modernas y escalables**.  \n"
        "\n"
        "🚀 **¿Listo para construir tu primera API con FastAPI?** 😃\n"

    ),

    (
        "sqlalchemy",
        "# 🔥 SQLAlchemy: ORM y Conexión a Bases de Datos en Python  \n"
        "\n"
        "### 📌 1. ¿Qué es SQLAlchemy?  \n\n"
        "SQLAlchemy es una **biblioteca de Python** que proporciona herramientas para interactuar con bases de datos relacionales de manera eficiente. Funciona como un **ORM (Object Relational Mapper)**, lo que permite trabajar con bases de datos usando **objetos Python en lugar de SQL puro**.  \n"
        "\n"
        "### 📌 2. ¿Por qué usar SQLAlchemy?  \n"
        "\n"
        "✔️ **Evita escribir SQL manualmente** → En lugar de hacer consultas con *SELECT*, *INSERT*, etc., usamos objetos y clases.  \n\n"
        "✔️ **Compatible con múltiples bases de datos** → MySQL, PostgreSQL, SQLite, Oracle, etc.  \n\n"
        "✔️ **Más seguridad** → Evita ataques por *inyección SQL* al trabajar con parámetros predefinidos.  \n\n"
        "✔️ **Facilita la migración** → Permite cambiar de motor de base de datos sin modificar el código.  \n\n"
        "✔️ **Optimización de consultas** → Soporta consultas avanzadas y caché de consultas.  \n"
        "\n"
        "### 📌 3. Instalación de SQLAlchemy  \n"
        "\n"
        "Para comenzar, instalamos la librería con:  \n"
        "```\n\n"
        "pip install sqlalchemy\n"
        "```\n\n"
        "Si usaremos *SQLite* (base de datos ligera en archivos), *viene incluida en Python* y no es necesario instalar nada más.  \n"
        "\n"
        "Para bases como **PostgreSQL o MySQL**, debemos instalar un controlador adicional:  \n"
        "```\n\n"
        "pip install psycopg2  # Para PostgreSQL\n\n"
        "pip install pymysql    # Para MySQL\n"
        "```\n"
        "\n"
        "### 📌 4. Conexión a una Base de Datos con SQLAlchemy  \n"
        "\n"
        "**📌 a) Configurar la Conexión**  \n\n"
        "Lo primero es definir la **URL de conexión** y el motor:  \n"
        "```\n\n"
        "from sqlalchemy import create_engine\n"
        "\n"
        "# Conexión a SQLite\n\n"
        "DATABASE_URL = 'sqlite:///./test.db'\n\n"
        "engine = create_engine(DATABASE_URL, echo=True)  # echo=True muestra las consultas en la consola\n"
        "```\n\n"
        "🔹 Si queremos usar **PostgreSQL**:  \n"
        "```\n\n"
        "DATABASE_URL = 'postgresql://usuario:password@localhost/nombre_db'\n\n"
        "engine = create_engine(DATABASE_URL)\n"
        "```\n"
        "\n"
        "### 📌 5. Definir Modelos con SQLAlchemy (ORM)  \n"
        "\n"
        "Creamos una **clase** que represente una tabla en la base de datos.  \n"
        "\n"
        "```\n\n"
        "from sqlalchemy import Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n"
        "\n"
        "Base = declarative_base()\n"
        "\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    email = Column(String, unique=True, index=True)\n"
        "\n"
        "```\n\n"
        "🔹 **Cada clase representa una tabla** y los atributos son **columnas**.  \n"
        "\n"
        "Ahora, para **crear la tabla en la base de datos**:  \n"
        "```\n\n"
        "Base.metadata.create_all(bind=engine)\n"
        "```\n"
        "\n"
        "### 📌 6. Crear una Sesión y Operaciones CRUD  \n"
        "\n"
        "Para interactuar con la base de datos, usamos una **sesión**.  \n"
        "\n"
        "**📌 a) Crear una Sesión**  \n"
        "```\n\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "\n"
        "SessionLocal = sessionmaker(bind=engine)\n\n"
        "session = SessionLocal()\n"
        "```\n"
        "\n"
        "**📌 b) Insertar Datos en la Base de Datos**  \n"
        "\n"
        "```\n\n"
        "nuevo_usuario = Usuario(nombre='Carlos', email='carlos@example.com')\n\n"
        "session.add(nuevo_usuario)  # Agregamos el usuario\n\n"
        "session.commit()  # Guardamos los cambios\n\n"
        "session.refresh(nuevo_usuario)  # Refrescamos el objeto en memoria\n\n"
        "print(nuevo_usuario.id)  # Mostramos el ID generado\n"
        "```\n"
        "\n"
        "**📌 c) Consultar Datos (Leer)**  \n"
        "\n"
        "```\n\n"
        "usuarios = session.query(Usuario).all()  # Obtener todos los usuarios\n\n"
        "for usuario in usuarios:\n\n"
        "    print(usuario.nombre, usuario.email)\n"
        "```\n"
        "\n"
        "Si queremos **buscar un usuario por email**:  \n"
        "```\n\n"
        "usuario = session.query(Usuario).filter(Usuario.email == 'carlos@example.com').first()\n\n"
        "print(usuario.nombre)  # Imprime 'Carlos'\n"
        "```\n"
        "\n"
        "**📌 d) Actualizar un Registro**  \n"
        "\n"
        "```\n\n"
        "usuario = session.query(Usuario).filter(Usuario.nombre == 'Carlos').first()\n\n"
        "usuario.email = 'nuevo_email@example.com'\n\n"
        "session.commit()  # Guardamos los cambios\n"
        "```\n"
        "\n"
        "**📌 e) Eliminar un Registro**  \n"
        "\n"
        "```\n\n"
        "usuario = session.query(Usuario).filter(Usuario.nombre == 'Carlos').first()\n\n"
        "session.delete(usuario)\n\n"
        "session.commit()  # Eliminamos el usuario\n"
        "```\n"
        "\n"
        "### 📌 7. Ventajas y Desventajas de SQLAlchemy  \n"
        "\n"
        "### **✅ Ventajas**  \n\n"
        "✔️ **Código más limpio y mantenible** → No necesitas escribir SQL manualmente.  \n\n"
        "✔️ **Independencia de base de datos** → Puedes cambiar de SQLite a PostgreSQL sin modificar mucho código.  \n\n"
        "✔️ **Protección contra inyecciones SQL** → Al usar objetos y parámetros, evita ataques.  \n\n"
        "✔️ **Mejor manejo de conexiones** → Optimiza el acceso a la base de datos.  \n"
        "\n"
        "### **❌ Desventajas**  \n\n"
        "⚠️ **Curva de aprendizaje** → Más complicado que usar SQL directo.  \n\n"
        "⚠️ **Ligera pérdida de rendimiento** → Ejecutar ORM es un poco más lento que consultas SQL nativas.  \n\n"
        "⚠️ **Mayor consumo de memoria** → Puede no ser ideal en aplicaciones con muchas consultas simultáneas.  \n"
        "\n"
        "### 📌 8. Conclusión**  \n\n"
        "🔹 **SQLAlchemy es una herramienta poderosa** para trabajar con bases de datos en Python de forma eficiente.  \n\n"
        "🔹 Permite interactuar con la base de datos sin escribir SQL, gracias al **ORM**.  \n\n"
        "🔹 Es compatible con **múltiples motores de bases de datos** y ofrece seguridad frente a ataques SQL.  \n\n"
        "🔹 Aunque tiene una curva de aprendizaje, **facilita el mantenimiento y escalabilidad del código**.  \n"
        "\n"
        "🚀 **¿Listo para usar SQLAlchemy en tu proyecto?** 😃\n"
        "\n"
        "*Este proyecto utiliza SQLAclchemy espero que lo hayas entendido un Saludo =)*\n"
    ),

    (
        "alembic",
        "# 🔥 Alembic: Migraciones de Base de Datos en Python con SQLAlchemy  \n"
        "\n"
        "### 📌 1. ¿Qué es Alembic?  \n"
        "Alembic es una herramienta que permite gestionar **migraciones de bases de datos** en proyectos que usan **SQLAlchemy**.  \n"
        "\n"
        "Cuando trabajamos con SQLAlchemy y modificamos los modelos (tablas y columnas), la base de datos no se actualiza automáticamente. Ahí es donde entra **Alembic**, permitiendo:  \n"
        "\n"
        "✔️ **Crear y aplicar migraciones** cuando cambian los modelos.  \n\n"
        "✔️ **Actualizar la base de datos sin perder datos existentes**.  \n\n"
        "✔️ **Mantener un historial de cambios** para revertir migraciones si es necesario.  \n\n"
        "✔️ **Automatizar la creación de versiones de la base de datos**.  \n"
        "\n"
        "### 📌 2. Instalación de Alembic  \n"
        "\n"
        "Para instalar Alembic, usamos:  \n"
        "```\n\n"
        "pip install alembic\n"
        "```\n\n"
        "Este comando agrega **Alembic** a nuestro entorno de desarrollo.  \n"
        "\n"
        "### 📌 3. Configurar Alembic en un Proyecto  \n"
        "\n"
        "Para inicializar Alembic en un proyecto con SQLAlchemy, usamos:  \n"
        "```\n\n"
        "alembic init alembic\n"
        "```\n\n"
        "🔹 Esto crea una carpeta llamada alembic/ con archivos de configuración y scripts de migración.  \n\n"
        "🔹 También se genera un archivo alembic.ini, donde se define la conexión a la base de datos.  \n"
        "\n"
        "### 📌 4. Configurar la Conexión a la Base de Datos  \n"
        "\n"
        "Editamos el archivo alembic.ini y buscamos la línea que define la URL de la base de datos:  \n"
        "```\n\n"
        "sqlalchemy.url = sqlite:///./test.db\n"
        "```\n\n"
        "Si usamos PostgreSQL, la URL sería algo como:  \n"
        "```\n\n"
        "sqlalchemy.url = postgresql://usuario:password@localhost/nombre_db\n"
        "```\n"
        "\n"
        "También podemos configurar la conexión en alembic/env.py. Buscamos la línea que define target_metadata y agregamos nuestros modelos:  \n"
        "```\n\n"
        "from my_app.database import Base  # Importamos el modelo Base de SQLAlchemy\n"
        "\n"
        "target_metadata = Base.metadata  # Alembic leerá los modelos desde aquí\n"
        "```\n"
        "\n"
        "### 📌 5. Crear y Aplicar Migraciones  \n"
        "\n"
        "**📌 a) Generar una Migración**  \n"
        "\n"
        "Para crear un script de migración, usamos:  \n"
        "```\n\n"
        "alembic revision --autogenerate -m 'Crear tabla usuarios'\n"
        "```\n\n"
        "🔹 `--autogenerate` permite que Alembic detecte automáticamente los cambios en los modelos.  \n\n"
        "🔹 `-m` permite escribir un mensaje descriptivo para la migración.  \n"
        "\n"
        "Esto genera un archivo en `alembic/versions/` con código para aplicar la migración.  \n"
        "\n"
        "**📌 b) Aplicar una Migración**  \n"
        "\n"
        "Para actualizar la base de datos con los cambios definidos en la migración, ejecutamos:  \n"
        "```\n\n"
        "alembic upgrade head\n"
        "```\n\n"
        "🔹 Esto aplicará los cambios y actualizará la base de datos.  \n"
        "\n"
        "Si en algún momento necesitamos **deshacer** la última migración:  \n"
        "```\n\n"
        "alembic downgrade -1\n"
        "```\n\n"
        "🔹 Esto revierte la migración más reciente.  \n"
        "\n"
        "### 📌 6. Ejemplo Práctico de Migraciones con Alembic  \n"
        "\n"
        "**📌 a) Creamos un Modelo de SQLAlchemy**  \n"
        "\n"
        "Imaginemos que tenemos un modelo de usuario en `models.py`:  \n"
        "```\n\n"
        "from sqlalchemy import Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n"
        "\n"
        "Base = declarative_base()\n"
        "\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    email = Column(String, unique=True, index=True)\n"
        "```\n"
        "\n"
        "**📌 b) Generamos la Primera Migración**  \n"
        "\n"
        "Ejecutamos:  \n"
        "```\n\n"
        "alembic revision --autogenerate -m 'Crear tabla usuarios'\n"
        "```\n\n"
        "🔹 Esto genera un archivo en alembic/versions/ con código que crea la tabla usuarios.  \n"
        "\n"
        "Ahora aplicamos la migración:  \n"
        "```\n\n"
        "alembic upgrade head\n"
        "```\n\n"
        "🔹 Se crea la tabla `usuarios` en la base de datos.  \n"
        "\n"
        "**📌 c) Modificamos el Modelo y Creamos otra Migración**  \n"
        "\n"
        "Supongamos que agregamos un nuevo campo `edad` al modelo:  \n"
        "```\n\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    email = Column(String, unique=True, index=True)\n\n"
        "    edad = Column(Integer)  # Nuevo campo\n"
        "```\n"
        "\n"
        "Generamos una nueva migración:  \n"
        "```\n\n"
        "alembic revision --autogenerate -m 'Agregar campo edad a usuarios'\n"
        "```\n\n"
        "Y aplicamos la migración:  \n"
        "```\n\n"
        "alembic upgrade head\n"
        "```\n\n"
        "🔹 Ahora la tabla `usuarios` tiene una nueva columna `edad`.  \n"
        "\n"
        "### 📌 7. Ver el Historial de Migraciones  \n"
        "\n"
        "Para ver las migraciones aplicadas, usamos:  \n"
        "```\n\n"
        "alembic history\n"
        "```\n\n"
        "Si queremos ver en qué versión estamos actualmente:  \n"
        "```\n\n"
        "alembic current\n"
        "```\n"
        "\n"
        "### 📌 8. Ventajas y Desventajas de Alembic  \n"
        "\n"
        "**✅ Ventajas**  \n\n"
        "✔️ **Gestión automática de cambios** → No es necesario modificar la base de datos manualmente.  \n\n"
        "✔️ **Historial de cambios** → Podemos revertir migraciones si algo sale mal.  \n\n"
        "✔️ **Compatibilidad con SQLAlchemy** → Se integra perfectamente con ORM.  \n\n"
        "✔️ **Ideal para proyectos en equipo** → Facilita el control de versiones de la base de datos.  \n"
        "\n"
        "**❌ Desventajas**  \n\n"
        "⚠️ **Requiere configuración inicial** → Se deben definir correctamente los modelos y la conexión.  \n\n"
        "⚠️ **Posibles conflictos en migraciones en equipos grandes** → Si varios desarrolladores generan migraciones al mismo tiempo, pueden chocar.  \n\n"
        "⚠️ **Curva de aprendizaje** → Puede ser confuso al inicio, especialmente cuando hay cambios complejos.  \n"
        "\n"
        "### 📌 9. Conclusión  \n"
        "\n"
        "Alembic es una herramienta poderosa que facilita la gestión de **migraciones de bases de datos** en proyectos con **SQLAlchemy**.  \n"
        "\n"
        "✔️ Permite actualizar la estructura de la base de datos sin perder datos.  \n\n"
        "✔️ Mantiene un historial de cambios para revertir migraciones si es necesario.  \n\n"
        "✔️ Se integra fácilmente con cualquier aplicación basada en **SQLAlchemy**.  \n"
        "\n"
        "🚀 **¿Listo para implementar migraciones con Alembic en tu proyecto?** 😃\n"
        "\n"
        "gl & hf =)\n"
    ),

    (
        "OAuth2",
        "# 🔐 OAuth2: Autenticación y Autorización en Aplicaciones Web \n"
        "\n"
        "### 📌 1. ¿Qué es OAuth2?  \n"
        "\n"
        "OAuth2 (**Open Authorization 2.0**) es un **protocolo estándar de autorización** que permite a aplicaciones conceder acceso seguro a recursos sin compartir credenciales como contraseñas.  \n"
        "\n"
        "Se usa comúnmente en **API y servicios web** para que los usuarios puedan iniciar sesión usando **Google, Facebook, GitHub, etc.**, sin exponer sus contraseñas.  \n"
        "\n"
        "### 📌 2. ¿Para qué sirve OAuth2?  \n"
        "\n"
        "✔️ **Permite autenticación sin compartir contraseñas** → El usuario inicia sesión con Google, Facebook, etc.  \n\n"
        "✔️ **Da acceso a recursos específicos** → Solo se otorgan permisos específicos (leer correos, acceder a fotos, etc.).  \n\n"
        "✔️ **Seguro y confiable** → Usa **tokens de acceso** en lugar de credenciales sensibles.  \n\n"
        "✔️ **Soporta aplicaciones móviles, web y servidores** → Funciona con cualquier plataforma.  \n"
        "\n"
        "### 📌 3. Cómo funciona OAuth2  \n"
        "\n"
        "OAuth2 se basa en **tokens de acceso** en lugar de compartir contraseñas. Funciona en cuatro partes principales:  \n"
        "\n"
        "1️⃣ **Usuario (Resource Owner)** → La persona que da acceso a sus datos.  \n\n"
        "2️⃣ **Cliente (Client App)** → La aplicación que quiere acceder a los datos del usuario.  \n\n"
        "3️⃣ **Servidor de Autorización (Authorization Server)** → El servicio que autentica y emite los tokens.  \n\n"
        "4️⃣ **Servidor de Recursos (Resource Server)** → La API que contiene los datos protegidos.  \n"
        "\n"
        "**Ejemplo**: Un usuario quiere iniciar sesión en una aplicación usando su cuenta de Google.  \n"
        "\n"
        "### 📌 4. Flujo de Autenticación con OAuth2  \n"
        "\n"
        "**1 El usuario accede a la aplicación y elige iniciar sesión con Google**  \n\n"
        "La aplicación redirige al usuario a Google para autenticarse.  \n"
        "\n"
        "```\n\n"
        "https://accounts.google.com/o/oauth2/auth?\n\n"
        "    client_id=TU_CLIENT_ID\n\n"
        "    &redirect_uri=TU_REDIRECT_URI\n\n"
        "    &response_type=code\n\n"
        "    &scope=email profile\n"
        "```\n\n"
        "- `client_id` → Identifica la aplicación que solicita acceso.  \n\n"
        "- `redirect_uri` → URL donde se enviará la respuesta después de autenticarse.  \n\n"
        "- `response_type=code` → Indica que queremos un **código de autorización**.  \n\n"
        "- `scope=email profile` → Permisos que estamos solicitando (email, perfil, etc.).  \n"
        "\n"
        "**2️⃣ El usuario inicia sesión y autoriza la aplicación**  \n\n"
        "Google muestra una pantalla pidiendo al usuario que **autorice el acceso** a su perfil.  \n"
        "\n"
        "**3️⃣ Google envía un 'Código de Autorización' a la aplicación**  \n\n"
        "Una vez autorizado, Google redirige al usuario de regreso a la aplicación con un **código temporal** en la URL:  \n"
        "\n"
        "```\n\n"
        "https://tuapp.com/callback?code=4/XYZ123\n"
        "```\n\n"
        "La aplicación usa este código para solicitar un **token de acceso**.  \n"
        "\n"
        "**4️⃣ La aplicación intercambia el código por un token de acceso**  \n\n"
        "La aplicación envía una petición **POST** a Google con el código recibido:  \n"
        "\n"
        "```\n\n"
        "POST https://oauth2.googleapis.com/token\n\n"
        "Content-Type: application/x-www-form-urlencoded\n"
        "\n"
        "client_id=TU_CLIENT_ID\n\n"
        "&client_secret=TU_CLIENT_SECRET\n\n"
        "&code=4/XYZ123\n\n"
        "&redirect_uri=TU_REDIRECT_URI\n\n"
        "&grant_type=authorization_code\n"
        "```\n\n"
        "Google responde con un **token de acceso**:  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  'access_token': 'ya29.a0AfH6SM...',\n\n"
        "  'expires_in': 3600,\n\n"
        "  'token_type': 'Bearer',\n\n"
        "  'refresh_token': '1//0g...'\n\n"
        "}\n"
        "```\n"
        "\n"
        "- `access_token` → Token que permite acceder a los datos del usuario.  \n\n"
        "- `expires_in` → Tiempo de expiración en segundos (ejemplo: 3600 segundos = 1 hora).  \n\n"
        "- `token_type=Bearer` → Tipo de token utilizado.  \n\n"
        "- `refresh_token` → Permite obtener un nuevo **access_token** sin pedir credenciales nuevamente.  \n"
        "\n"
        "**5️⃣ La aplicación usa el token para acceder a los datos del usuario**  \n\n"
        "Ahora, la aplicación puede usar el **token de acceso** para consultar la API de Google:  \n"
        "\n"
        "```\n\n"
        "GET https://www.googleapis.com/oauth2/v1/userinfo\n\n"
        "Authorization: Bearer ya29.a0AfH6SM...\n"
        "```\n\n"
        "Google responde con los datos del usuario:  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  'id': '1234567890',\n\n"
        "  'email': 'usuario@gmail.com',\n\n"
        "  'name': 'Juan Pérez',\n\n"
        "  'picture': 'https://lh3.googleusercontent.com/photo.jpg'\n\n"
        "}\n"
        "```\n\n"
        "✔️ Ahora la aplicación conoce el **nombre, email y foto de perfil del usuario** sin pedir su contraseña.  \n"
        "\n"
        "### 📌 5. Implementación de OAuth2 en Python con FastAPI  \n"
        "\n"
        "Usaremos **FastAPI** y la librería oauthlib para manejar la autenticación con OAuth2.  \n"
        "\n"
        "**📌 a) Instalar las Dependencias**  \n"
        "```\n\n"
        "pip install fastapi[all] authlib\n"
        "```\n"
        "\n"
        "**📌 b) Configurar el Servidor OAuth2 en FastAPI**  \n\n"
        "Creamos `main.py` con el siguiente código:  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, Depends\n\n"
        "from fastapi.security import OAuth2AuthorizationCodeBearer\n\n"
        "from authlib.integrations.starlette_client import OAuth\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "# Configuración de OAuth2 con Google\n\n"
        "oauth = OAuth()\n\n"
        "oauth.register(\n\n"
        "    name='google',\n\n"
        "    client_id='TU_CLIENT_ID',\n\n"
        "    client_secret='TU_CLIENT_SECRET',\n\n"
        "    authorize_url='https://accounts.google.com/o/oauth2/auth',\n\n"
        "    access_token_url='https://oauth2.googleapis.com/token',\n\n"
        "    client_kwargs={'scope': 'openid email profile'}\n\n"
        ")\n"
        "\n"
        "# Ruta para iniciar el proceso de autenticación\n\n"
        "@app.get('/login')\n\n"
        "async def login():\n\n"
        "    return await oauth.google.authorize_redirect('http://localhost:8000/callback')\n"
        "\n"
        "# Ruta de retorno después de autenticarse con Google\n\n"
        "@app.get('/callback')\n\n"
        "async def callback():\n\n"
        "    token = await oauth.google.authorize_access_token()\n\n"
        "    user = await oauth.google.parse_id_token(token)\n\n"
        "    return {'user': user}\n"
        "\n"
        "```\n"
        "**📌 c) Explicación del Código**  \n"
        "\n"
        "1️⃣ **Definimos el servidor FastAPI** con `FastAPI()`.  \n\n"
        "2️⃣ **Configuramos OAuth2 con Google** → Definimos las URLs de autenticación y permisos (`scope`).  \n\n"
        "3️⃣ **Ruta `/login`** → Redirige al usuario a Google para autenticarse.  \n\n"
        "4️⃣ **Ruta `/callback`** → Recibe el token de acceso y obtiene la información del usuario.  \n"
        "\n"
        "**📌 d) Ejecutar el Servidor y Probar OAuth2**  \n\n"
        "Iniciamos el servidor con:  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n\n"
        "Accedemos a `http://localhost:8000/login` en el navegador.  \n\n"
        "✔️ Esto redirigirá a Google para autenticarse.  \n\n"
        "✔️ Luego, Google devolverá el usuario autenticado con su información.  \n"
        "\n"
        "### 📌 6. Ventajas y Desventajas de OAuth2  \n"
        "\n"
        "**✅ Ventajas**  \n\n"
        "✔️ **Mayor seguridad** → No se comparten contraseñas directamente.  \n\n"
        "✔️ **Permisos granulares** → Se puede controlar qué datos compartir.  \n\n"
        "✔️ **Amplio soporte** → Usado por Google, Facebook, GitHub, etc.  \n\n"
        "✔️ **Experiencia fluida para el usuario** → No necesita crear cuentas nuevas.  \n"
        "\n"
        "**❌ Desventajas**  \n\n"
        "⚠️ **Requiere configuración en el proveedor** → Necesita registrar la aplicación en Google, Facebook, etc.  \n\n"
        "⚠️ **Dependencia de terceros** → Si el proveedor falla, el inicio de sesión deja de funcionar.  \n\n"
        "⚠️ **Curva de aprendizaje** → La implementación puede ser compleja al inicio.  \n"
        "\n"
        "### 📌 7. Conclusión  \n"
        "\n"
        "OAuth2 es el estándar más usado para **autorización segura** en aplicaciones web y móviles.  \n"
        "\n"
        "✔️ Permite a los usuarios iniciar sesión sin compartir su contraseña.  \n\n"
        "✔️ Usa **tokens de acceso** para interactuar con APIs de terceros.  \n\n"
        "✔️ Se puede implementar fácilmente en **Python con FastAPI**.  \n"
        "\n"
        "🚀 **¿Listo para usar OAuth2 en tu aplicación?** 😃\n"
    ),

    (
        "JWT",
        "# 🔐 JSON Web Token (JWT): \n"
        "##Autenticación Segura en Aplicaciones Web  \n"
        "\n"
        "### 📌 1. ¿Qué es JWT?  \n"
        "\n"
        "JWT (**JSON Web Token**) es un **estándar de autenticación** basado en **tokens** que permite intercambiar información de forma segura entre un cliente y un servidor.  \n"
        "\n"
        "A diferencia de OAuth2, que se usa para **autorizar** acceso a recursos de terceros, JWT se usa principalmente para **autenticar usuarios** en una API sin necesidad de mantener sesiones en el servidor.  \n"
        "\n"
        "### 📌 2. ¿Para qué sirve JWT?  \n"
        "\n"
        "✔️ **Autenticación de usuarios** → Se usa para iniciar sesión en APIs y aplicaciones web.  \n\n"
        "✔️ **Comunicación segura entre microservicios** → Permite que los servicios intercambien información autenticada.  \n\n"
        "✔️ **Acceso sin mantener sesiones en el servidor** → JWT se envía en cada petición, eliminando la necesidad de sesiones en la base de datos.  \n\n"
        "✔️ **Uso en Single Page Applications (SPAs)** → Ideal para React, Angular o Vue.js, donde el frontend maneja la autenticación.  \n"
        "\n"
        "### 📌 3. Cómo funciona JWT  \n"
        "\n"
        "Un **JWT es un token que contiene información del usuario** en formato codificado y firmado.  \n"
        "\n"
        "Cuando un usuario inicia sesión en una API, el servidor genera un **token JWT** y lo devuelve al cliente.  \n"
        "\n"
        "Este token se usa en cada petición para demostrar que el usuario está autenticado.  \n"
        "\n"
        "### 📌 4. Estructura de un JWT  \n"
        "\n"
        "Un **JWT tiene tres partes** separadas por puntos (`.`):  \n"
        "\n"
        "```\n\n"
        "HEADER.PAYLOAD.SIGNATURE\n"
        "```\n"
        "\n"
        "** Header (Encabezado)**  \n\n"
        "Contiene el tipo de token y el algoritmo de firma.  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  'alg': 'HS256',\n\n"
        "  'typ': 'JWT'\n\n"
        "}\n"
        "```\n\n"
        "Ejemplo codificado en Base64:  \n"
        "\n"
        "```\n\n"
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n"
        "```\n"
        "\n"
        "** Payload (Cuerpo)**  \n\n"
        "Contiene la información del usuario y los claims (permisos y expiración).  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  'sub': '1234567890',\n\n"
        "  'name': 'Juan Pérez',\n\n"
        "  'role': 'admin',\n\n"
        "  'exp': 1711500000\n\n"
        "}\n"
        "```\n\n"
        "Ejemplo codificado en Base64:  \n"
        "\n"
        "```\n\n"
        "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikp1YW4gUGVyZXoiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MTE1MDAwMDB9\n"
        "```\n"
        "\n"
        "**Signature (Firma)**  \n\n"
        "Se genera con un secreto y el algoritmo especificado en el header.  \n"
        "\n"
        "```\n\n"
        "HMACSHA256(\n\n"
        "  base64UrlEncode(header) + '.' +\n\n"
        "  base64UrlEncode(payload),\n\n"
        "  secret\n\n"
        ")\n"
        "```\n\n"
        "Esto garantiza que **el token no ha sido modificado**.  \n"
        "\n"
        "Ejemplo de firma generada:  \n"
        "\n"
        "```\n\n"
        "SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n"
        "```\n"
        "\n"
        "🔹 **Token completo (JWT final):**  \n"
        "```\n\n"
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikp1YW4gUGVyZXoiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MTE1MDAwMDB9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n"
        "```\n"
        "\n"
        "### 📌 5. Implementación de JWT en Python con FastAPI  \n"
        "\n"
        "Para manejar JWT en una API con **FastAPI**, usamos la librería PyJWT.  \n"
        "\n"
        "**📌 a) Instalar Dependencias**  \n"
        "```\n\n"
        "pip install fastapi[all] pyjwt python-multipart\n"
        "```\n"
        "\n"
        "**📌 b) Configurar la Generación y Validación de Tokens**  \n"
        "\n"
        "Creamos main.py con el siguiente código:  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, HTTPException, Depends\n\n"
        "from datetime import datetime, timedelta\n\n"
        "import jwt  # Librería PyJWT\n\n"
        "from jwt.exceptions import ExpiredSignatureError, InvalidTokenError\n\n"
        "from fastapi.security import OAuth2PasswordBearer\n"
        "\n"
        "**Clave secreta para firmar los tokens (mantener segura)**\n\n"
        "SECRET_KEY = 'clave_secreta_super_segura'\n\n"
        "ALGORITHM = 'HS256'\n\n"
        "ACCESS_TOKEN_EXPIRE_MINUTES = 30\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "**Manejador de autenticación con OAuth2**\n\n"
        "oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')\n"
        "\n"
        "**Función para generar tokens JWT**\n\n"
        "def create_jwt_token(data: dict):\n\n"
        "    to_encode = data.copy()\n\n"
        "    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n\n"
        "    to_encode.update({'exp': expire})\n\n"
        "    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n\n"
        "    return encoded_jwt\n"
        "\n"
        "**Función para verificar y decodificar tokens**\n\n"
        "def verify_jwt_token(token: str = Depends(oauth2_scheme)):\n\n"
        "    try:\n\n"
        "        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n\n"
        "        return payload\n\n"
        "    except ExpiredSignatureError:\n\n"
        "        raise HTTPException(status_code=401, detail='Token expirado')\n\n"
        "    except InvalidTokenError:\n\n"
        "        raise HTTPException(status_code=401, detail='Token inválido')\n"
        "\n"
        "**Ruta para autenticar usuarios y devolver un token**\n\n"
        "@app.post('/login')\n\n"
        "async def login():\n\n"
        "    user_data = {'sub': '123', 'name': 'Juan Pérez', 'role': 'admin'}\n\n"
        "    token = create_jwt_token(user_data)\n\n"
        "    return {'access_token': token, 'token_type': 'bearer'}\n"
        "\n"
        "# Ruta protegida que solo puede acceder un usuario autenticado con JWT\n\n"
        "@app.get('/datos-protegidos')\n\n"
        "async def protected_route(payload: dict = Depends(verify_jwt_token)):\n\n"
        "    return {'mensaje': 'Acceso permitido', 'usuario': payload}\n"
        "```\n"
        "\n"
        "**📌 c) Explicación del Código**  \n"
        "\n"
        "1️⃣ **Definimos FastAPI y configuramos JWT** con `SECRET_KEY` y `HS256`.  \n\n"
        "2️⃣ **Función `create_jwt_token`** → Genera un JWT con un tiempo de expiración de 30 minutos.  \n\n"
        "3️⃣ **Función `verify_jwt_token`** → Decodifica el token y verifica si es válido.  \n\n"
        "4️⃣ **Ruta `/login`** → Devuelve un token JWT al usuario.  \n\n"
        "5️⃣ **Ruta protegida `/datos-protegidos`** → Solo accesible con un JWT válido.  \n"
        "\n"
        "**📌 d) Probar la API con JWT**  \n"
        "\n"
        "1️⃣ **Iniciar el servidor**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n\n"
        "2️⃣ **Obtener un token JWT**  \n\n"
        "Enviamos un `POST` a `http://localhost:8000/login`.  \n"
        "\n"
        "Ejemplo de respuesta:  \n"
        "```\n\n"
        "{\n\n"
        "  'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n\n"
        "  'token_type': 'bearer'\n\n"
        "}\n"
        "```\n\n"
        "3️⃣ **Acceder a la ruta protegida**  \n\n"
        "Enviamos un `GET` a `http://localhost:8000/datos-protegidos` con el JWT en el header:  \n"
        "```\n\n"
        "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n"
        "```\n\n"
        "✔️ Si el token es válido, devuelve:  \n"
        "```\n\n"
        "{\n\n"
        "  'mensaje': 'Acceso permitido',\n\n"
        "  'usuario': {\n\n"
        "    'sub': '123',\n\n"
        "    'name': 'Juan Pérez',\n\n"
        "    'role': 'admin',\n\n"
        "    'exp': 1711500000\n\n"
        "  }\n\n"
        "}\n"
        "```\n"
        "\n"
        "### 📌 6. Conclusión  \n"
        "\n"
        "JWT es una forma segura y eficiente de manejar la autenticación en aplicaciones web y APIs.  \n"
        "\n"
        "✔️ **Elimina la necesidad de sesiones en el servidor**.  \n\n"
        "✔️ **Permite autenticación sin almacenar credenciales en cada petición**.  \n\n"
        "✔️ **Se puede usar en APIs REST, microservicios y Single Page Applications**.  \n"
        "\n"
        "🚀 **¿Listo para implementar JWT en tu proyecto?** 😃\n"
    ),

    (
        "graphQL",
        "# 🚀 GraphQL: Consulta de Datos de Forma Flexible y Eficiente  \n"
        "\n"
        "### 📌 1. ¿Qué es GraphQL?  \n"
        "\n"
        "GraphQL es un **lenguaje de consulta para APIs** desarrollado por Facebook en 2012. A diferencia de REST, que expone múltiples endpoints con respuestas fijas, GraphQL permite a los clientes solicitar exactamente los datos que necesitan en una sola petición.  \n"
        "\n"
        "🔹 **Ventajas clave:**  \n\n"
        "✔️ Permite obtener solo los datos necesarios (**evita over-fetching y under-fetching**).  \n\n"
        "✔️ Una sola API puede atender múltiples clientes (**web, móvil, IoT**).  \n\n"
        "✔️ Reduce el número de peticiones al servidor (**una consulta puede obtener datos de múltiples fuentes**).  \n"
        "\n"
        "### 📌 2. Diferencia entre GraphQL y REST  \n"
        "\n"
        "🔹 **REST:**  \n\n"
        "- Se basa en **endpoints predefinidos** (/users, /products, etc.).  \n\n"
        "- Puede devolver más datos de los necesarios (**over-fetching**) o menos de los esperados (**under-fetching**).  \n\n"
        "- Cada recurso tiene su propio endpoint.  \n"
        "\n"
        "🔹 **GraphQL:**  \n\n"
        "- Usa un **único endpoint (/graphql)** para todas las consultas.  \n\n"
        "- El cliente elige qué datos recibir.  \n\n"
        "- Reduce la cantidad de llamadas al servidor.  \n"
        "\n"
        "### 📌 3. ¿Cómo funciona GraphQL?  \n"
        "\n"
        "**📌 a) Esquema (Schema)**  \n\n"
        "Define los tipos de datos y las consultas disponibles.  \n"
        "\n"
        "```\n\n"
        "type Usuario {\n\n"
        "  id: ID!\n\n"
        "  nombre: String!\n\n"
        "  edad: Int\n\n"
        "}\n"
        "\n"
        "type Query {\n\n"
        "  obtenerUsuarios: [Usuario]\n\n"
        "}\n"
        "```\n\n"
        "Este esquema define un **tipo Usuario** con `id`, `nombre` y `edad`.  \n"
        "\n"
        "**📌 b) Consultas (Queries)**  \n\n"
        "Los clientes pueden solicitar solo los datos que necesitan.  \n"
        "\n"
        "Ejemplo de consulta para obtener usuarios:  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  obtenerUsuarios {\n\n"
        "    id\n\n"
        "    nombre\n\n"
        "  }\n\n"
        "}\n"
        "```\n\n"
        "Respuesta esperada:  \n"
        "\n"
        "```\n\n"
        "{\n\n"
        "  'data': {\n\n"
        "    'obtenerUsuarios': [\n\n"
        "      { 'id': '1', 'nombre': 'Juan' },\n\n"
        "      { 'id': '2', 'nombre': 'Ana' }\n\n"
        "    ]\n\n"
        "  }\n\n"
        "}\n"
        "```\n\n"
        "El cliente recibe solo id y nombre, **sin traer datos innecesarios como edad**.  \n"
        "\n"
        "**📌 c) Mutaciones (Mutations)**  \n\n"
        "Permiten modificar datos en el servidor, como crear o actualizar usuarios.  \n"
        "\n"
        "Ejemplo de mutación para agregar un usuario:  \n"
        "\n"
        "```\n\n"
        "mutation {\n\n"
        "  crearUsuario(nombre: 'Carlos', edad: 30) {\n\n"
        "    id\n\n"
        "    nombre\n\n"
        "  }\n\n"
        "}\n"
        "```\n\n"
        "Respuesta esperada:  \n"
        "```\n\n"
        "{\n\n"
        "  'data': {\n\n"
        "    'crearUsuario': { 'id': '3', 'nombre': 'Carlos' }\n\n"
        "  }\n\n"
        "}\n"
        "```\n"
        "\n"
        "### 📌 4. Implementación de GraphQL en Python con FastAPI  \n"
        "\n"
        "Para integrar GraphQL en Python, usaremos **FastAPI** junto con **Strawberry GraphQL**.  \n"
        "\n"
        "**📌 a) Instalación de Dependencias**  \n"
        "```\n\n"
        "pip install fastapi strawberry-graphql uvicorn\n"
        "```\n"
        "\n"
        "**📌 b) Crear un Servidor GraphQL en FastAPI**  \n"
        "\n"
        "Creamos un archivo main.py con la API GraphQL:  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI\n\n"
        "import strawberry\n\n"
        "from strawberry.fastapi import GraphQLRouter\n\n"
        "from typing import List\n"
        "\n"
        "# Definir el tipo Usuario en GraphQL\n\n"
        "@strawberry.type\n\n"
        "class Usuario:\n\n"
        "    id: int\n\n"
        "    nombre: str\n\n"
        "    edad: int\n"
        "\n"
        "# Base de datos simulada\n\n"
        "usuarios_db = [\n\n"
        "    Usuario(id=1, nombre='Juan', edad=25),\n\n"
        "    Usuario(id=2, nombre='Ana', edad=30),\n\n"
        "]\n"
        "\n"
        "# Definir las consultas (Queries)\n\n"
        "@strawberry.type\n\n"
        "class Query:\n\n"
        "    @strawberry.field\n\n"
        "    def obtener_usuarios(self) -> List[Usuario]:\n\n"
        "        return usuarios_db\n"
        "\n"
        "# Definir las mutaciones (Mutations)\n\n"
        "@strawberry.type\n\n"
        "class Mutation:\n\n"
        "    @strawberry.mutation\n\n"
        "    def crear_usuario(self, nombre: str, edad: int) -> Usuario:\n\n"
        "        nuevo_usuario = Usuario(id=len(usuarios_db) + 1, nombre=nombre, edad=edad)\n\n"
        "        usuarios_db.append(nuevo_usuario)\n\n"
        "        return nuevo_usuario\n"
        "\n"
        "# Crear esquema GraphQL\n\n"
        "schema = strawberry.Schema(query=Query, mutation=Mutation)\n"
        "\n"
        "# Configurar FastAPI con GraphQL\n\n"
        "app = FastAPI()\n\n"
        "graphql_app = GraphQLRouter(schema)\n\n"
        "app.include_router(graphql_app, prefix='/graphql')\n"
        "\n"
        "# Ejecutar el servidor con: uvicorn main:app --reload\n"
        "```\n"
        "\n"
        "**📌 c) Explicación del Código**  \n"
        "\n"
        "1️⃣ **Definimos el modelo Usuario** con id, nombre y edad.  \n\n"
        "2️⃣ **Creamos una lista usuarios_db** para almacenar usuarios en memoria.  \n\n"
        "3️⃣ **Definimos la consulta obtener_usuarios** que devuelve la lista de usuarios.  \n\n"
        "4️⃣ **Creamos la mutación crear_usuario** para agregar nuevos usuarios.  \n\n"
        "5️⃣ **Registramos GraphQL en FastAPI** usando GraphQLRouter(schema).  \n"
        "\n"
        "**📌 d) Probar la API GraphQL**  \n"
        "\n"
        "1️⃣ **Iniciar el servidor**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n\n"
        "2️⃣ **Acceder a GraphQL Playground**  \n\n"
        "Abrimos en el navegador:  \n\n"
        "👉 [`http://localhost:8000/graphql`](http://localhost:8000/graphql)  \n"
        "\n"
        "3️⃣ **Ejecutar una consulta para obtener usuarios:**  \n"
        "```\n\n"
        "{\n\n"
        "  obtenerUsuarios {\n\n"
        "    id\n\n"
        "    nombre\n\n"
        "  }\n\n"
        "}\n"
        "```\n\n"
        "🔹 **Respuesta esperada:**  \n"
        "```\n\n"
        "{\n\n"
        "  'data': {\n\n"
        "    'obtenerUsuarios': [\n\n"
        "      { 'id': 1, 'nombre': 'Juan' },\n\n"
        "      { 'id': 2, 'nombre': 'Ana' }\n\n"
        "    ]\n\n"
        "  }\n\n"
        "}\n"
        "```\n"
        "\n"
        "4️⃣ **Ejecutar una mutación para agregar un usuario:**  \n"
        "```\n\n"
        "mutation {\n\n"
        "  crearUsuario(nombre: 'Carlos', edad: 28) {\n\n"
        "    id\n\n"
        "    nombre\n\n"
        "  }\n\n"
        "}\n"
        "```\n\n"
        "🔹 **Respuesta esperada:**  \n"
        "```\n\n"
        "{\n\n"
        "  'data': {\n\n"
        "    'crearUsuario': { 'id': 3, 'nombre': 'Carlos' }\n\n"
        "  }\n\n"
        "}\n"
        "```\n"
        "\n"
        "### 📌 5. Ventajas y Desventajas de GraphQL  \n"
        "\n"
        "✔️ **Permite obtener solo los datos necesarios**.  \n\n"
        "✔️ **Reduce el número de llamadas al servidor**.  \n\n"
        "✔️ **Esquema flexible y fácil de extender**.  \n\n"
        "✔️ **Ideal para aplicaciones con múltiples clientes (web, móvil, IoT)**.  \n"
        "\n"
        "❌ **Más complejo de implementar que REST**.  \n\n"
        "❌ **La optimización de consultas puede ser difícil en bases de datos grandes**.  \n\n"
        "❌ **Requiere herramientas adicionales para caching y control de acceso**.  \n"
        "\n"
        "### 📌 6. Conclusión  \n"
        "\n"
        "GraphQL es una excelente alternativa a REST, especialmente cuando se necesita una API **flexible y eficiente**.  \n"
        "\n"
        "🚀 **¿Listo para probar GraphQL en tu próximo proyecto?** 😃\n"

    ),

    (
        "WebSockets",
        "# 🌐 WebSockets en Python con FastAPI  \n"
        "\n"
        "### 📌 1. ¿Qué son los WebSockets?  \n"
        "\n"
        "WebSockets es un *protocolo de comunicación bidireccional en tiempo real* que permite que cliente y servidor intercambien mensajes de manera continua sin necesidad de abrir una nueva conexión en cada mensaje.  \n"
        "\n"
        "🔹 **Diferencias con HTTP:**  \n\n"
        "✔️ En HTTP, cada petición del cliente requiere una nueva conexión.  \n\n"
        "✔️ WebSockets mantienen una conexión abierta, permitiendo *comunicación en tiempo real*.  \n"
        "\n"
        "### 📌 Ejemplos de uso:  \n\n"
        "- Chats en tiempo real.  \n\n"
        "- Juegos multijugador en línea.  \n\n"
        "- Notificaciones en vivo (actualizaciones de mercado, redes sociales).  \n\n"
        "- Aplicaciones de monitoreo en tiempo real.  \n"
        "\n"
        "### 📌 2. Cómo funciona WebSockets  \n"
        "\n"
        "1️⃣ **El cliente inicia la conexión WebSocket** enviando un 'handshake' al servidor.  \n\n"
        "2️⃣ **El servidor acepta la conexión** y mantiene el canal abierto.  \n\n"
        "3️⃣ **Ambos pueden enviar y recibir mensajes en cualquier momento** sin reabrir la conexión.  \n\n"
        "4️⃣ **Cuando termina la sesión, la conexión se cierra**.  \n"
        "\n"
        "### 📌 3. Implementación de WebSockets en Python con FastAPI  \n"
        "\n"
        "FastAPI proporciona soporte nativo para WebSockets con `WebSocket` y `WebSocketRoute`.  \n"
        "\n"
        "**📌 a) Instalación de Dependencias**  \n\n"
        "Si aún no tienes FastAPI y Uvicorn, instálalos con:  \n"
        "```\n\n"
        "pip install fastapi uvicorn\n"
        "```\n"
        "\n"
        "**📌 b) Crear un Servidor WebSocket**  \n"
        "\n"
        "Creamos un archivo main.py con el siguiente código:  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\n"
        "from typing import List\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "# Lista para almacenar conexiones activas\n\n"
        "connected_clients: List[WebSocket] = []\n"
        "\n"
        "# Ruta para WebSockets\n\n"
        "@app.websocket('/ws')\n\n"
        "async def websocket_endpoint(websocket: WebSocket):\n\n"
        "    await websocket.accept()\n\n"
        "    connected_clients.append(websocket)\n\n"
        "    try:\n\n"
        "        while True:\n\n"
        "            message = await websocket.receive_text()\n\n"
        "            for client in connected_clients:\n\n"
        "                await client.send_text(f'Mensaje recibido: {message}')\n\n"
        "    except WebSocketDisconnect:\n\n"
        "        connected_clients.remove(websocket)\n"
        "```\n"
        "\n"
        "**📌 c) Explicación del Código**  \n"
        "\n"
        "1️⃣ **Definimos la ruta `/ws`** → Permite a los clientes conectarse a WebSockets.  \n\n"
        "2️⃣ **El servidor acepta la conexión** con `await websocket.accept()`.  \n\n"
        "3️⃣ **Agregamos el cliente a `connected_clients`** para manejar múltiples conexiones.  \n\n"
        "4️⃣ **Recibimos mensajes con `await websocket.receive_text()`**.  \n\n"
        "5️⃣ **Reenviamos los mensajes a todos los clientes conectados**.  \n\n"
        "6️⃣ **Cuando un cliente se desconecta, lo eliminamos de la lista**.  \n"
        "\n"
        "**📌 d) Probar el Servidor WebSocket**  \n"
        "\n"
        "1️⃣ **Iniciar el servidor**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n\n"
        "2️⃣ **Conectar un cliente WebSocket**  \n\n"
        "Abrimos la consola del navegador y ejecutamos:  \n"
        "\n"
        "```\n\n"
        "const ws = new WebSocket('ws://localhost:8000/ws');\n\n"
        "ws.onmessage = (event) => console.log('Mensaje del servidor:', event.data);\n\n"
        "ws.onopen = () => ws.send('¡Hola, servidor!');\n"
        "```\n\n"
        "3️⃣ **El servidor responderá con:**  \n"
        "```\n\n"
        "Mensaje recibido: ¡Hola, servidor!\n"
        "```\n"
        "\n"
        "### 📌 4. Crear un Chat en Tiempo Real con WebSockets**  \n"
        "\n"
        "Vamos a mejorar nuestro código para admitir **múltiples usuarios en un chat**.  \n"
        "\n"
        "**📌 a) Código del Servidor (`main.py`)**  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\n\n"
        "from typing import List\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "**Manejador de conexiones WebSocket**\n\n"
        "class ConnectionManager:\n\n"
        "    def __init__(self):\n\n"
        "        self.active_connections: List[WebSocket] = []\n"
        "\n"
        "    async def connect(self, websocket: WebSocket):\n\n"
        "        await websocket.accept()\n\n"
        "        self.active_connections.append(websocket)\n"
        "\n"
        "    def disconnect(self, websocket: WebSocket):\n\n"
        "        self.active_connections.remove(websocket)\n"
        "\n"
        "    async def send_message(self, message: str):\n\n"
        "        for connection in self.active_connections:\n\n"
        "            await connection.send_text(message)\n"
        "\n"
        "manager = ConnectionManager()\n"
        "\n"
        "@app.websocket('/ws')\n\n"
        "async def websocket_endpoint(websocket: WebSocket):\n\n"
        "    await manager.connect(websocket)\n\n"
        "    try:\n\n"
        "        while True:\n\n"
        "            message = await websocket.receive_text()\n\n"
        "            await manager.send_message(f'Usuario dice: {message}')\n\n"
        "    except WebSocketDisconnect:\n\n"
        "        manager.disconnect(websocket)\n"
        "```\n"
        "\n"
        "**📌 b) Probar el Chat con Múltiples Clientes**  \n"
        "\n"
        "Abrimos dos pestañas en el navegador y ejecutamos:  \n"
        "\n"
        "```\n\n"
        "const ws1 = new WebSocket('ws://localhost:8000/ws');\n\n"
        "ws1.onmessage = (event) => console.log('Cliente 1:', event.data);\n\n"
        "ws1.onopen = () => ws1.send('¡Hola desde Cliente 1!');\n"
        "\n"
        "const ws2 = new WebSocket('ws://localhost:8000/ws');\n\n"
        "ws2.onmessage = (event) => console.log('Cliente 2:', event.data);\n\n"
        "ws2.onopen = () => ws2.send('¡Hola desde Cliente 2!');\n"
        "```\n"
        "\n"
        "🔹 Ambos clientes recibirán los mensajes enviados en tiempo real.  \n"
        "\n"
        "### 📌 5. Autenticación en WebSockets con Tokens  \n"
        "\n"
        "Si queremos proteger WebSockets con **JWT**, podemos hacerlo enviando el token en la URL.  \n"
        "\n"
        "**📌 a) Código del Servidor con JWT**  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, Query\n\n"
        "import jwt\n"
        "\n"
        "SECRET_KEY = 'mi_secreto'\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "async def verify_token(token: str = Query(...)):\n\n"
        "    try:\n\n"
        "        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n\n"
        "        return payload\n\n"
        "    except jwt.ExpiredSignatureError:\n\n"
        "        return None\n"
        "\n"
        "@app.websocket('/ws')\n\n"
        "async def websocket_endpoint(websocket: WebSocket, user=Depends(verify_token)):\n\n"
        "    if user is None:\n\n"
        "        await websocket.close()\n\n"
        "        return\n\n"
        "    await websocket.accept()\n\n"
        "    while True:\n\n"
        "        message = await websocket.receive_text()\n\n"
        "        await websocket.send_text(f'Usuario {user['sub']} dice: {message}')\n"
        "```\n"
        "\n"
        "**📌 b) Probar la Autenticación**  \n"
        "\n"
        "1️⃣ **Generar un token JWT**  \n"
        "\n"
        "```\n\n"
        "import jwt\n\n"
        "SECRET_KEY = 'mi_secreto'\n\n"
        "token = jwt.encode({'sub': '123'}, SECRET_KEY, algorithm='HS256')\n\n"
        "print(token)\n"
        "```\n"
        "\n"
        "2️⃣ **Conectar el WebSocket con el token**  \n"
        "\n"
        "```\n\n"
        "const ws = new WebSocket('ws://localhost:8000/ws?token=TOKEN_GENERADO');\n\n"
        "ws.onmessage = (event) => console.log(event.data);\n\n"
        "ws.onopen = () => ws.send('¡Mensaje seguro!');\n"
        "```\n"
        "\n"
        "### 📌 6. Ventajas y Desventajas de WebSockets  \n"
        "\n"
        "✔️ **Comunicación en tiempo real** sin necesidad de múltiples peticiones HTTP.  \n\n"
        "✔️ **Reducción del uso de ancho de banda** gracias a la conexión persistente.  \n\n"
        "✔️ **Ideal para chats, juegos y aplicaciones interactivas**.  \n"
        "\n"
        "❌ **No es compatible con todos los firewalls y proxies**.  \n\n"
        "❌ **Requiere manejo manual de conexiones y desconexiones**.  \n\n"
        "❌ **Menos escalable que REST sin WebSocket Gateways** (como Redis o NATS).  \n"
        "\n"
        "### 📌 7. Conclusión  \n"
        "\n"
        "WebSockets en FastAPI permiten construir aplicaciones **en tiempo real** de manera sencilla y eficiente.  \n"
        "\n"
        "🚀 **¿Listo para crear tu propio chat o sistema en vivo con WebSockets?** 😃\n"
    ),

    (
        "postgresql",
        "# 🛢 PostgreSQL en Python: Configuración y Uso con SQLAlchemy  \n"
        "\n"
        "### 📌 1. ¿Qué es PostgreSQL?  \n"
        "\n"
        "PostgreSQL es un **sistema de gestión de bases de datos relacional (RDBMS) de código abierto**. Es conocido por ser potente, escalable y compatible con SQL estándar.  \n"
        "\n"
        "🔹 **Ventajas de PostgreSQL:**  \n\n"
        "✔️ Soporta transacciones ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad).  \n\n"
        "✔️ Manejo avanzado de consultas SQL, incluyendo subconsultas y joins.  \n\n"
        "✔️ Extensiones como PostGIS (para geodatos) y JSONB (para datos semiestructurados).  \n\n"
        "✔️ Excelente soporte para integraciones con múltiples lenguajes, incluyendo Python.  \n"
        "\n"
        "### 📌 2. Instalación y Configuración de PostgreSQL \n"
        "\n"
        "**📌 a) Instalar PostgreSQL**  \n\n"
        "🔹 En Linux (Ubuntu/Debian):  \n"
        "```\n\n"
        "sudo apt update\n\n"
        "sudo apt install postgresql postgresql-contrib\n"
        "```\n"
        "\n"
        "🔹 En macOS (usando Homebrew):  \n"
        "```\n\n"
        "brew install postgresql\n"
        "```\n"
        "\n"
        "🔹 En Windows:  \n\n"
        "Descargar desde [https://www.postgresql.org/download/](https://www.postgresql.org/download/) e instalar con el asistente.\n"
        "\n"
        "**📌 b) Iniciar PostgreSQL**  \n\n"
        "Después de la instalación, podemos iniciar el servicio con:  \n"
        "\n"
        "```\n\n"
        "sudo systemctl start postgresql  # Linux\n\n"
        "brew services start postgresql   # macOS\n"
        "```\n"
        "\n"
        "**📌 c) Crear una Base de Datos y Usuario**  \n\n"
        "Accedemos a PostgreSQL con:  \n"
        "```\n\n"
        "sudo -u postgres psql\n"
        "```\n\n"
        "Creamos un usuario y base de datos:  \n"
        "```\n\n"
        "CREATE DATABASE mi_base_de_datos;\n\n"
        'CREATE USER mi_usuario WITH ENCRYPTED PASSWORD "mi_contraseña";\n\n'
        "GRANT ALL PRIVILEGES ON DATABASE mi_base_de_datos TO mi_usuario;\n"
        "```\n\n"
        "Salimos con \q.\n"
        "\n"
        "### 📌 3. Conectar PostgreSQL con Python  \n"
        "\n"
        "Para conectar PostgreSQL con Python, podemos usar *psycopg2* o *SQLAlchemy*.  \n"
        "\n"
        "**📌 a) Instalar Dependencias**  \n"
        "```\n\n"
        "pip install psycopg2-binary sqlalchemy\n"
        "```\n"
        "\n"
        "**📌 b) Conectar con psycopg2**  \n"
        "```\n\n"
        "import psycopg2\n"
        "\n"
        "# Conexión a PostgreSQL\n\n"
        "conn = psycopg2.connect(\n\n"
        "    dbname='mi_base_de_datos',\n\n"
        "    user='mi_usuario',\n\n"
        "    password='mi_contraseña',\n\n"
        "    host='localhost',\n\n"
        "    port='5432'\n\n"
        ")\n"
        "\n"
        "# Crear un cursor para ejecutar consultas\n\n"
        "cursor = conn.cursor()\n"
        "\n"
        "# Crear una tabla\n\n"
        'cursor.execute( """\n\n'
        "    CREATE TABLE IF NOT EXISTS usuarios (\n\n"
        "        id SERIAL PRIMARY KEY,\n\n"
        "        nombre VARCHAR(100),\n\n"
        "        edad INT\n\n"
        ' """   );\n\n'
        ")\n"
        "\n"
        "# Insertar datos\n\n"
        "cursor.execute('INSERT INTO usuarios (nombre, edad) VALUES (%s, %s)', ('Juan', 25))\n"
        "\n"
        "# Confirmar cambios\n\n"
        "conn.commit()\n"
        "\n"
        "# Consultar datos\n\n"
        "cursor.execute('SELECT * FROM usuarios;')\n\n"
        "usuarios = cursor.fetchall()\n\n"
        "print(usuarios)\n"
        "\n"
        "# Cerrar conexión\n\n"
        "cursor.close()\n\n"
        "conn.close()\n"
        "```\n"
        "\n"
        "🔹 **Explicación:**  \n\n"
        "✔️ Conectamos a la base de datos con psycopg2.connect().  \n\n"
        "✔️ Creamos un cursor para ejecutar comandos SQL.  \n\n"
        "✔️ Insertamos y consultamos datos.  \n\n"
        "✔️ Cerramos la conexión al final.  \n"
        "\n"
        "### 📌 4. Uso de PostgreSQL con SQLAlchemy  \n"
        "\n"
        "SQLAlchemy es un ORM (Object Relational Mapper) que permite trabajar con bases de datos de manera más estructurada usando objetos de Python.  \n"
        "\n"
        "**📌 a) Instalar SQLAlchemy y el Driver de PostgreSQL**  \n"
        "```\n\n"
        "pip install sqlalchemy psycopg2-binary\n"
        "```\n"
        "\n"
        "**📌 b) Configurar SQLAlchemy para PostgreSQL**  \n"
        "```\n\n"
        "from sqlalchemy import create_engine, Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "\n"
        "# Configurar la conexión con PostgreSQL\n\n"
        "DATABASE_URL = 'postgresql://mi_usuario:mi_contraseña@localhost/mi_base_de_datos'\n"
        "\n"
        "# Crear el motor de conexión\n\n"
        "engine = create_engine(DATABASE_URL)\n"
        "\n"
        "# Crear la sesión\n\n"
        "SessionLocal = sessionmaker(bind=engine)\n\n"
        "session = SessionLocal()\n"
        "\n"
        "# Definir la base\n\n"
        "Base = declarative_base()\n"
        "\n"
        "# Definir el modelo Usuario\n\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    edad = Column(Integer)\n"
        "\n"
        "# Crear las tablas en la base de datos\n\n"
        "Base.metadata.create_all(bind=engine)\n"
        "\n"
        "# Insertar un usuario\n\n"
        "nuevo_usuario = Usuario(nombre='Carlos', edad=30)\n\n"
        "session.add(nuevo_usuario)\n\n"
        "session.commit()\n"
        "\n"
        "# Consultar usuarios\n\n"
        "usuarios = session.query(Usuario).all()\n\n"
        "for usuario in usuarios:\n\n"
        "    print(usuario.id, usuario.nombre, usuario.edad)\n"
        "\n"
        "# Cerrar la sesión\n\n"
        "session.close()\n"
        "```\n"
        "\n"
        "### 📌 5. Integración con FastAPI  \n"
        "\n"
        "Podemos combinar PostgreSQL, SQLAlchemy y FastAPI para crear una API con una base de datos.  \n"
        "\n"
        "**📌 a) Instalar Dependencias**  \n"
        "```\n\n"
        "pip install fastapi uvicorn psycopg2 sqlalchemy\n"
        "```\n"
        "\n"
        "**📌 b) Crear el Servidor API**  \n\n"
        "Creamos `main.py` con la API:  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI, Depends\n\n"
        "from sqlalchemy import create_engine, Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n\n"
        "from sqlalchemy.orm import sessionmaker, Session\n"
        "\n"
        "# Configuración de PostgreSQL\n\n"
        "DATABASE_URL = 'postgresql://mi_usuario:mi_contraseña@localhost/mi_base_de_datos'\n\n"
        "engine = create_engine(DATABASE_URL)\n\n"
        "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n"
        "Base = declarative_base()\n"
        "\n"
        "# Definir el modelo Usuario\n\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, index=True)\n\n"
        "    nombre = Column(String, index=True)\n\n"
        "    edad = Column(Integer)\n"
        "\n"
        "# Crear la base de datos\n\n"
        "Base.metadata.create_all(bind=engine)\n"
        "\n"
        "# Crear la aplicación FastAPI\n\n"
        "app = FastAPI()\n"
        "\n"
        "# Dependencia para la sesión de base de datos\n\n"
        "def get_db():\n\n"
        "    db = SessionLocal()\n\n"
        "    try:\n\n"
        "        yield db\n\n"
        "    finally:\n\n"
        "        db.close()\n"
        "\n"
        "# Ruta para obtener todos los usuarios\n\n"
        "@app.get('/usuarios/')\n\n"
        "def leer_usuarios(db: Session = Depends(get_db)):\n\n"
        "    return db.query(Usuario).all()\n"
        "\n"
        "# Ruta para agregar un usuario\n\n"
        "@app.post('/usuarios/')\n\n"
        "def crear_usuario(nombre: str, edad: int, db: Session = Depends(get_db)):\n\n"
        "    usuario = Usuario(nombre=nombre, edad=edad)\n\n"
        "    db.add(usuario)\n\n"
        "    db.commit()\n\n"
        "    db.refresh(usuario)\n\n"
        "    return usuario\n"
        "```\n"
        "\n"
        "### 📌 6. Probar la API con PostgreSQL  \n"
        "\n"
        "1️⃣ **Ejecutar el servidor**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n"
        "\n"
        "2️⃣ **Agregar un usuario (POST request)**  \n"
        "```\n\n"
        "POST http://localhost:8000/usuarios/\n\n"
        "{\n\n"
        "  'nombre': 'Ana',\n\n"
        "  'edad': 28\n\n"
        "}\n"
        "```\n"
        "\n"
        "3️⃣ **Consultar usuarios (GET request)**  \n"
        "```\n\n"
        "GET http://localhost:8000/usuarios/\n"
        "```\n"
        "\n"
        "🔹 La API responde con la lista de usuarios almacenados en PostgreSQL.  \n"
        "\n"
        "### 📌 7. Conclusión \n"
        "\n"
        "✔️ PostgreSQL es una base de datos potente y escalable.  \n\n"
        "✔️ Puede usarse en Python con *psycopg2* para consultas directas o *SQLAlchemy* para un ORM más flexible.  \n\n"
        "✔️ Se integra fácilmente con *FastAPI* para crear APIs rápidas y eficientes.  \n"
        "\n"
        "🚀 **¡Listo para construir aplicaciones con PostgreSQL y Python!** 😃\n"
    ),

    (
        "mysql",
        "# 📌 MySQL en Python: Instalación, Conexión y CRUD con SQLAlchemy  \n"
        "\n"
        "### 1. ¿Qué es MySQL?  \n\n"
        "MySQL es un **sistema de gestión de bases de datos relacional (RDBMS)** de código abierto, ampliamente utilizado en aplicaciones web y sistemas empresariales.  \n"
        "\n"
        "✔️ **Ventajas:**  \n\n"
        "✅ Rápido y eficiente en lecturas.  \n\n"
        "✅ Ampliamente soportado por hosting y cloud services.  \n\n"
        "✅ Compatible con SQL estándar.  \n\n"
        "✅ Se integra fácilmente con Python y frameworks como Django o Flask.  \n"
        "\n"
        "### 2. Instalación y Configuración de MySQL  \n"
        "\n"
        "**📌 a) Instalar MySQL**  \n"
        "\n"
        "🔹 **En Linux (Ubuntu/Debian):**  \n"
        "```\n\n"
        "sudo apt update\n\n"
        "sudo apt install mysql-server\n"
        "```\n"
        "\n"
        "🔹 **En macOS (Homebrew):**  \n"
        "```\n\n"
        "brew install mysql\n\n"
        "brew services start mysql\n"
        "```\n"
        "\n"
        "🔹 **En Windows:**  \n\n"
        "Descargar e instalar desde [https://dev.mysql.com/downloads/](https://dev.mysql.com/downloads/).  \n"
        "\n"
        "**📌 b) Crear una Base de Datos y Usuario**  \n"
        "\n"
        "Para entrar a MySQL:  \n"
        "```\n\n"
        "mysql -u root -p\n"
        "```\n"
        "\n"
        "Crear base de datos y usuario:  \n"
        "```\n\n"
        "CREATE DATABASE mi_base_de_datos;\n\n"
        'CREATE USER "mi_usuario"@"localhost" IDENTIFIED BY "mi_contraseña";\n\n'
        'GRANT ALL PRIVILEGES ON mi_base_de_datos.* TO "mi_usuario"@"localhost";\n\n'
        "FLUSH PRIVILEGES;\n"
        "```\n"
        "\n"
        "Salimos con `EXIT;`.\n"
        "\n"
        "### 3. Conectar MySQL con Python  \n"
        "\n"
        "Podemos usar **MySQL Connector** o **SQLAlchemy** como ORM.  \n"
        "\n"
        "**📌 a) Instalar Dependencias**  \n"
        "```\n\n"
        "pip install mysql-connector-python sqlalchemy\n"
        "```\n"
        "\n"
        "**📌 b) Conectar con `mysql-connector-python`**  \n"
        "```\n\n"
        "import mysql.connector\n"
        "\n"
        "# Conexión a MySQL\n\n"
        "conn = mysql.connector.connect(\n\n"
        "    host='localhost',\n\n"
        "    user='mi_usuario',\n\n"
        "    password='mi_contraseña',\n\n"
        "    database='mi_base_de_datos'\n\n"
        ")\n"
        "\n"
        "cursor = conn.cursor()\n"
        "\n"
        "# Crear una tabla\n\n"
        'cursor.execute("""\n\n'
        "    CREATE TABLE IF NOT EXISTS usuarios (\n\n"
        "        id INT AUTO_INCREMENT PRIMARY KEY,\n\n"
        "        nombre VARCHAR(100),\n\n"
        "        edad INT\n\n"
        "    );\n\n"
        '""")\n'
        "\n"
        "# Insertar datos\n\n"
        "cursor.execute('INSERT INTO usuarios (nombre, edad) VALUES (%s, %s)', ('Juan', 25))\n"
        "\n"
        "# Confirmar cambios\n\n"
        "conn.commit()\n"
        "\n"
        "# Consultar datos\n\n"
        "cursor.execute('SELECT * FROM usuarios;')\n\n"
        "usuarios = cursor.fetchall()\n\n"
        "print(usuarios)\n"
        "\n"
        "# Cerrar conexión\n\n"
        "cursor.close()\n\n"
        "conn.close()\n"
        "```\n"
        "\n"
        "### 4. CRUD con SQLAlchemy en MySQL  \n"
        "\n"
        "SQLAlchemy nos permite manejar bases de datos de forma más estructurada con objetos de Python.  \n"
        "\n"
        "**📌 a) Configurar SQLAlchemy para MySQL**  \n"
        "```\n\n"
        "from sqlalchemy import create_engine, Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "\n"
        "# Configuración de MySQL\n\n"
        "DATABASE_URL = 'mysql+mysqlconnector://mi_usuario:mi_contraseña@localhost/mi_base_de_datos'\n"
        "\n"
        "# Crear el motor de conexión\n\n"
        "engine = create_engine(DATABASE_URL)\n"
        "\n"
        "# Crear la sesión\n\n"
        "SessionLocal = sessionmaker(bind=engine)\n\n"
        "session = SessionLocal()\n"
        "\n"
        "# Definir la base\n\n"
        "Base = declarative_base()\n"
        "\n"
        "# Modelo Usuario\n\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, autoincrement=True)\n\n"
        "    nombre = Column(String(100))\n\n"
        "    edad = Column(Integer)\n"
        "\n"
        "# Crear las tablas en la base de datos\n\n"
        "Base.metadata.create_all(bind=engine)\n"
        "```\n"
        "\n"
        "### 5. Implementar CRUD en Python  \n"
        "\n"
        "**📌 a) Crear Usuario (CREATE)**  \n"
        "```\n\n"
        "def crear_usuario(nombre: str, edad: int):\n\n"
        "    nuevo_usuario = Usuario(nombre=nombre, edad=edad)\n\n"
        "    session.add(nuevo_usuario)\n\n"
        "    session.commit()\n\n"
        "    session.refresh(nuevo_usuario)\n\n"
        "    return nuevo_usuario\n"
        "\n"
        "# Insertar un usuario\n\n"
        "usuario = crear_usuario('Carlos', 30)\n\n"
        "print(f'Usuario creado: {usuario.id} - {usuario.nombre} - {usuario.edad}')\n"
        "```\n"
        "\n"
        "**📌 b) Leer Usuarios (READ)**  \n"
        "```\n\n"
        "def obtener_usuarios():\n\n"
        "    return session.query(Usuario).all()\n"
        "\n"
        "usuarios = obtener_usuarios()\n\n"
        "for u in usuarios:\n\n"
        "    print(f'{u.id}: {u.nombre}, {u.edad} años')\n"
        "```\n"
        "\n"
        "**📌 c) Actualizar Usuario (UPDATE)**  \n"
        "```\n\n"
        "def actualizar_usuario(user_id: int, nuevo_nombre: str, nueva_edad: int):\n\n"
        "    usuario = session.query(Usuario).filter(Usuario.id == user_id).first()\n\n"
        "    if usuario:\n\n"
        "        usuario.nombre = nuevo_nombre\n\n"
        "        usuario.edad = nueva_edad\n\n"
        "        session.commit()\n\n"
        "        return usuario\n\n"
        "    return None\n"
        "\n"
        "usuario_actualizado = actualizar_usuario(1, 'Carlos Pérez', 35)\n\n"
        "if usuario_actualizado:\n\n"
        "    print(f'Usuario actualizado: {usuario_actualizado.id} - {usuario_actualizado.nombre} - {usuario_actualizado.edad}')\n"
        "```\n"
        "\n"
        "**📌 d) Eliminar Usuario (DELETE)**  \n"
        "```\n\n"
        "def eliminar_usuario(user_id: int):\n\n"
        "    usuario = session.query(Usuario).filter(Usuario.id == user_id).first()\n\n"
        "    if usuario:\n\n"
        "        session.delete(usuario)\n\n"
        "        session.commit()\n\n"
        "        print(f'Usuario con ID {user_id} eliminado')\n\n"
        "    else:\n\n"
        "        print(f'Usuario con ID {user_id} no encontrado')\n"
        "\n"
        "eliminar_usuario(1)\n"
        "```\n"
        "\n"
        "### 6. Crear una API CRUD con FastAPI y MySQL  \n"
        "\n"
        "Podemos combinar MySQL con **FastAPI** para exponer un API con endpoints CRUD.  \n"
        "\n"
        "**📌 a) Instalar FastAPI y Uvicorn**  \n"
        "```\n\n"
        "pip install fastapi uvicorn\n"
        "```\n"
        "\n"
        "**📌 b) Crear main.py con el CRUD**  \n"
        "```\n\n"
        "from fastapi import FastAPI, Depends\n\n"
        "from sqlalchemy.orm import Session\n\n"
        "from sqlalchemy import create_engine, Column, Integer, String\n\n"
        "from sqlalchemy.ext.declarative import declarative_base\n\n"
        "from sqlalchemy.orm import sessionmaker\n"
        "\n"
        "# Configurar MySQL\n\n"
        "DATABASE_URL = 'mysql+mysqlconnector://mi_usuario:mi_contraseña@localhost/mi_base_de_datos'\n\n"
        "engine = create_engine(DATABASE_URL)\n\n"
        "SessionLocal = sessionmaker(bind=engine)\n\n"
        "Base = declarative_base()\n"
        "\n"
        "# Definir el modelo Usuario\n\n"
        "class Usuario(Base):\n\n"
        "    __tablename__ = 'usuarios'\n"
        "\n"
        "    id = Column(Integer, primary_key=True, autoincrement=True)\n\n"
        "    nombre = Column(String(100))\n\n"
        "    edad = Column(Integer)\n"
        "\n"
        "# Crear tablas en la base de datos\n\n"
        "Base.metadata.create_all(bind=engine)\n"
        "\n"
        "# Instancia de FastAPI\n\n"
        "app = FastAPI()\n"
        "\n"
        "# Dependencia de sesión de BD\n\n"
        "def get_db():\n\n"
        "    db = SessionLocal()\n\n"
        "    try:\n\n"
        "        yield db\n\n"
        "    finally:\n\n"
        "        db.close()\n"
        "\n"
        "# 📌 Obtener todos los usuarios\n\n"
        "@app.get('/usuarios/')\n\n"
        "def leer_usuarios(db: Session = Depends(get_db)):\n\n"
        "    return db.query(Usuario).all()\n"
        "\n"
        "# 📌 Crear usuario\n\n"
        "@app.post('/usuarios/')\n\n"
        "def crear_usuario(nombre: str, edad: int, db: Session = Depends(get_db)):\n\n"
        "    usuario = Usuario(nombre=nombre, edad=edad)\n\n"
        "    db.add(usuario)\n\n"
        "    db.commit()\n\n"
        "    db.refresh(usuario)\n\n"
        "    return usuario\n"
        "\n"
        "# 📌 Actualizar usuario\n\n"
        "@app.put('/usuarios/{user_id}')\n\n"
        "def actualizar_usuario(user_id: int, nombre: str, edad: int, db: Session = Depends(get_db)):\n\n"
        "    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()\n\n"
        "    if usuario:\n\n"
        "        usuario.nombre = nombre\n\n"
        "        usuario.edad = edad\n\n"
        "        db.commit()\n\n"
        "        return usuario\n\n"
        "    return {'error': 'Usuario no encontrado'}\n"
        "\n"
        "# 📌 Eliminar usuario\n\n"
        "@app.delete('/usuarios/{user_id}')\n\n"
        "def eliminar_usuario(user_id: int, db: Session = Depends(get_db)):\n\n"
        "    usuario = db.query(Usuario).filter(Usuario.id == user_id).first()\n\n"
        "    if usuario:\n\n"
        "        db.delete(usuario)\n\n"
        "        db.commit()\n\n"
        "        return {'mensaje': 'Usuario eliminado'}\n\n"
        "    return {'error': 'Usuario no encontrado'}\n"
        "```\n"
        "\n"
        "### 7. Probar la API  \n"
        "\n"
        "🔹 **Ejecutar el servidor:**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n"
        "\n"
        "🔹 **Probar CRUD con Postman o navegador:**  \n\n"
        "- `GET http://localhost:8000/usuarios/`\n\n"
        "- `POST http://localhost:8000/usuarios/` (con JSON `{'nombre': 'Ana', 'edad': 25}`)\n\n"
        "- `PUT http://localhost:8000/usuarios/1`\n\n"
        "- `DELETE http://localhost:8000/usuarios/1`\n"
        "\n"
        "### 📌 Conclusión  \n\n"
        "✔️ MySQL es una base de datos robusta y compatible con Python.  \n\n"
        "✔️ Se puede usar con mysql-connector-python o **SQLAlchemy ORM**.  \n\n"
        "✔️ Se integra fácilmente con **FastAPI** para crear APIs CRUD eficientes.  \n"
        "\n"
        "🚀 **¡Listo para construir aplicaciones con MySQL y Python!** 😃\n"
    ),

    (
        "mongodb",
        "# 📌 MongoDB en Python: Explicación, Ventajas y CRUD con Python  \n"
        "\n"
        "### 1. ¿Qué es MongoDB?  \n\n"
        "MongoDB es una *base de datos NoSQL* orientada a documentos, diseñada para manejar grandes volúmenes de datos con alta flexibilidad. En lugar de almacenar datos en filas y columnas (como MySQL o PostgreSQL), *usa documentos JSON (BSON)*, lo que permite almacenar estructuras anidadas dinámicamente.\n"
        "\n"
        "### 2. ¿Por qué usar MongoDB?  \n"
        "\n"
        "✔️ **Ventajas:**  \n\n"
        "✅ **Flexible:** No requiere esquemas fijos, permite agregar o eliminar campos sin problemas.  \n\n"
        "✅ **Escalable:** Maneja grandes volúmenes de datos distribuidos.  \n\n"
        "✅ **Alta disponibilidad:** Usa replicación y particionamiento automático.  \n\n"
        "✅ **Rápido en lecturas y escrituras:** Ideal para Big Data y aplicaciones en tiempo real.  \n"
        "\n"
        "❌ **Desventajas:**  \n\n"
        "❌ No soporta **transacciones ACID** tan bien como bases de datos SQL.  \n\n"
        "❌ El consumo de almacenamiento es mayor que en SQL debido a la redundancia de datos en documentos BSON.  \n"
        "\n"
        "### 3. Instalación y Configuración de MongoDB  \n"
        "\n"
        "**📌 a) Instalar MongoDB**  \n"
        "\n"
        "🔹 **En Linux (Ubuntu/Debian):**  \n"
        "```\n\n"
        "sudo apt update\n\n"
        "sudo apt install mongodb\n\n"
        "sudo systemctl start mongodb\n\n"
        "sudo systemctl enable mongodb\n"
        "```\n"
        "\n"
        "🔹 **En macOS (Homebrew):**  \n"
        "```\n\n"
        "brew tap mongodb/brew\n\n"
        "brew install mongodb-community\n\n"
        "brew services start mongodb-community\n"
        "```\n"
        "\n"
        "🔹 **En Windows:**  \n\n"
        "Descargar e instalar desde [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).  \n"
        "\n"
        "### 4. Conectar Python con MongoDB  \n"
        "\n"
        "MongoDB tiene un driver oficial para Python llamado **pymongo**.\n"
        "\n"
        "**📌 a) Instalar pymongo**  \n"
        "```\n\n"
        "pip install pymongo\n"
        "```\n"
        "\n"
        "**📌 b) Conectar MongoDB con Python**  \n"
        "```\n\n"
        "from pymongo import MongoClient\n"
        "\n"
        "# Conexión a MongoDB\n\n"
        "client = MongoClient('mongodb://localhost:27017/')\n"
        "\n"
        "# Seleccionar la base de datos\n\n"
        "db = client['mi_base_de_datos']\n"
        "\n"
        "# Crear una colección (tabla en SQL)\n\n"
        "usuarios = db['usuarios']\n"
        "```\n"
        "\n"
        "### 5. CRUD en MongoDB con Python  \n"
        "\n"
        "**📌 a) Crear (CREATE)**  \n"
        "```\n\n"
        "def crear_usuario(nombre, edad, email):\n\n"
        "    usuario = {'nombre': nombre, 'edad': edad, 'email': email}\n\n"
        "    usuarios.insert_one(usuario)\n\n"
        "    print(f'Usuario {nombre} creado correctamente.')\n"
        "\n"
        "# Insertar usuario\n\n"
        "crear_usuario('Juan', 25, 'juan@example.com')\n"
        "```\n"
        "\n"
        "**📌 b) Leer (READ)**  \n"
        "```\n\n"
        "def obtener_usuarios():\n\n"
        "    return list(usuarios.find())\n"
        "\n"
        "# Consultar usuarios\n\n"
        "for usuario in obtener_usuarios():\n\n"
        "    print(usuario)\n"
        "```\n"
        "\n"
        "**📌 c) Actualizar (UPDATE)**  \n"
        "```\n\n"
        "def actualizar_usuario(nombre, nueva_edad):\n\n"
        "    usuarios.update_one({'nombre': nombre}, {'$set': {'edad': nueva_edad}})\n\n"
        "    print(f'Usuario {nombre} actualizado correctamente.')\n"
        "\n"
        "# Actualizar usuario\n\n"
        "actualizar_usuario('Juan', 30)\n"
        "```\n"
        "\n"
        "**📌 d) Eliminar (DELETE)**  \n"
        "```\n\n"
        "def eliminar_usuario(nombre):\n\n"
        "    usuarios.delete_one({'nombre': nombre})\n\n"
        "    print(f'Usuario {nombre} eliminado.')\n"
        "\n"
        "# Eliminar usuario\n\n"
        "eliminar_usuario('Juan')\n"
        "```\n"
        "\n"
        "### 6. Integrar MongoDB con FastAPI para crear una API CRUD  \n"
        "\n"
        "MongoDB se puede combinar con **FastAPI** para exponer endpoints RESTful.\n"
        "\n"
        "**📌 a) Instalar FastAPI y Uvicorn**  \n"
        "```\n\n"
        "pip install fastapi uvicorn\n"
        "```\n"
        "\n"
        "**📌 b) Crear `main.py` con FastAPI y MongoDB**  \n"
        "```\n\n"
        "from fastapi import FastAPI\n\n"
        "from pymongo import MongoClient\n\n"
        "from pydantic import BaseModel\n"
        "\n"
        "# Conexión a MongoDB\n\n"
        "client = MongoClient('mongodb://localhost:27017/')\n\n"
        "db = client['mi_base_de_datos']\n\n"
        "usuarios = db['usuarios']\n"
        "\n"
        "# Definir la app FastAPI\n\n"
        "app = FastAPI()\n"
        "\n"
        "# Modelo de usuario\n\n"
        "class Usuario(BaseModel):\n\n"
        "    nombre: str\n\n"
        "    edad: int\n\n"
        "    email: str\n"
        "\n"
        "# 📌 Crear usuario\n\n"
        "@app.post('/usuarios/')\n\n"
        "def crear_usuario(usuario: Usuario):\n\n"
        "    usuario_dict = usuario.dict()\n\n"
        "    usuarios.insert_one(usuario_dict)\n\n"
        "    return {'mensaje': 'Usuario creado', 'usuario': usuario_dict}\n"
        "\n"
        "# 📌 Obtener usuarios\n\n"
        "@app.get('/usuarios/')\n\n"
        "def obtener_usuarios():\n\n"
        "    return list(usuarios.find({}, {'_id': 0}))\n"
        "\n"
        "# 📌 Actualizar usuario\n\n"
        "@app.put('/usuarios/{nombre}')\n\n"
        "def actualizar_usuario(nombre: str, edad: int):\n\n"
        "    resultado = usuarios.update_one({'nombre': nombre}, {'$set': {'edad': edad}})\n\n"
        "    if resultado.matched_count:\n\n"
        "        return {'mensaje': 'Usuario actualizado'}\n\n"
        "    return {'error': 'Usuario no encontrado'}\n"
        "\n"
        "# 📌 Eliminar usuario\n\n"
        "@app.delete('/usuarios/{nombre}')\n\n"
        "def eliminar_usuario(nombre: str):\n\n"
        "    resultado = usuarios.delete_one({'nombre': nombre})\n\n"
        "    if resultado.deleted_count:\n\n"
        "        return {'mensaje': 'Usuario eliminado'}\n\n"
        "    return {'error': 'Usuario no encontrado'}\n"
        "```\n"
        "\n"
        "### 7. Probar la API  \n"
        "\n"
        "🔹 **Ejecutar el servidor:**  \n"
        "```\n\n"
        "uvicorn main:app --reload\n"
        "```\n"
        "\n"
        "🔹 **Probar CRUD con Postman o navegador:**  \n\n"
        "- GET http://localhost:8000/usuarios/\n\n"
        "- POST http://localhost:8000/usuarios/ (con JSON {'nombre': 'Ana', 'edad': 25, 'email': 'ana@example.com'})\n\n"
        "- PUT http://localhost:8000/usuarios/Ana?edad=30\n\n"
        "- DELETE http://localhost:8000/usuarios/Ana\n"
        "\n"
        "## **📌 Conclusión**  \n\n"
        "✔️ MongoDB es ideal para datos flexibles y escalables.  \n\n"
        "✔️ Se integra con Python usando pymongo y se adapta bien a *FastAPI*.  \n\n"
        "✔️ *CRUD con MongoDB es más dinámico* que en SQL gracias a su estructura flexible.  \n"
        "\n"
        "🚀 **¡Ahora puedes manejar MongoDB como un pro!** 😃\n"
    ),

    (
        "redis",
        "# 📌 Redis en Python: Caché y Pub/Sub  \n"
        "\n"
        "### 1. ¿Qué es Redis?  \n\n"
        "Redis (**Remote Dictionary Server**) es una *base de datos en memoria* extremadamente rápida, utilizada principalmente como *caché*, sistema de *mensajería* (pub/sub) y almacenamiento de datos en estructuras clave-valor.  \n"
        "\n"
        "🔹 **Características principales:**  \n\n"
        "✅ **Alta velocidad:** Almacena datos en RAM, lo que lo hace mucho más rápido que las bases de datos tradicionales.  \n\n"
        "✅ **Soporte para estructuras de datos avanzadas:** Listas, sets, hashes, contadores, etc.  \n\n"
        "✅ **Persistencia opcional:** Puede guardar datos en disco si se necesita durabilidad.  \n\n"
        "✅ **Mensajería en tiempo real (Pub/Sub):** Permite la comunicación eficiente entre procesos.  \n\n"
        "✅ **Escalabilidad:** Puede distribuirse en clústeres.  \n"
        "\n"
        "### 2. Instalación de Redis  \n"
        "\n"
        "🔹 **En Linux (Ubuntu/Debian):**  \n"
        "```\n\n"
        "sudo apt update\n\n"
        "sudo apt install redis\n\n"
        "sudo systemctl start redis\n\n"
        "sudo systemctl enable redis\n"
        "```\n"
        "\n"
        "🔹 **En macOS (Homebrew):**  \n"
        "```\n\n"
        "brew install redis\n\n"
        "brew services start redis\n"
        "```\n"
        "\n"
        "🔹 **En Windows:**  \n\n"
        "Redis no tiene soporte oficial, pero se puede instalar con Docker:  \n"
        "```\n\n"
        "docker run --name redis -p 6379:6379 -d redis\n"
        "```\n"
        "\n"
        "Para probar si Redis está funcionando, ejecuta:  \n"
        "```\n\n"
        "redis-cli ping\n"
        "```\n\n"
        "Si devuelve PONG, ¡Redis está funcionando! 🎉  \n"
        "\n"
        "### 3. Conectar Python con Redis  \n"
        "\n"
        "Python usa la biblioteca redis-py para interactuar con Redis.  \n"
        "\n"
        "🔹 **Instalar Redis en Python:**  \n"
        "```\n\n"
        "pip install redis\n"
        "```\n"
        "\n"
        "🔹 **Conectar a Redis en Python:**  \n"
        "```\n\n"
        "import redis\n"
        "\n"
        "# Conectar a Redis en localhost y puerto 6379\n\n"
        'redis_client = redis.Redis(host="localhost", port=6379, decode_responses=True)\n'
        "\n"
        "# Verificar conexión\n\n"
        "if redis_client.ping():\n\n"
        "    print('✅ Conectado a Redis')\n"
        "```\n"
        "\n"
        "### 4. Uso de Redis como Caché  \n"
        "\n"
        "Redis es ideal para *almacenar datos temporales* y reducir la carga en bases de datos tradicionales.  \n"
        "\n"
        "🔹 **Ejemplo: Guardar y obtener valores en Redis**  \n"
        "```\n\n"
        "# Guardar un valor en Redis con una expiración de 10 segundos\n\n"
        "redis_client.set('usuario:1', 'Juan Pérez', ex=10)\n"
        "\n"
        "# Obtener el valor almacenado\n\n"
        "usuario = redis_client.get('usuario:1')\n\n"
        "print(f'👤 Usuario obtenido: {usuario}')\n"
        "```\n\n"
        "Aquí, Redis guarda usuario:1 con valor 'Juan Pérez' durante 10 segundos. Pasado ese tiempo, se elimina automáticamente.\n"
        "\n"
        "**📌 Uso de Redis como contador  \n"
        "```\n\n"
        "# Incrementar contador\n\n"
        "redis_client.incr('contador')\n\n"
        "contador_actual = redis_client.get('contador')\n\n"
        "print(f'📊 Contador: {contador_actual}')\n"
        "```\n\n"
        "Redis es ideal para métricas y estadísticas en tiempo real.\n"
        "\n"
        "### 5. Pub/Sub en Redis  \n"
        "\n"
        "Redis permite *mensajería en tiempo real* con un sistema de *publicación/suscripción (Pub/Sub)*.  \n"
        "\n"
        "**📌 Ejemplo: Publicador (Publisher)**\n"
        "```\n\n"
        "import redis\n"
        "\n"
        'redis_client = redis.Redis(host="localhost", port=6379, decode_responses=True)\n'
        "\n"
        "# Publicar un mensaje en un canal\n\n"
        "redis_client.publish('notificaciones', 'Nuevo usuario registrado: Juan Pérez')\n"
        "```\n"
        "\n"
        "**📌 Ejemplo: Suscriptor (Subscriber)**  \n"
        "```\n\n"
        "import redis\n"
        "\n"
        'redis_client = redis.Redis(host="localhost", port=6379, decode_responses=True)\n\n'
        "pubsub = redis_client.pubsub()\n"
        "\n"
        "# Suscribirse a un canal\n\n"
        "pubsub.subscribe('notificaciones')\n"
        "\n"
        "print('🔔 Esperando mensajes...')\n\n"
        "for mensaje in pubsub.listen():\n\n"
        "    if mensaje['type'] == 'message':\n\n"
        "        print(f'📩 Nuevo mensaje: {mensaje['data']}')\n"
        "```\n"
        "\n"
        "🔹 Aquí, cualquier cliente que esté suscrito a 'notificaciones' recibirá el mensaje en tiempo real.  \n\n"
        "🔹 **Útil para:** notificaciones en vivo, chats, eventos en tiempo real.  \n"
        "\n"
        "### 6. Integración de Redis con FastAPI para caché  \n"
        "\n"
        "Redis es ideal para mejorar el rendimiento de **APIs con FastAPI**.  \n"
        "\n"
        "🔹 **Ejemplo: Cachear respuestas de una API con Redis y FastAPI**  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI\n\n"
        "import redis\n\n"
        "import time\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "# Conectar a Redis\n\n"
        'redis_client = redis.Redis(host="localhost", port=6379, decode_responses=True)\n'
        "\n"
        "@app.get('/datos/{clave}')\n\n"
        "def obtener_datos(clave: str):\n\n"
        "    # Verificar si el dato ya está en caché\n\n"
        "    if (valor := redis_client.get(clave)) is not None:\n\n"
        "        return {'dato': valor, 'cache': True}\n"
        "\n"
        "    # Simular consulta a base de datos\n\n"
        "    time.sleep(2)  # Simula un tiempo de respuesta lento\n\n"
        "    valor = f'Valor calculado para {clave}'\n"
        "\n"
        "    # Guardar en caché por 30 segundos\n\n"
        "    redis_client.set(clave, valor, ex=30)\n"
        "    \n"
        "    return {'dato': valor, 'cache': False}\n"
        "```\n"
        "\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- Se consulta primero Redis. Si el valor está almacenado, se devuelve al instante.  \n\n"
        "- Si no está en caché, la API genera el valor, lo guarda en Redis y lo devuelve.  \n\n"
        "- La próxima vez que se consulte, Redis responderá en **milisegundos**.  \n"
        "\n"
        "### 7. Conclusión  \n"
        "\n"
        "✔️ **Redis es ideal para caché, contadores, pub/sub y optimización de APIs.**  \n\n"
        "✔️ **Se integra fácilmente con Python** mediante redis-py.  \n\n"
        "✔️ **Mejora el rendimiento de aplicaciones** reduciendo consultas a bases de datos tradicionales.  \n\n"
        "✔️ **Pub/Sub es perfecto para sistemas de mensajería en tiempo real.**  \n"
        "\n"
        "🚀 **¡Ahora puedes usar Redis como un experto!** 😃\n"
    ),

    (
        "conexiones asincronas",
        "# 📌 Conexiones Asíncronas en Python  \n"
        "\n"
        "### 1. ¿Qué es una Conexión Asíncrona? \n\n"
        "Una conexión *asíncrona* es aquella en la que una operación no bloquea la ejecución del programa mientras espera una respuesta. En otras palabras, el programa puede seguir ejecutando otras tareas en lugar de quedar 'congelado' esperando un resultado.  \n"
        "\n"
        "Este modelo se basa en la *programación concurrente*, lo que mejora el rendimiento en situaciones donde hay múltiples operaciones de entrada/salida (I/O), como:  \n\n"
        "✅ **Conexiones a bases de datos**  \n\n"
        "✅ **Peticiones HTTP**  \n\n"
        "✅ **Operaciones de lectura/escritura en archivos**  \n\n"
        "✅ **WebSockets y streaming de datos**  \n"
        "\n"
        "### 2. ¿Síncrono vs Asíncrono?  \n"
        "\n"
        "🔹 **Código síncrono (bloqueante)**  \n"
        "```\n\n"
        "import time\n"
        "\n"
        "def tarea():\n\n"
        "    print('⏳ Ejecutando tarea...')\n\n"
        "    time.sleep(3)  # Simula una espera de 3 segundos\n\n"
        "    print('✅ Tarea completada')\n"
        "\n"
        "tarea()\n\n"
        "print('🎉 Fin del programa')\n"
        "```\n\n"
        "**Salida:**  \n"
        "```\n\n"
        "⏳ Ejecutando tarea...\n\n"
        "(espera 3 segundos)\n\n"
        "✅ Tarea completada\n\n"
        "🎉 Fin del programa\n"
        "```\n\n"
        "**Problema:** Durante la espera (sleep), el programa está bloqueado y no puede hacer nada más.  \n"
        "\n"
        "🔹 **Código asíncrono (no bloqueante)**  \n"
        "```\n\n"
        "import asyncio\n"
        "\n"
        "async def tarea():\n\n"
        "    print('⏳ Ejecutando tarea...')\n\n"
        "    await asyncio.sleep(3)  # Espera sin bloquear el programa\n\n"
        "    print('✅ Tarea completada')\n"
        "\n"
        "async def main():\n\n"
        "    await tarea()\n\n"
        "    print('🎉 Fin del programa')\n"
        "\n"
        "asyncio.run(main())\n"
        "```\n\n"
        "**Salida:**  \n"
        "```\n\n"
        "⏳ Ejecutando tarea...\n\n"
        "(espera 3 segundos)\n\n"
        "✅ Tarea completada\n\n"
        "🎉 Fin del programa\n"
        "```\n\n"
        "**Diferencia clave:** Aunque la tarea sigue tardando 3 segundos, *el programa sigue disponible para ejecutar otras tareas en paralelo*.  \n"
        "\n"
        "### 3. Conexiones Asíncronas en Python: Uso de asyncio  \n"
        "\n"
        "asyncio es el módulo principal para manejar *tareas asíncronas* en Python.  \n"
        "\n"
        "**📌 a) Tareas asíncronas en paralelo**  \n"
        "```\n\n"
        "import asyncio\n"
        "\n"
        "async def tarea(nombre, segundos):\n\n"
        "    print(f'⏳ {nombre} iniciando...')\n\n"
        "    await asyncio.sleep(segundos)  # Simula un proceso asíncrono\n\n"
        "    print(f'✅ {nombre} completada en {segundos} segundos')\n"
        "\n"
        "async def main():\n\n"
        "    await asyncio.gather(\n\n"
        "        tarea('Tarea 1', 2),\n\n"
        "        tarea('Tarea 2', 3),\n\n"
        "        tarea('Tarea 3', 1)\n\n"
        "    )\n"
        "\n"
        "asyncio.run(main())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Lanza **tres tareas en paralelo** usando `asyncio.gather()`.  \n\n"
        "- No espera a que una termine para iniciar la siguiente.  \n\n"
        "- **Optimiza el tiempo de ejecución**, terminando en el menor tiempo posible.  \n"
        "\n"
        "### 4. Conexiones Asíncronas con Bases de Datos  \n"
        "\n"
        "Si usamos bases de datos SQL como PostgreSQL o MySQL, necesitamos **drivers asíncronos**, como:  \n\n"
        "🔹 asyncpg → PostgreSQL  \n\n"
        "🔹 aiomysql → MySQL  \n\n"
        "🔹 motor → MongoDB  \n"
        "\n"
        "**📌 Ejemplo: Conectar a PostgreSQL Asíncronamente**  \n"
        "```\n\n"
        "pip install asyncpg\n"
        "```\n"
        "```\n\n"
        "import asyncpg\n\n"
        "import asyncio\n"
        "\n"
        "async def conectar_db():\n\n"
        "    conn = await asyncpg.connect(user='user', password='pass', database='testdb', host='localhost')\n"
        "    \n"
        "    # Ejecutar una consulta\n\n"
        "    filas = await conn.fetch('SELECT * FROM usuarios')\n"
        "    \n"
        "    # Mostrar los resultados\n\n"
        "    for fila in filas:\n\n"
        "        print(fila)\n"
        "    \n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(conectar_db())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Se conecta a **PostgreSQL** usando `asyncpg`.  \n\n"
        "- **Ejecuta consultas sin bloquear el programa**.  \n\n"
        "- **Cierra la conexión** cuando termina.  \n"
        "\n"
        "✅ **Ideal para APIs y aplicaciones con muchas consultas simultáneas**.  \n"
        "\n"
        "### 5. Conexiones Asíncronas con APIs (HTTP)  \n"
        "\n"
        "Para hacer peticiones HTTP en *modo asíncrono*, se usa *aiohttp*.  \n"
        "\n"
        "🔹 **Instalar aiohttp:**  \n"
        "```\n\n"
        "pip install aiohttp\n"
        "```\n"
        "\n"
        "🔹 **Ejemplo: Hacer múltiples peticiones en paralelo**  \n"
        "```\n\n"
        "import aiohttp\n\n"
        "import asyncio\n"
        "\n"
        "async def fetch(url):\n\n"
        "    async with aiohttp.ClientSession() as session:\n\n"
        "        async with session.get(url) as response:\n\n"
        "            print(f'✅ {url} - Status: {response.status}')\n"
        "\n"
        "async def main():\n\n"
        "    urls = [\n\n"
        "        'https://jsonplaceholder.typicode.com/posts/1',\n\n"
        "        'https://jsonplaceholder.typicode.com/posts/2',\n\n"
        "        'https://jsonplaceholder.typicode.com/posts/3'\n\n"
        "    ]\n"
        "    \n"
        "    await asyncio.gather(*(fetch(url) for url in urls))\n"
        "\n"
        "asyncio.run(main())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Usa aiohttp para hacer **peticiones HTTP sin bloquear**.  \n\n"
        "- Lanza *varias peticiones en paralelo* con asyncio.gather().  \n\n"
        "- *Optimiza el tiempo de respuesta* en comparación con requests.  \n"
        "\n"
        "### 6. Conexiones Asíncronas con WebSockets  \n"
        "\n"
        "🔹 **Instalar la librería `websockets`**  \n"
        "```\n\n"
        "pip install websockets\n"
        "```\n"
        "\n"
        "🔹 **Ejemplo: Servidor WebSocket con FastAPI**  \n"
        "```\n\n"
        "from fastapi import FastAPI, WebSocket\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "@app.websocket('/ws')\n\n"
        "async def websocket_endpoint(websocket: WebSocket):\n\n"
        "    await websocket.accept()\n\n"
        "    while True:\n\n"
        "        data = await websocket.receive_text()\n\n"
        "        await websocket.send_text(f'Mensaje recibido: {data}')\n"
        "\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Crea un servidor WebSocket en /ws.  \n\n"
        "- Acepta mensajes y responde en *tiempo real*.  \n"
        "\n"
        "✅ **Usado para chats, notificaciones y streaming de datos.**  \n"
        "\n"
        "### 7. Cuándo Usar Conexiones Asíncronas  \n"
        "\n"
        "✔️ **Cuando hay múltiples operaciones de I/O**, como bases de datos y APIs.  \n\n"
        "✔️ **Cuando se necesitan WebSockets o streaming de datos en tiempo real.**  \n\n"
        "✔️ **Cuando se hacen muchas peticiones HTTP simultáneas.**  \n\n"
        "✔️ **Cuando se requiere alta escalabilidad y bajo consumo de recursos.**  \n"
        "\n"
        "❌ **No es recomendable para operaciones pesadas en CPU** (usar multiprocessing en su lugar).  \n"
        "\n"
        "### 8. Conclusión\n"
        "\n"
        "🚀 **Las conexiones asíncronas en Python permiten ejecutar tareas concurrentes sin bloquear el programa**.  \n\n"
        "⚡ **Optimiza APIs, bases de datos y WebSockets, reduciendo tiempos de espera.**  \n\n"
        "🔹 **asyncio y aiohttp son esenciales para construir aplicaciones modernas y eficientes.**  \n"
        "\n"
        "📌 **¡Ahora puedes manejar conexiones asíncronas como un experto!** 😃\n"
    ),

    (
        "asyncpg",
        "# 📌 ¿Qué es asyncpg y cómo usarlo en Python?  \n"
        "\n"
        "### 1. ¿Qué es asyncpg?  \n\n"
        "asyncpg es una biblioteca **asíncrona** para conectarse y operar con bases de datos *PostgreSQL* en Python. Se basa en asyncio, lo que permite manejar consultas *sin bloquear el programa*, optimizando la concurrencia y el rendimiento.  \n"
        "\n"
        "🔹 **Ventajas de asyncpg:**  \n\n"
        "✅ Más rápido que psycopg2 porque usa una arquitectura optimizada.  \n\n"
        "✅ Compatible con asyncio, lo que permite ejecutar múltiples consultas en paralelo.  \n\n"
        "✅ Manejo eficiente de conexiones y pools de conexión.  \n\n"
        "✅ Compatible con **PostgreSQL 9.2+**.  \n"
        "\n"
        "### 2. Instalación de asyncpg  \n\n"
        "Para instalar asyncpg, usa:  \n"
        "```\n\n"
        "pip install asyncpg\n"
        "```\n"
        "\n"
        "Asegúrate de tener *PostgreSQL* instalado y funcionando.  \n"
        "\n"
        "Si quieres probar sin instalar PostgreSQL, puedes ejecutar un contenedor con Docker:  \n"
        "```\n\n"
        "docker run --name postgres -e POSTGRES_USER=user -e POSTGRES_PASSWORD=pass -e POSTGRES_DB=testdb -p 5432:5432 -d postgres\n"
        "```\n"
        "\n"
        "### 3. Conectar a PostgreSQL con asyncpg  \n"
        "\n"
        "🔹 **Ejemplo: Conexión simple**  \n"
        "```\n\n"
        "import asyncpg\n\n"
        "import asyncio\n"
        "\n"
        "async def conectar_db():\n\n"
        "    conn = await asyncpg.connect(\n\n"
        "        user='user',\n\n"
        "        password='pass',\n\n"
        "        database='testdb',\n\n"
        "        host='localhost'\n\n"
        "    )\n\n"
        "    print('✅ Conectado a PostgreSQL')\n"
        "\n"
        "    # Cerrar la conexión\n\n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(conectar_db())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Se conecta a PostgreSQL usando asyncpg.connect().  \n\n"
        "- Si la conexión es exitosa, imprime ✅ Conectado a PostgreSQL.  \n\n"
        "- Cierra la conexión al terminar.  \n"
        "\n"
        "### 4. Insertar Datos en PostgreSQL  \n"
        "\n"
        "🔹 **Ejemplo: Insertar un usuario en la base de datos**  \n"
        "```\n\n"
        "import asyncpg\n\n"
        "import asyncio\n"
        "\n"
        "async def insertar_usuario():\n\n"
        "    conn = await asyncpg.connect(user='user', password='pass', database='testdb', host='localhost')\n"
        "    \n"
        "    await conn.execute('INSERT INTO usuarios (nombre, edad) VALUES ($1, $2)', 'Juan Pérez', 30)\n"
        "\n"
        "    print('✅ Usuario insertado')\n"
        "    \n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(insertar_usuario())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Conecta a PostgreSQL.  \n\n"
        "- Inserta un usuario con `nombre = Juan Pérez` y `edad = 30`.  \n\n"
        "- Usa **`$1, $2`** como parámetros seguros contra **inyección SQL**.  \n\n"
        "- Cierra la conexión al finalizar.  \n"
        "\n"
        "### 5. Consultar Datos  \n"
        "\n"
        "🔹 **Ejemplo: Obtener todos los usuarios de la base de datos**  \n"
        "```\n\n"
        "import asyncpg\n\n"
        "import asyncio\n"
        "\n"
        "async def obtener_usuarios():\n\n"
        "    conn = await asyncpg.connect(user='user', password='pass', database='testdb', host='localhost')\n"
        "    \n"
        "    filas = await conn.fetch('SELECT * FROM usuarios')\n"
        "\n"
        "    for fila in filas:\n\n"
        "        print(f'👤 Usuario: {fila['nombre']}, Edad: {fila['edad']}')\n"
        "    \n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(obtener_usuarios())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Consulta todos los usuarios con `SELECT * FROM usuarios`.  \n\n"
        "- Recorre los resultados y los imprime.  \n\n"
        "- Cierra la conexión después de obtener los datos.  \n"
        "\n"
        "### 6. Uso de Pool de Conexiones \n"
        "\n"
        "Si necesitas manejar **múltiples conexiones simultáneamente**, `asyncpg` permite crear un **pool de conexiones** para mejorar el rendimiento.  \n"
        "\n"
        "🔹 **Ejemplo: Usar un pool de conexiones**  \n"
        "```\n\n"
        "import asyncpg\n\n"
        "import asyncio\n"
        "\n"
        "async def ejecutar_consulta():\n\n"
        "    pool = await asyncpg.create_pool(user='user', password='pass', database='testdb', host='localhost', min_size=1, max_size=5)\n"
        "\n"
        "    async with pool.acquire() as conn:\n\n"
        "        usuario = await conn.fetchrow('SELECT * FROM usuarios WHERE nombre = $1', 'Juan Pérez')\n\n"
        "        print(f'👤 Usuario encontrado: {usuario['nombre']}, Edad: {usuario['edad']}')\n"
        "\n"
        "    await pool.close()\n"
        "\n"
        "asyncio.run(ejecutar_consulta())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Crea un *pool de conexiones* con un mínimo de 1 y un máximo de 5 conexiones.  \n\n"
        "- Usa pool.acquire() para obtener una conexión del pool.  \n\n"
        "- Realiza una consulta y la muestra.  \n\n"
        "- Cierra el pool al finalizar.  \n"
        "\n"
        "✅ **Ideal para manejar múltiples peticiones concurrentes sin saturar la base de datos.**  \n"
        "\n"
        "### 7. Conclusión  \n"
        "\n"
        "🚀 **`asyncpg` es la mejor opción para conexiones asíncronas con PostgreSQL en Python.**  \n\n"
        "⚡ **Permite realizar consultas concurrentes sin bloquear el programa.**  \n\n"
        "🔹 **Recomendado para APIs, aplicaciones web y sistemas de alta concurrencia.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes manejar PostgreSQL de forma asíncrona como un experto!** 😃\n"
    ),

    (
        "aiomysql",
        "# 📌 ¿Qué es aiomysql y cómo usarlo en Python?  \n"
        "\n"
        "### 1. ¿Qué es aiomysql?  \n\n"
        "aiomysql es una biblioteca *asíncrona* que permite conectar Python con bases de datos *MySQL* y *MariaDB* utilizando asyncio. A diferencia de librerías tradicionales como `mysql-connector` o pymysql, aiomysql **no bloquea** el programa mientras ejecuta consultas, permitiendo manejar múltiples operaciones en paralelo.  \n"
        "\n"
        "🔹 **Ventajas de aiomysql:**  \n\n"
        "✅ Compatible con `asyncio`, permitiendo consultas concurrentes.  \n\n"
        "✅ Permite el uso de **pools de conexión** para mayor eficiencia.  \n\n"
        "✅ Funciona con **MySQL** y **MariaDB**.  \n\n"
        "✅ Seguridad mejorada mediante **parámetros protegidos** contra inyecciones SQL.  \n"
        "\n"
        "### 2. Instalación de aiomysql  \n\n"
        "Para instalarlo, ejecuta:  \n"
        "```\n\n"
        "pip install aiomysql\n"
        "```\n\n"
        "Asegúrate de tener un servidor MySQL/MariaDB funcionando.  \n"
        "\n"
        "Si no tienes MySQL instalado, puedes ejecutarlo con Docker:  \n"
        "```\n\n"
        "docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=testdb -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -p 3306:3306 -d mysql\n"
        "```\n"
        "\n"
        "### 3. Conectar a MySQL con aiomysql  \n"
        "\n"
        "🔹 **Ejemplo: Conexión simple**  \n"
        "```\n\n"
        "import aiomysql\n\n"
        "import asyncio\n"
        "\n"
        "async def conectar_db():\n\n"
        "    conn = await aiomysql.connect(\n\n"
        "        user='user',\n\n"
        "        password='pass',\n\n"
        "        db='testdb',\n\n"
        "        host='localhost',\n\n"
        "        port=3306\n\n"
        "    )\n\n"
        "    print('✅ Conectado a MySQL')\n"
        "\n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(conectar_db())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Conecta a MySQL usando aiomysql.connect().  \n\n"
        "- Si la conexión es exitosa, imprime ✅ Conectado a MySQL.  \n\n"
        "- Cierra la conexión al finalizar.  \n"
        "\n"
        "### 4. Insertar Datos en MySQL  \n"
        "\n"
        "🔹 **Ejemplo: Insertar un usuario en la base de datos**  \n"
        "```\n\n"
        "import aiomysql\n\n"
        "import asyncio\n"
        "\n"
        "async def insertar_usuario():\n\n"
        "    conn = await aiomysql.connect(user='user', password='pass', db='testdb', host='localhost', port=3306)\n\n"
        "    async with conn.cursor() as cursor:\n\n"
        "        await cursor.execute('INSERT INTO usuarios (nombre, edad) VALUES (%s, %s)', ('Juan Pérez', 30))\n\n"
        "        await conn.commit()\n"
        "    \n"
        "    print('✅ Usuario insertado')\n\n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(insertar_usuario())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Conecta a MySQL.  \n\n"
        "- Inserta un usuario con nombre = Juan Pérez y edad = 30.  \n\n"
        "- Usa **%s, %s** como parámetros seguros contra **inyección SQL**.  \n\n"
        "- Ejecuta conn.commit() para guardar los cambios.  \n\n"
        "- Cierra la conexión al finalizar.  \n"
        "\n"
        "### 5. Consultar Datos  \n"
        "\n"
        "🔹 **Ejemplo: Obtener todos los usuarios de la base de datos**  \n"
        "```\n\n"
        "import aiomysql\n\n"
        "import asyncio\n"
        "\n"
        "async def obtener_usuarios():\n\n"
        "    conn = await aiomysql.connect(user='user', password='pass', db='testdb', host='localhost', port=3306)\n"
        "    \n"
        "    async with conn.cursor(aiomysql.DictCursor) as cursor:\n\n"
        "        await cursor.execute('SELECT * FROM usuarios')\n\n"
        "        filas = await cursor.fetchall()\n"
        "\n"
        "        for fila in filas:\n\n"
        "            print(f'👤 Usuario: {fila['nombre']}, Edad: {fila['edad']}')\n"
        "\n"
        "    await conn.close()\n"
        "\n"
        "asyncio.run(obtener_usuarios())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Consulta todos los usuarios con SELECT * FROM usuarios.  \n\n"
        "- Usa DictCursor para recibir los resultados en formato de diccionario.  \n\n"
        "- Imprime cada usuario con su nombre y edad.  \n\n"
        "- Cierra la conexión después de obtener los datos.  \n"
        "\n"
        "### 6. Uso de Pool de Conexiones  \n"
        "\n"
        "Si la aplicación maneja muchas conexiones, **usar un pool de conexiones** mejora la eficiencia y evita saturar el servidor.  \n"
        "\n"
        "🔹 **Ejemplo: Usar un pool de conexiones**  \n"
        "```\n\n"
        "import aiomysql\n\n"
        "import asyncio\n"
        "\n"
        "async def ejecutar_consulta():\n\n"
        "    pool = await aiomysql.create_pool(user='user', password='pass', db='testdb', host='localhost', port=3306, minsize=1, maxsize=5)\n"
        "\n"
        "    async with pool.acquire() as conn:\n\n"
        "        async with conn.cursor(aiomysql.DictCursor) as cursor:\n\n"
        "            await cursor.execute('SELECT * FROM usuarios WHERE nombre = %s', ('Juan Pérez',))\n\n"
        "            usuario = await cursor.fetchone()\n\n"
        "            print(f'👤 Usuario encontrado: {usuario['nombre']}, Edad: {usuario['edad']}')\n"
        "\n"
        "    pool.close()\n\n"
        "    await pool.wait_closed()\n"
        "\n"
        "asyncio.run(ejecutar_consulta())\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Crea un **pool de conexiones** con un mínimo de 1 y un máximo de 5 conexiones.  \n\n"
        "- Usa pool.acquire() para obtener una conexión del pool.  \n\n"
        "- Realiza una consulta y la muestra.  \n\n"
        "- Cierra el pool al finalizar.  \n"
        "\n"
        "✅ **Ideal para APIs y aplicaciones con múltiples usuarios conectados.**  \n"
        "\n"
        "### 7. Conclusión \n"
        "\n"
        "🚀 **aiomysql es una excelente opción para conectar Python con MySQL de forma asíncrona.**  \n\n"
        "⚡ **Optimiza la concurrencia y evita bloqueos en aplicaciones con múltiples conexiones.**  \n\n"
        "🔹 **Usar un pool de conexiones mejora el rendimiento en APIs y servicios web.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes manejar MySQL de forma asíncrona como un experto!** 😃\n"
    ),

    (
        "caching",
        "# 📌 ¿Qué es Caching y cómo implementarlo con Redis y Memcached en Python?  \n"
        "\n"
        "### 1. ¿Qué es Caching?  \n\n"
        "El *caching* es una técnica para *almacenar temporalmente datos en memoria* y así acelerar el acceso a información frecuentemente utilizada. En lugar de consultar una base de datos o calcular un valor cada vez que se necesita, el dato se guarda en una caché, lo que *reduce la latencia* y *mejora el rendimiento* de la aplicación.  \n"
        "\n"
        "🔹 **Beneficios del Caching:**  \n\n"
        "✅ Reduce el tiempo de respuesta de las consultas.  \n\n"
        "✅ Disminuye la carga en la base de datos o servicios externos.  \n\n"
        "✅ Optimiza el uso de recursos en servidores.  \n"
        "\n"
        "### 2. Estrategias de Caching  \n"
        "\n"
        "Existen varias estrategias de caching dependiendo de la necesidad de la aplicación:  \n"
        "\n"
        "🔹 **Cache Aside (Lazy Loading):**  \n\n"
        "   - Primero se consulta la caché.  \n\n"
        "   - Si el dato **no está en caché**, se obtiene de la base de datos y **se almacena en la caché** para futuros accesos.  \n\n"
        "   - Se usa en aplicaciones con datos **frecuentemente leídos** pero que no cambian mucho.  \n"
        "\n"
        "🔹 **Write-Through Cache:**  \n\n"
        "   - Cuando se escribe un dato en la base de datos, también se **almacena en caché** inmediatamente.  \n\n"
        "   - Se asegura que la caché siempre tenga los datos más recientes.  \n"
        "\n"
        "🔹 **Write-Back Cache:**  \n\n"
        "   - Los datos se escriben **primero en caché** y, después de un tiempo, se sincronizan con la base de datos.  \n\n"
        "   - Mejora el rendimiento en aplicaciones con **muchas escrituras**, pero puede haber pérdida de datos en caso de falla.  \n"
        "\n"
        "🔹 **Time-To-Live (TTL):**  \n\n"
        "   - Se asigna un **tiempo de expiración** a los datos en la caché para que se eliminen automáticamente.  \n\n"
        "   - Se usa en datos que cambian con el tiempo y deben actualizarse periódicamente.  \n"
        "\n"
        "### 3. Implementación con Redis en Python  \n\n"
        "Redis es una base de datos en memoria **extremadamente rápida**, ideal para caching.  \n"
        "\n"
        "**📌 Instalación de Redis y cliente en Python**  \n\n"
        "Para instalar Redis y su cliente en Python (`redis-py`):  \n"
        "```\n\n"
        "pip install redis\n"
        "```\n\n"
        "Si no tienes Redis instalado, puedes ejecutarlo con Docker:  \n"
        "```\n\n"
        "docker run --name redis -p 6379:6379 -d redis\n"
        "```\n"
        "\n"
        "**📌 Implementación de Cache Aside con Redis**  \n"
        "```\n\n"
        "import redis\n\n"
        "import time\n"
        "\n"
        "# Conectar a Redis\n\n"
        "cache = redis.Redis(host='localhost', port=6379, decode_responses=True)\n"
        "\n"
        "def get_data(key):\n\n"
        '    """Simula una consulta a la base de datos"""\n\n'
        "    time.sleep(2)  # Simula un tiempo de consulta lento\n\n"
        "    return f'Datos de {key}'\n"
        "\n"
        "def get_from_cache(key):\n\n"
        '    """Consulta primero en Redis, si no está, obtiene de la base de datos y lo almacena"""\n\n'
        "    data = cache.get(key)\n"
        "    \n"
        "    if data:\n\n"
        "        print('✅ Datos obtenidos de Redis')\n\n"
        "        return data\n"
        "    \n"
        "    print('🔍 Datos no encontrados en Redis, consultando la base de datos...')\n\n"
        "    data = get_data(key)\n\n"
        "    cache.setex(key, 10, data)  # Almacena en Redis con una expiración de 10 segundos\n\n"
        "    return data\n"
        "\n"
        "# Primera consulta (no está en caché)\n\n"
        "print(get_from_cache('usuario:1'))\n"
        "\n"
        "# Segunda consulta (se obtiene de Redis)\n\n"
        "print(get_from_cache('usuario:1'))\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Intenta obtener el dato de Redis.  \n\n"
        "- Si **existe en caché**, lo devuelve rápidamente.  \n\n"
        "- Si **no está en caché**, lo obtiene de la base de datos y lo guarda en Redis con una **expiración de 10 segundos**.  \n"
        "\n"
        "### 4. Implementación con Memcached en Python  \n\n"
        "Memcached es otro sistema de almacenamiento en memoria **rápido y ligero**, diseñado para **acelerar aplicaciones web**.  \n"
        "\n"
        "**📌 Instalación de Memcached y su cliente en Python**  \n\n"
        "Para instalar el cliente de Memcached en Python:  \n"
        "```\n\n"
        "pip install pymemcache\n"
        "```\n\n"
        "Si no tienes Memcached instalado, puedes ejecutarlo con Docker:  \n"
        "```\n\n"
        "docker run --name memcached -p 11211:11211 -d memcached\n"
        "```\n"
        "\n"
        "**📌 Implementación de Cache Aside con Memcached**  \n"
        "```\n\n"
        "from pymemcache.client import base\n\n"
        "import time\n"
        "\n"
        "# Conectar a Memcached\n\n"
        "cache = base.Client(('localhost', 11211))\n"
        "\n"
        "def get_data(key):\n\n"
        '    """Simula una consulta lenta a la base de datos"""\n\n'
        "    time.sleep(2)\n\n"
        "    return f'Datos de {key}'\n"
        "\n"
        "def get_from_cache(key):\n\n"
        '    """Consulta en Memcached, si no está, obtiene los datos y los almacena"""\n\n'
        "    data = cache.get(key)\n"
        "    \n"
        "    if data:\n\n"
        "        print('✅ Datos obtenidos de Memcached')\n\n"
        "        return data.decode('utf-8')  # Decodificar bytes a string\n"
        "    \n"
        "    print('🔍 Datos no encontrados en Memcached, consultando la base de datos...')\n\n"
        "    data = get_data(key)\n\n"
        "    cache.set(key, data, expire=10)  # Guarda en caché por 10 segundos\n\n"
        "    return data\n"
        "\n"
        "# Primera consulta (no está en caché)\n\n"
        "print(get_from_cache('usuario:1'))\n"
        "\n"
        "# Segunda consulta (se obtiene de Memcached)\n\n"
        "print(get_from_cache('usuario:1'))\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- Intenta obtener el dato de Memcached.  \n\n"
        "- Si **está en caché**, lo devuelve rápidamente.  \n\n"
        "- Si **no está en caché**, lo obtiene de la base de datos y lo guarda en Memcached con **una expiración de 10 segundos**.  \n"
        "\n"
        "### 5. Comparación: Redis vs Memcached  \n"
        "\n"
        "🔹 **Redis:**  \n\n"
        "✅ Permite estructuras de datos avanzadas como listas, sets y hashes.  \n\n"
        "✅ Soporta persistencia de datos (opcional).  \n\n"
        "✅ Ideal para aplicaciones con **múltiples operaciones de lectura y escritura**.  \n"
        "\n"
        "🔹 **Memcached:**  \n\n"
        "✅ Más ligero y rápido en almacenamiento simple de claves y valores.  \n\n"
        "✅ No ofrece persistencia de datos.  \n\n"
        "✅ Ideal para **caching puro** en aplicaciones web de alto tráfico.  \n"
        "\n"
        "📌 **Conclusión:** Si necesitas caching simple, Memcached es más rápido. Si necesitas almacenamiento avanzado y persistencia, Redis es mejor.  \n"
        "\n"
        "### 6. Conclusión  \n"
        "\n"
        "🚀 **El caching mejora el rendimiento y reduce la carga en la base de datos.**  \n\n"
        "⚡ **Redis y Memcached son opciones excelentes para caching en Python.**  \n\n"
        "🔹 **Cache Aside es la estrategia más utilizada en aplicaciones web.**  \n"
        "\n"
        "📌 **¡Ahora puedes optimizar tus aplicaciones con caching como un experto!** 😃\n"
    ),

    (
        "patrones de diseño",
        "# 📌 Patrones de Diseño en Python  \n"
        "\n"
        "### 1. ¿Qué son los Patrones de Diseño?  \n\n"
        "Los **patrones de diseño** son soluciones reutilizables para problemas comunes en el desarrollo de software. No son código específico, sino **estructuras y principios** que ayudan a organizar el código de forma más **eficiente, reutilizable y mantenible**.  \n"
        "\n"
        "Estos patrones ayudan a:  \n\n"
        "✅ **Evitar código repetitivo y difícil de mantener.**  \n\n"
        "✅ **Mejorar la organización del código y la escalabilidad.**  \n\n"
        "✅ **Facilitar la colaboración en proyectos grandes.**  \n"
        "\n"
        "### 2. Clasificación de los Patrones de Diseño  \n"
        "\n"
        "🔹 **Patrones Creacionales** → Controlan la creación de objetos.  \n\n"
        "🔹 **Patrones Estructurales** → Organizan la relación entre clases y objetos.  \n\n"
        "🔹 **Patrones de Comportamiento** → Definen la comunicación entre objetos.  \n"
        "\n"
        "A continuación, veremos ejemplos de cada uno en **Python**.  \n"
        "\n"
        "### 3. Ejemplo de un Patrón Creacional: Singleton  \n\n"
        "📌 **Propósito:** Garantiza que solo exista *una única instancia* de una clase y proporciona un acceso global a ella.  \n"
        "\n"
        "🔹 **Ejemplo: Implementación de Singleton en Python**  \n"
        "```\n\n"
        "class Singleton:\n\n"
        "    _instance = None  # Almacena la única instancia de la clase\n"
        "\n"
        "    def __new__(cls):\n\n"
        "        if cls._instance is None:\n\n"
        "            cls._instance = super(Singleton, cls).__new__(cls)\n\n"
        "        return cls._instance\n"
        "\n"
        "# Prueba del Singleton\n\n"
        "obj1 = Singleton()\n\n"
        "obj2 = Singleton()\n"
        "\n"
        "print(obj1 is obj2)  # ✅ True, ambas variables apuntan a la misma instancia\n"
        "```\n\n"
        "📌 **Explicación:**  \n\n"
        "- __new__() verifica si la instancia ya existe.  \n\n"
        "- Si no existe, la crea y la almacena en _instance.  \n\n"
        "- Si ya existe, devuelve la instancia existente.  \n"
        "\n"
        "✅ **Útil para:** Gestores de configuración, conexión a bases de datos, etc.  \n"
        "\n"
        "### 4. Ejemplo de un Patrón Estructural: Decorator  \n\n"
        "📌 **Propósito:** Permite añadir funcionalidades a un objeto *sin modificar su estructura interna*.  \n"
        "\n"
        "🔹 **Ejemplo: Un Decorador en Python**  \n"
        "```\n\n"
        "def decorador(func):\n\n"
        "    def envoltura():\n\n"
        "        print('🔹 Antes de ejecutar la función')\n\n"
        "        func()\n\n"
        "        print('🔹 Después de ejecutar la función')\n\n"
        "    return envoltura\n"
        "\n"
        "@decorador\n\n"
        "def saludo():\n\n"
        "    print('👋 ¡Hola, mundo!')\n"
        "\n"
        "saludo()\n"
        "```\n\n"
        "📌 **Explicación:**  \n\n"
        "- decorador() recibe una función y le añade funcionalidad antes y después de ejecutarla.  \n\n"
        "- La sintaxis @decorador aplica el patrón directamente a saludo().  \n"
        "\n"
        "✅ **Útil para:** Logging, autenticación, control de acceso.  \n"
        "\n"
        "### 5. Ejemplo de un Patrón de Comportamiento: Observer  \n\n"
        "📌 **Propósito:** Permite que múltiples objetos sean notificados cuando un objeto cambia su estado.  \n"
        "\n"
        "🔹 **Ejemplo: Implementación de Observer en Python**  \n"
        "```\n\n"
        "class Observable:\n\n"
        "    def __init__(self):\n\n"
        "        self.observers = []\n"
        "\n"
        "    def agregar_observador(self, observador):\n\n"
        "        self.observers.append(observador)\n"
        "\n"
        "    def notificar(self, mensaje):\n\n"
        "        for obs in self.observers:\n\n"
        "            obs.actualizar(mensaje)\n"
        "\n"
        "class Observador:\n\n"
        "    def actualizar(self, mensaje):\n\n"
        "        print(f'📢 Notificación recibida: {mensaje}')\n"
        "\n"
        "# Uso del patrón Observer\n\n"
        "observable = Observable()\n\n"
        "obs1 = Observador()\n\n"
        "obs2 = Observador()\n"
        "\n"
        "observable.agregar_observador(obs1)\n\n"
        "observable.agregar_observador(obs2)\n"
        "\n"
        "observable.notificar('Se ha actualizado el sistema')  \n"
        "```\n\n"
        "📌 **Explicación:**  \n\n"
        "- Observable mantiene una lista de observadores y les notifica cambios.  \n\n"
        "- Observador define el método actualizar() que recibe las notificaciones.  \n\n"
        "- Se agregan observadores y se envía una notificación.  \n"
        "\n"
        "✅ **Útil para:** Sistemas de eventos, interfaces gráficas, patrones de notificación.  \n"
        "\n"
        "### 6. Conclusión  \n"
        "\n"
        "🚀 **Los patrones de diseño mejoran la calidad y organización del código.**  \n\n"
        "⚡ **Evitan problemas comunes y facilitan la reutilización de código.**  \n\n"
        "🔹 **Python facilita la implementación de estos patrones con su flexibilidad y simplicidad.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes aplicar patrones de diseño como un experto!** 🎯\n"
    ),

    (
        "singleton",
        "# 📌 Patrón Singleton en Python \n"
        "\n"
        "### 1. ¿Qué es el patrón Singleton?  \n\n"
        "El *patrón Singleton* es un *patrón de diseño creacional* que garantiza que *solo exista una única instancia de una clase* en todo el programa y proporciona un *punto de acceso global* a esa instancia.  \n"
        "\n"
        "📌 **Objetivo del Singleton:**  \n\n"
        "✅ Evitar la creación de múltiples instancias de una misma clase.  \n\n"
        "✅ Controlar el acceso a recursos compartidos (base de datos, configuraciones, logs).  \n\n"
        "✅ Ahorrar memoria y mejorar el rendimiento en procesos que no requieren múltiples instancias.  \n"
        "\n"
        "### 2. ¿Para qué se utiliza el Singleton?  \n\n"
        "El Singleton es útil cuando **una sola instancia** de una clase debe coordinar acciones en todo el sistema.  \n"
        "\n"
        "🔹 **Casos de uso comunes:**  \n\n"
        "✅ **Conexiones a bases de datos** (para evitar abrir múltiples conexiones innecesarias).  \n\n"
        "✅ **Gestión de configuración** (cargar una vez y reutilizar en todo el sistema).  \n\n"
        "✅ **Sistemas de logging** (un solo registro centralizado de eventos).  \n\n"
        "✅ **Gestión de caché o recursos compartidos** (almacenar datos en memoria eficientemente).  \n"
        "\n"
        "### 3. Implementación del patrón Singleton en Python  \n\n"
        "En Python, el Singleton se puede implementar de varias maneras. Aquí te muestro dos formas comunes.  \n"
        "\n"
        "**📌 Implementación con __new__()**\n"
        "```\n\n"
        "class Singleton:\n\n"
        "    _instance = None  # Variable de clase que almacena la instancia única\n"
        "\n"
        "    def __new__(cls):\n\n"
        "        if cls._instance is None:\n\n"
        "            cls._instance = super(Singleton, cls).__new__(cls)\n\n"
        "        return cls._instance\n"
        "\n"
        "# Prueba del Singleton\n\n"
        "obj1 = Singleton()\n\n"
        "obj2 = Singleton()\n"
        "\n"
        "print(obj1 is obj2)  # ✅ True, ambas variables apuntan a la misma instancia\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- La primera vez que se llama Singleton(), __new__() crea una nueva instancia y la guarda en _instance.  \n\n"
        "- Las siguientes veces que se llame Singleton(), __new__() devolverá la **misma instancia existente**.  \n\n"
        "- Si imprimimos obj1 is obj2, devuelve True, porque ambas variables son la misma instancia.  \n"
        "\n"
        "**📌 Implementación con un Decorador**  \n\n"
        "Otra forma elegante de implementar Singleton es con **decoradores**:  \n"
        "```\n\n"
        "def singleton(cls):\n\n"
        "    instances = {}\n"
        "\n"
        "    def get_instance(*args, **kwargs):\n\n"
        "        if cls not in instances:\n\n"
        "            instances[cls] = cls(*args, **kwargs)\n\n"
        "        return instances[cls]\n"
        "\n"
        "    return get_instance\n"
        "\n"
        "@singleton\n\n"
        "class Config:\n\n"
        "    def __init__(self):\n\n"
        "        self.configuracion = {'modo': 'producción'}\n"
        "\n"
        "# Prueba del Singleton con decorador\n\n"
        "c1 = Config()\n\n"
        "c2 = Config()\n"
        "\n"
        "print(c1 is c2)  # ✅ True, ambas son la misma instancia\n\n"
        'print(c1.configuracion)  # {"modo": "producción"}\n'
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- El decorador @singleton almacena la instancia de la clase en un diccionario.  \n\n"
        "- Si la clase ya ha sido instanciada, devuelve la **misma instancia**.  \n\n"
        "- Si imprimimos c1 is c2, devuelve True, asegurando el patrón Singleton.  \n"
        "\n"
        "### 4. Ejemplo de Uso del Singleton en un Gestor de Configuración  \n\n"
        "Supongamos que tenemos una clase de **configuración de aplicación** que solo debe cargarse una vez y reutilizarse.  \n"
        "\n"
        "```\n\n"
        "class Configuracion:\n\n"
        "    _instance = None\n"
        "\n"
        "    def __new__(cls):\n\n"
        "        if cls._instance is None:\n\n"
        "            cls._instance = super(Configuracion, cls).__new__(cls)\n\n"
        "            cls._instance.config = {'modo': 'producción', 'debug': False}\n\n"
        "        return cls._instance\n"
        "\n"
        "    def obtener_configuracion(self):\n\n"
        "        return self.config\n"
        "\n"
        "# Uso del Singleton\n\n"
        "config1 = Configuracion()\n\n"
        "config2 = Configuracion()\n"
        "\n"
        'print(config1.obtener_configuracion())  # {"modo": "producción", "debug": False}\n'
        "\n"
        "# Modificamos la configuración desde una instancia\n\n"
        "config1.config['debug'] = True\n"
        "\n"
        "# Verificamos si la otra instancia tiene el mismo cambio\n\n"
        'print(config2.obtener_configuracion())  # {"modo": "producción", "debug": True}\n'
        "\n"
        "print(config1 is config2)  # ✅ True, ambas apuntan a la misma instancia\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- La primera vez que se crea Configuracion(), almacena la instancia en _instance.  \n\n"
        "- Si se vuelve a crear Configuracion(), devuelve la misma instancia.  \n\n"
        "- Si cambiamos la configuración en config1, config2 también refleja los cambios.  \n"
        "\n"
        "✅ **Este patrón es ideal para cargar configuraciones globales en una aplicación sin duplicar instancias innecesarias.**  \n"
        "\n"
        "### 5. Conclusión  \n"
        "\n"
        "🚀 **El patrón Singleton garantiza que solo exista una única instancia de una clase.**  \n\n"
        "⚡ **Es útil para conexiones a bases de datos, gestión de configuración, logging y más.**  \n\n"
        "🔹 **Se puede implementar en Python con __new__(), decoradores o metaclases.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes aplicar el patrón Singleton en tus proyectos de Python!** 🔥\n"
    ),

    (
        "factory",
        "# 📌 Patrón Factory en Python \n"
        "\n"
        "### 1. ¿Qué es el patrón Factory?  \n\n"
        "El *patrón Factory* es un *patrón de diseño creacional* que permite *crear objetos sin especificar su clase exacta*. En lugar de instanciar los objetos directamente con Clase(), usamos un *método o función* que decide qué objeto devolver.  \n"
        "\n"
        "📌 **Objetivo del Factory:**  \n\n"
        "✅ **Encapsular la creación de objetos** para evitar código repetitivo.  \n\n"
        "✅ **Permitir flexibilidad y escalabilidad**, ya que el tipo de objeto a crear puede decidirse en tiempo de ejecución.  \n\n"
        "✅ **Facilitar el mantenimiento**, evitando dependencias directas con clases específicas.  \n"
        "\n"
        "### 2. ¿Para qué se utiliza el Factory?  \n\n"
        "🔹 **Cuando el proceso de creación de objetos es complejo.**  \n\n"
        "🔹 **Si el código necesita ser extensible**, permitiendo añadir nuevas clases sin modificar la lógica existente.  \n\n"
        "🔹 **Para desacoplar la lógica de negocio de la creación de instancias.**  \n"
        "\n"
        "Ejemplos comunes incluyen:  \n\n"
        "✅ Creación de **conexiones a bases de datos** según el motor seleccionado.  \n\n"
        "✅ Sistemas de **logs** que crean diferentes tipos de registradores.  \n\n"
        "✅ Creación de **interfaces gráficas** con diferentes tipos de botones o widgets.  \n"
        "\n"
        "### 3. Implementación del patrón Factory en Python  \n\n"
        "En Python, podemos implementar **Factory Method** usando una **función** o una **clase Factory**.  \n"
        "\n"
        "**📌 Implementación básica con una función Factory**\n"
        "```\n\n"
        "class Perro:\n\n"
        "    def hablar(self):\n\n"
        "        return '🐶 Guau!'\n"
        "\n"
        "class Gato:\n\n"
        "    def hablar(self):\n\n"
        "        return '🐱 Miau!'\n"
        "\n"
        "# Función Factory\n\n"
        "def obtener_animal(tipo):\n\n"
        "    if tipo == 'perro':\n\n"
        "        return Perro()\n\n"
        "    elif tipo == 'gato':\n\n"
        "        return Gato()\n\n"
        "    else:\n\n"
        "        raise ValueError('Tipo de animal no reconocido')\n"
        "\n"
        "# Uso del Factory\n\n"
        "animal1 = obtener_animal('perro')\n\n"
        "animal2 = obtener_animal('gato')\n"
        "\n"
        "print(animal1.hablar())  # 🐶 Guau!\n\n"
        "print(animal2.hablar())  # 🐱 Miau!\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- obtener_animal(tipo) decide qué clase instanciar según el parámetro recibido.  \n\n"
        "- Si pedimos 'perro', crea un objeto Perro().  \n\n"
        "- Si pedimos 'gato', crea un objeto Gato().  \n\n"
        "- **El código que usa la Factory no necesita conocer las clases concretas**, solo llama a obtener_animal().  \n"
        "\n"
        "✅ **Ventaja:** Si queremos añadir más animales, solo agregamos nuevas clases sin modificar el código existente.  \n"
        "\n"
        "### 4. Implementación con una Clase Factory  \n\n"
        "A veces, una función Factory no es suficiente, y necesitamos una **clase Factory** para manejar objetos más complejos.  \n"
        "\n"
        "```\n\n"
        "class AnimalFactory:\n\n"
        "    @staticmethod\n\n"
        "    def crear_animal(tipo):\n\n"
        "        if tipo == 'perro':\n\n"
        "            return Perro()\n\n"
        "        elif tipo == 'gato':\n\n"
        "            return Gato()\n\n"
        "        else:\n\n"
        "            raise ValueError('Tipo de animal no reconocido')\n"
        "\n"
        "# Uso de la Clase Factory\n\n"
        "factory = AnimalFactory()\n\n"
        "animal1 = factory.crear_animal('perro')\n\n"
        "animal2 = factory.crear_animal('gato')\n"
        "\n"
        "print(animal1.hablar())  # 🐶 Guau!\n\n"
        "print(animal2.hablar())  # 🐱 Miau!\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- AnimalFactory encapsula la lógica de creación en un método estático crear_animal().  \n\n"
        "- Si pedimos 'perro', crea un Perro(), y si pedimos 'gato', crea un Gato().  \n\n"
        "- Separamos la lógica de creación de objetos, lo que facilita la escalabilidad y el mantenimiento.  \n"
        "\n"
        "✅ **Ventaja:** Podemos reutilizar AnimalFactory en diferentes partes del código sin modificarla.  \n"
        "\n"
        "### 5. Ejemplo práctico: Factory para conexión a bases de datos  \n\n"
        "Supongamos que queremos una Factory que cree conexiones a diferentes bases de datos **(SQLite, MySQL, PostgreSQL)** sin que el usuario tenga que preocuparse por los detalles.  \n"
        "\n"
        "```\n\n"
        "import sqlite3\n\n"
        "import pymysql\n"
        "\n"
        "class DatabaseFactory:\n\n"
        "    @staticmethod\n\n"
        "    def get_connection(db_type, **kwargs):\n\n"
        "        if db_type == 'sqlite':\n\n"
        "            return sqlite3.connect(kwargs.get('database', ':memory:'))\n\n"
        "        elif db_type == 'mysql':\n\n"
        "            return pymysql.connect(\n\n"
        "                host=kwargs.get('host', 'localhost'),\n\n"
        "                user=kwargs.get('user', 'root'),\n\n"
        "                password=kwargs.get('password', ''),\n\n"
        "                database=kwargs.get('database', 'test')\n\n"
        "            )\n\n"
        "        else:\n\n"
        "            raise ValueError('Tipo de base de datos no soportado')\n"
        "\n"
        "# Uso del Factory\n\n"
        "sqlite_conn = DatabaseFactory.get_connection('sqlite', database='mi_db.sqlite')\n\n"
        "mysql_conn = DatabaseFactory.get_connection('mysql', host='localhost', user='admin', password='1234', database='mi_db')\n"
        "\n"
        'print(type(sqlite_conn))  # <class "sqlite3.Connection">\n\n'
        'print(type(mysql_conn))   # <class "pymysql.connections.Connection">\n'
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- DatabaseFactory.get_connection() devuelve la conexión adecuada según el tipo de base de datos.  \n\n"
        "- Si pedimos 'sqlite', crea una conexión SQLite.  \n\n"
        "- Si pedimos 'mysql', devuelve una conexión a MySQL.  \n\n"
        "- El usuario no necesita saber cómo conectar cada base de datos, solo usa get_connection().  \n"
        "\n"
        "✅ **Ventaja:** Si queremos añadir soporte para **PostgreSQL**, solo agregamos otra condición sin modificar el código existente.  \n"
        "\n"
        "### 6. Conclusión  \n"
        "\n"
        "🚀 **El patrón Factory permite crear objetos sin acoplar nuestro código a clases específicas.**  \n\n"
        "⚡ **Facilita la escalabilidad, ya que nuevas clases pueden añadirse sin modificar el código existente.**  \n\n"
        "🔹 **Se puede implementar con funciones, clases Factory o incluso metaclases.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes aplicar el patrón Factory en tus proyectos de Python!** 🔥\n"
    ),

    (
        "observer",
        "# 📌 Patrón Observer en Python  \n"
        "\n"
        "### 1. ¿Qué es el patrón Observer?  \n\n"
        "El **patrón Observer** es un **patrón de diseño de comportamiento** que permite definir una **relación de suscripción entre objetos**, de manera que cuando un objeto (el **Sujeto**) cambia de estado, **notifica automáticamente a todos los Observadores** que están suscritos a él.  \n"
        "\n"
        "📌 **Objetivo del Observer:**  \n\n"
        "✅ Implementar un **modelo de eventos** en el que múltiples objetos pueden reaccionar a cambios en otro objeto sin acoplamiento fuerte.  \n\n"
        "✅ **Desacoplar** la lógica de negocio de la notificación de cambios.  \n\n"
        "✅ Facilitar la **escalabilidad** al permitir que nuevos observadores se suscriban dinámicamente.  \n"
        "\n"
        "### 2. ¿Para qué se utiliza el Observer?  \n\n"
        "El patrón Observer es útil cuando queremos que **varios objetos reaccionen automáticamente a cambios en otro objeto**.  \n"
        "\n"
        "🔹 **Casos de uso comunes:**  \n\n"
        "✅ **Interfaces gráficas (GUIs)** → Cuando un botón cambia de estado, varios widgets pueden reaccionar.  \n\n"
        "✅ **Sistemas de notificaciones** → Cuando ocurre un evento, múltiples suscriptores reciben una alerta.  \n\n"
        "✅ **Modelos de eventos en frameworks web** → React, Django Signals, etc.  \n\n"
        "✅ **Sistemas de logging o auditoría** → Registrar eventos automáticamente en múltiples destinos.  \n"
        "\n"
        "### 3. Implementación del patrón Observer en Python  \n\n"
        "Podemos implementar el patrón Observer creando una clase **Sujeto (Observable)** que mantenga una lista de **Observadores** y les notifique los cambios.  \n"
        "\n"
        "**📌 Implementación básica del patrón Observer**\n"
        "```\n\n"
        "class Sujeto:\n\n"
        "    def __init__(self):\n\n"
        "        self._observadores = []  # Lista de observadores\n"
        "\n"
        "    def agregar_observador(self, observador):\n\n"
        "        self._observadores.append(observador)\n"
        "\n"
        "    def eliminar_observador(self, observador):\n\n"
        "        self._observadores.remove(observador)\n"
        "\n"
        "    def notificar_observadores(self, mensaje):\n\n"
        "        for observador in self._observadores:\n\n"
        "            observador.actualizar(mensaje)\n"
        "\n"
        "\n"
        "class Observador:\n\n"
        "    def actualizar(self, mensaje):\n\n"
        "        raise NotImplementedError('Subclases deben implementar el método actualizar')\n"
        "\n"
        "\n"
        "class ObservadorConcreto(Observador):\n\n"
        "    def __init__(self, nombre):\n\n"
        "        self.nombre = nombre\n"
        "\n"
        "    def actualizar(self, mensaje):\n\n"
        "        print(f'🔔 {self.nombre} recibió la notificación: {mensaje}')\n"
        "\n"
        "\n"
        "# Uso del patrón Observer\n\n"
        "sujeto = Sujeto()\n"
        "\n"
        "obs1 = ObservadorConcreto('Observador 1')\n\n"
        "obs2 = ObservadorConcreto('Observador 2')\n"
        "\n"
        "sujeto.agregar_observador(obs1)\n\n"
        "sujeto.agregar_observador(obs2)\n"
        "\n"
        "sujeto.notificar_observadores('¡Nuevo evento disponible!')  # Ambos observadores recibirán el mensaje\n"
        "\n"
        "sujeto.eliminar_observador(obs1)\n"
        "\n"
        "sujeto.notificar_observadores('Actualización importante')  # Solo el Observador 2 recibe este mensaje\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- Sujeto mantiene una lista de observadores (_observadores).  \n\n"
        "- Observador es una clase base que define un método actualizar().  \n\n"
        "- ObservadorConcreto implementa actualizar(), definiendo qué hacer cuando recibe una notificación.  \n\n"
        "- Cuando sujeto.notificar_observadores() se ejecuta, todos los observadores reciben el mensaje.  \n\n"
        "- Si eliminamos un observador, deja de recibir actualizaciones.  \n"
        "\n"
        "✅ **Ventaja:** Podemos añadir nuevos observadores sin modificar el código del sujeto.  \n"
        "\n"
        "### 4. Ejemplo práctico: Sistema de notificaciones  \n\n"
        "Supongamos que queremos implementar un **sistema de notificaciones** donde los usuarios pueden suscribirse a alertas.  \n"
        "\n"
        "```\n\n"
        "class CanalNotificaciones:\n\n"
        "    def __init__(self):\n\n"
        "        self._suscriptores = []\n"
        "\n"
        "    def suscribirse(self, usuario):\n\n"
        "        self._suscriptores.append(usuario)\n"
        "\n"
        "    def cancelar_suscripcion(self, usuario):\n\n"
        "        self._suscriptores.remove(usuario)\n"
        "\n"
        "    def enviar_notificacion(self, mensaje):\n\n"
        "        print(f'📢 Enviando notificación: {mensaje}')\n\n"
        "        for usuario in self._suscriptores:\n\n"
        "            usuario.recibir_notificacion(mensaje)\n"
        "\n"
        "\n"
        "class Usuario:\n\n"
        "    def __init__(self, nombre):\n\n"
        "        self.nombre = nombre\n"
        "\n"
        "    def recibir_notificacion(self, mensaje):\n\n"
        "        print(f'📩 {self.nombre} recibió: {mensaje}')\n"
        "\n"
        "\n"
        "# Uso del sistema de notificaciones\n\n"
        "canal = CanalNotificaciones()\n"
        "\n"
        "usuario1 = Usuario('Alice')\n\n"
        "usuario2 = Usuario('Bob')\n"
        "\n"
        "canal.suscribirse(usuario1)\n\n"
        "canal.suscribirse(usuario2)\n"
        "\n"
        "canal.enviar_notificacion('🔥 Nueva oferta disponible!')\n"
        "\n"
        "canal.cancelar_suscripcion(usuario1)\n"
        "\n"
        "canal.enviar_notificacion('🎉 Evento exclusivo para suscriptores!')  # Solo Bob recibe la notificación\n"
        "```\n\n"
        "📌 **¿Qué hace este código?**  \n\n"
        "- CanalNotificaciones gestiona los **suscriptores** y les envía mensajes.  \n\n"
        "- Usuario representa a los **observadores**, que reciben las notificaciones.  \n\n"
        "- Cuando enviamos una notificación con enviar_notificacion(), todos los suscriptores reciben el mensaje.  \n\n"
        "- Si un usuario se **desuscribe**, deja de recibir notificaciones.  \n"
        "\n"
        "✅ **Ventaja:** Podemos añadir más tipos de suscriptores sin modificar `CanalNotificaciones`.  \n"
        "\n"
        "### 5. Implementación con weakref.WeakSet (Evita referencias fuertes)  \n\n"
        "Python tiene un módulo llamado `weakref`, que nos ayuda a manejar observadores sin referencias fuertes para evitar problemas de memoria.  \n"
        "\n"
        "```\n\n"
        "import weakref\n"
        "\n"
        "class Sujeto:\n\n"
        "    def __init__(self):\n\n"
        "        self._observadores = weakref.WeakSet()\n"
        "\n"
        "    def agregar_observador(self, observador):\n\n"
        "        self._observadores.add(observador)\n"
        "\n"
        "    def notificar(self, mensaje):\n\n"
        "        for observador in self._observadores:\n\n"
        "            observador.actualizar(mensaje)\n"
        "\n"
        "\n"
        "class Observador:\n\n"
        "    def actualizar(self, mensaje):\n\n"
        "        print(f'📢 Notificación recibida: {mensaje}')\n"
        "\n"
        "\n"
        "# Uso del patrón Observer con weakref\n\n"
        "sujeto = Sujeto()\n\n"
        "obs = Observador()\n"
        "\n"
        "sujeto.agregar_observador(obs)\n\n"
        "sujeto.notificar('✅ Evento registrado')  # Observador recibe la notificación\n"
        "\n"
        "del obs  # Eliminamos el observador\n\n"
        "sujeto.notificar('🚀 Esto no debería imprimirse')  # No hay observadores activos\n"
        "```\n\n"
        "📌 **¿Por qué usar weakref.WeakSet()?**  \n\n"
        "✅ **Evita fugas de memoria** → Si un observador se elimina, se elimina automáticamente de _observadores.  \n\n"
        "✅ **No necesitamos eliminar manualmente los observadores**.  \n"
        "\n"
        "### 6. Conclusión \n"
        "\n"
        "🚀 **El patrón Observer permite que múltiples objetos reaccionen a cambios sin acoplamiento fuerte.**  \n\n"
        "⚡ **Es ideal para notificaciones, eventos y actualizaciones en tiempo real.**  \n\n"
        "🔹 **Se puede implementar con listas, clases Factory o weakref.WeakSet().**  \n"
        "\n"
        "📌 **¡Ahora ya puedes aplicar el patrón Observer en tus proyectos de Python!** 🔥\n"
    ),

    (
        "strategy",
        "# 📌 Patrón Strategy en Python  \n"
        "\n"
        "### 1. ¿Qué es el patrón Strategy?  \n\n"
        "El *patrón Strategy* es un *patrón de diseño de comportamiento* que permite definir un *grupo de algoritmos intercambiables*, encapsularlos en clases separadas y hacer que los objetos los usen sin acoplarse a una implementación específica.  \n"
        "\n"
        "📌 **Objetivo del Strategy:**  \n\n"
        "✅ Permitir que un algoritmo sea **seleccionado en tiempo de ejecución**.  \n\n"
        "✅ **Desacoplar** la lógica de negocio de los algoritmos específicos.  \n\n"
        "✅ Facilitar la **extensibilidad**, permitiendo añadir nuevas estrategias sin modificar el código existente.  \n"
        "\n"
        "### 2. ¿Para qué se utiliza el Strategy?  \n\n"
        "El patrón Strategy es útil cuando queremos **alternar entre diferentes algoritmos sin modificar la lógica del cliente**.  \n"
        "\n"
        "🔹 **Casos de uso comunes:**  \n\n"
        "✅ **Sistemas de pago** → Permitir pagar con PayPal, tarjeta de crédito, criptomonedas, etc.  \n\n"
        "✅ **Compresión de archivos** → Usar ZIP, GZIP, o TAR según la elección del usuario.  \n\n"
        "✅ **Ordenamiento de datos** → Seleccionar entre QuickSort, MergeSort o BubbleSort según el contexto.  \n\n"
        "✅ **Autenticación de usuarios** → Alternar entre OAuth, JWT o autenticación básica.  \n"
        "\n"
        "### 3. Implementación del patrón Strategy en Python  \n\n"
        "Podemos implementar el patrón Strategy definiendo una **interfaz común** para todas las estrategias y creando **clases específicas** que implementen diferentes versiones de un algoritmo.  \n"
        "\n"
        "**📌 Implementación básica del patrón Strategy**\n"
        "```\n\n"
        "from abc import ABC, abstractmethod\n"
        "\n"
        "# Definimos la interfaz de la estrategia\n\n"
        "class Estrategia(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def ejecutar(self, datos):\n\n"
        "        pass\n"
        "\n"
        "# Implementamos estrategias concretas\n\n"
        "class EstrategiaMayusculas(Estrategia):\n\n"
        "    def ejecutar(self, datos):\n\n"
        "        return datos.upper()\n"
        "\n"
        "class EstrategiaMinusculas(Estrategia):\n\n"
        "    def ejecutar(self, datos):\n\n"
        "        return datos.lower()\n"
        "\n"
        "class EstrategiaCapitalizar(Estrategia):\n\n"
        "    def ejecutar(self, datos):\n\n"
        "        return datos.capitalize()\n"
        "\n"
        "# Contexto que usa diferentes estrategias\n\n"
        "class Contexto:\n\n"
        "    def __init__(self, estrategia: Estrategia):\n\n"
        "        self._estrategia = estrategia\n"
        "\n"
        "    def establecer_estrategia(self, estrategia: Estrategia):\n\n"
        "        self._estrategia = estrategia\n"
        "\n"
        "    def ejecutar_estrategia(self, datos):\n\n"
        "        return self._estrategia.ejecutar(datos)\n"
        "\n"
        "# Uso del patrón Strategy\n\n"
        "contexto = Contexto(EstrategiaMayusculas())  \n\n"
        "print(contexto.ejecutar_estrategia('Hola mundo'))  # HOLA MUNDO\n"
        "\n"
        "contexto.establecer_estrategia(EstrategiaMinusculas())  \n\n"
        "print(contexto.ejecutar_estrategia('Hola mundo'))  # hola mundo\n"
        "\n"
        "contexto.establecer_estrategia(EstrategiaCapitalizar())  \n\n"
        "print(contexto.ejecutar_estrategia('hola mundo'))  # Hola mundo\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "- Estrategia es una **clase abstracta** con el método ejecutar(), que deben implementar todas las estrategias.  \n\n"
        "- EstrategiaMayusculas, EstrategiaMinusculas y EstrategiaCapitalizar implementan diferentes formas de procesar texto.  \n\n"
        "- Contexto almacena una estrategia y la ejecuta cuando sea necesario.  \n\n"
        "- Podemos cambiar la estrategia **en tiempo de ejecución** con establecer_estrategia().  \n"
        "\n"
        "✅ **Ventaja:** Podemos añadir nuevas estrategias sin modificar el código existente.  \n"
        "\n"
        "### 4. Ejemplo práctico: Sistema de pago con múltiples estrategias  \n\n"
        "Supongamos que queremos implementar un sistema donde los usuarios puedan elegir entre **pago con tarjeta, PayPal o criptomonedas**.  \n"
        "\n"
        "```\n\n"
        "class MetodoPago(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def pagar(self, monto):\n\n"
        "        pass\n"
        "\n"
        "class PagoTarjeta(MetodoPago):\n\n"
        "    def pagar(self, monto):\n\n"
        "        print(f'💳 Pagando {monto} con tarjeta de crédito.')\n"
        "\n"
        "class PagoPayPal(MetodoPago):\n\n"
        "    def pagar(self, monto):\n\n"
        "        print(f'🅿️ Pagando {monto} con PayPal.')\n"
        "\n"
        "class PagoCripto(MetodoPago):\n\n"
        "    def pagar(self, monto):\n\n"
        "        print(f'₿ Pagando {monto} con criptomonedas.')\n"
        "\n"
        "class ProcesadorPago:\n\n"
        "    def __init__(self, metodo_pago: MetodoPago):\n\n"
        "        self._metodo_pago = metodo_pago\n"
        "\n"
        "    def cambiar_metodo(self, metodo_pago: MetodoPago):\n\n"
        "        self._metodo_pago = metodo_pago\n"
        "\n"
        "    def procesar_pago(self, monto):\n\n"
        "        self._metodo_pago.pagar(monto)\n"
        "\n"
        "# Uso del patrón Strategy\n\n"
        "procesador = ProcesadorPago(PagoTarjeta())\n\n"
        "procesador.procesar_pago(100)  # 💳 Pagando 100 con tarjeta de crédito.\n"
        "\n"
        "procesador.cambiar_metodo(PagoPayPal())\n\n"
        "procesador.procesar_pago(200)  # 🅿️ Pagando 200 con PayPal.\n"
        "\n"
        "procesador.cambiar_metodo(PagoCripto())\n\n"
        "procesador.procesar_pago(300)  # ₿ Pagando 300 con criptomonedas.\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "1️⃣ MetodoPago es una **interfaz** que define el método pagar().  \n\n"
        "2️⃣ PagoTarjeta, PagoPayPal y PagoCripto implementan diferentes formas de procesar pagos.  \n\n"
        "3️⃣ ProcesadorPago mantiene una referencia a la estrategia activa y la ejecuta con procesar_pago().  \n\n"
        "4️⃣ Podemos cambiar el método de pago en **tiempo de ejecución** con cambiar_metodo().  \n"
        "\n"
        "✅ **Ventaja:** Si en el futuro queremos agregar **Apple Pay o Stripe**, solo creamos una nueva clase sin modificar el código existente.  \n"
        "\n"
        "### 5. Implementación con funciones de alto orden  \n\n"
        "En Python, podemos simplificar el patrón Strategy usando **funciones en lugar de clases**.  \n"
        "\n"
        "```\n\n"
        "def estrategia_mayusculas(datos):\n\n"
        "    return datos.upper()\n"
        "\n"
        "def estrategia_minusculas(datos):\n\n"
        "    return datos.lower()\n"
        "\n"
        "def estrategia_capitalizar(datos):\n\n"
        "    return datos.capitalize()\n"
        "\n"
        "# Contexto que usa funciones como estrategias\n\n"
        "class Contexto:\n\n"
        "    def __init__(self, estrategia):\n\n"
        "        self._estrategia = estrategia\n"
        "\n"
        "    def establecer_estrategia(self, estrategia):\n\n"
        "        self._estrategia = estrategia\n"
        "\n"
        "    def ejecutar_estrategia(self, datos):\n\n"
        "        return self._estrategia(datos)\n"
        "\n"
        "# Uso con funciones como estrategias\n\n"
        "contexto = Contexto(estrategia_mayusculas)\n\n"
        "print(contexto.ejecutar_estrategia('Hola mundo'))  # HOLA MUNDO\n"
        "\n"
        "contexto.establecer_estrategia(estrategia_minusculas)\n\n"
        "print(contexto.ejecutar_estrategia('Hola mundo'))  # hola mundo\n"
        "\n"
        "contexto.establecer_estrategia(estrategia_capitalizar)\n\n"
        "print(contexto.ejecutar_estrategia('hola mundo'))  # Hola mundo\n"
        "```\n\n"
        "📌 **¿Cómo funciona?**  \n\n"
        "✅ En lugar de clases, usamos **funciones** para definir estrategias.  \n\n"
        "✅ Contexto acepta cualquier función y la ejecuta.  \n\n"
        "✅ Más simple y Pythonic para estrategias simples.  \n"
        "\n"
        "### 6. Conclusión \n"
        "\n"
        "🚀 **El patrón Strategy permite alternar entre diferentes algoritmos sin modificar la lógica del cliente.**  \n\n"
        "⚡ **Es útil en procesamiento de datos, autenticación, compresión de archivos, ordenamiento y pagos.**  \n\n"
        "🔹 **Se puede implementar con clases o funciones de alto orden.**  \n"
        "\n"
        "📌 **¡Ahora ya puedes aplicar el patrón Strategy en tus proyectos de Python!** 🔥\n"
    ),

    (
        "solid",
        "# 📌 Principios SOLID en Python  \n"
        "\n"
        "Los principios **SOLID** son un conjunto de reglas que ayudan a diseñar **código limpio, mantenible y escalable**. Fueron formulados por **Robert C. Martin (Uncle Bob)** y se aplican en programación orientada a objetos (POO).  \n"
        "\n"
        "✅ **Objetivo de SOLID:**  \n\n"
        "🔹 Hacer que el código sea **más comprensible y modular**.  \n\n"
        "🔹 Reducir la **complejidad** y mejorar la **extensibilidad**.  \n\n"
        "🔹 Facilitar la **prueba y el mantenimiento** del código.  \n"
        "\n"
        "SOLID es un acrónimo de cinco principios:  \n\n"
        "- **S** → **Single Responsibility Principle (SRP)**  \n\n"
        "- **O** → **Open/Closed Principle (OCP)**  \n\n"
        "- **L** → **Liskov Substitution Principle (LSP)**  \n\n"
        "- **I** → **Interface Segregation Principle (ISP)**  \n\n"
        "- **D** → **Dependency Inversion Principle (DIP)**  \n"
        "\n"
        "A continuación, explicaremos **cada principio con ejemplos en Python**.  \n"
        "\n"
        "### 1. Principio de Responsabilidad Única (SRP)  \n\n"
        "🔹 **Cada clase debe tener una única razón para cambiar**.  \n\n"
        "🔹 Una clase **debe tener una única responsabilidad**.  \n"
        "\n"
        "### ❌ **Ejemplo INCORRECTO (violando SRP)**  \n"
        "```\n\n"
        "class Reporte:\n\n"
        "    def __init__(self, contenido):\n\n"
        "        self.contenido = contenido\n"
        "\n"
        "    def generar_pdf(self):\n\n"
        "        print('Generando reporte en PDF...')\n"
        "\n"
        "    def guardar_bd(self):\n\n"
        "        print('Guardando en la base de datos...')\n"
        "```\n\n"
        "📌 **Problema:**  \n\n"
        "☠️ Esta clase tiene **dos responsabilidades**:  \n\n"
        "- **Generar el PDF.**  \n\n"
        "- **Guardar en la base de datos.**  \n\n"
        "Si necesitamos cambiar la forma en que guardamos los datos, también afectamos la lógica del PDF.  \n"
        "\n"
        "### ✅ **Ejemplo CORRECTO (aplicando SRP)**  \n"
        "```\n\n"
        "class Reporte:\n\n"
        "    def __init__(self, contenido):\n\n"
        "        self.contenido = contenido\n"
        "\n"
        "class GeneradorPDF:\n\n"
        "    def generar(self, reporte):\n\n"
        "        print('Generando reporte en PDF...')\n"
        "\n"
        "class RepositorioBD:\n\n"
        "    def guardar(self, reporte):\n\n"
        "        print('Guardando en la base de datos...')\n"
        "```\n\n"
        "📌 **Corrección:**  \n\n"
        "✔️ Ahora cada clase tiene una única responsabilidad.  \n\n"
        "✔️ **Reportes** solo gestiona el contenido.  \n\n"
        "✔️ **GeneradorPDF** maneja la generación de PDFs.  \n\n"
        "✔️ **RepositorioBD** gestiona la persistencia de datos.  \n"
        "\n"
        "### 2. Principio de Abierto/Cerrado (OCP)  \n\n"
        "🔹 **El código debe estar abierto para extensión, pero cerrado para modificación.**  \n\n"
        "🔹 Debemos evitar modificar clases existentes para agregar nuevas funcionalidades.  \n"
        "\n"
        "### ❌ **Ejemplo INCORRECTO (violando OCP)**  \n"
        "```\n\n"
        "class CalculadoraDescuentos:\n\n"
        "    def calcular(self, tipo, precio):\n\n"
        "        if tipo == 'estudiante':\n\n"
        "            return precio * 0.8\n\n"
        "        elif tipo == 'jubilado':\n\n"
        "            return precio * 0.7\n\n"
        "        else:\n\n"
        "            return precio\n"
        "```\n\n"
        "📌 **Problema:**  \n\n"
        "☠️ Si agregamos un nuevo descuento, **modificamos la clase** y **rompemos código existente**.  \n"
        "\n"
        "### ✅ **Ejemplo CORRECTO (aplicando OCP con polimorfismo)**  \n"
        "```\n\n"
        "from abc import ABC, abstractmethod\n"
        "\n"
        "class Descuento(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def aplicar(self, precio):\n\n"
        "        pass\n"
        "\n"
        "class DescuentoEstudiante(Descuento):\n\n"
        "    def aplicar(self, precio):\n\n"
        "        return precio * 0.8\n"
        "\n"
        "class DescuentoJubilado(Descuento):\n\n"
        "    def aplicar(self, precio):\n\n"
        "        return precio * 0.7\n"
        "\n"
        "class CalculadoraDescuentos:\n\n"
        "    def __init__(self, descuento: Descuento):\n\n"
        "        self.descuento = descuento\n"
        "\n"
        "    def calcular(self, precio):\n\n"
        "        return self.descuento.aplicar(precio)\n"
        "\n"
        "# Uso\n\n"
        "print(CalculadoraDescuentos(DescuentoEstudiante()).calcular(100))  # 80\n\n"
        "print(CalculadoraDescuentos(DescuentoJubilado()).calcular(100))  # 70\n"
        "```\n\n"
        "📌 **Corrección:**  \n\n"
        "✔️ Podemos agregar nuevos descuentos sin modificar la clase principal.  \n"
        "\n"
        "### 3. Principio de Sustitución de Liskov (LSP)  \n\n"
        "🔹 **Las subclases deben poder sustituir a sus clases base sin cambiar el comportamiento del programa.**  \n"
        "\n"
        "### ❌ **Ejemplo INCORRECTO (violando LSP)**  \n"
        "```\n\n"
        "class Pato:\n\n"
        "    def volar(self):\n\n"
        "        print('🦆 Volando...')\n"
        "\n"
        "class PatoDeGoma(Pato):\n\n"
        "    def volar(self):\n\n"
        "        raise NotImplementedError('Los patos de goma no vuelan')\n"
        "```\n\n"
        "📌 **Problema:**  \n\n"
        "☠️ *PatoDeGoma* rompe la funcionalidad esperada de *Pato*, causando errores en código que usa la clase base.  \n"
        "\n"
        "### ✅ **Ejemplo CORRECTO (aplicando LSP con herencia correcta)**  \n"
        "```\n\n"
        "class Pato(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def hacer_sonido(self):\n\n"
        "        pass\n"
        "\n"
        "class PatoReal(Pato):\n\n"
        "    def hacer_sonido(self):\n\n"
        "        return 'Cuac cuac'\n"
        "\n"
        "class PatoDeGoma(Pato):\n\n"
        "    def hacer_sonido(self):\n\n"
        "        return 'Squeak!'\n"
        "\n"
        "# Uso\n\n"
        "patos = [PatoReal(), PatoDeGoma()]\n\n"
        "for pato in patos:\n\n"
        "    print(pato.hacer_sonido())\n"
        "```\n\n"
        "📌 **Corrección:**  \n\n"
        "✔️ *PatoDeGoma* y *PatoReal* cumplen con *Pato*, sin romper el código.  \n"
        "\n"
        "### 4. Principio de Segregación de Interfaces (ISP)  \n\n"
        "🔹 **Una clase no debe verse forzada a implementar métodos que no usa.**  \n"
        "\n"
        "### ❌ **Ejemplo INCORRECTO (violando ISP)**  \n"
        "```\n\n"
        "class Animal:\n\n"
        "    def caminar(self):\n\n"
        "        pass\n"
        "    \n"
        "    def volar(self):\n\n"
        "        pass  # 🐶 Un perro no vuela\n"
        "```\n\n"
        "📌 **Problema:**  \n\n"
        "☠️ **Los perros no vuelan**, pero se ven obligados a implementar volar().  \n"
        "\n"
        "### ✅ **Ejemplo CORRECTO (aplicando ISP con interfaces específicas)**  \n"
        "```\n\n"
        "class Caminador(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def caminar(self):\n\n"
        "        pass\n"
        "\n"
        "class Volador(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def volar(self):\n\n"
        "        pass\n"
        "\n"
        "class Perro(Caminador):\n\n"
        "    def caminar(self):\n\n"
        "        print('🐶 Caminando...')\n"
        "\n"
        "class Pajaro(Caminador, Volador):\n\n"
        "    def caminar(self):\n\n"
        "        print('🐦 Caminando...')\n"
        "    \n"
        "    def volar(self):\n\n"
        "        print('🕊️ Volando...')\n"
        "```\n\n"
        "📌 **Corrección:**  \n\n"
        "✔️ Separamos Caminador y Volador en interfaces independientes.  \n"
        "\n"
        "### 5. Principio de Inversión de Dependencias (DIP)  \n\n"
        "🔹 **Los módulos de alto nivel no deben depender de los de bajo nivel, ambos deben depender de abstracciones.**  \n"
        "\n"
        "### ❌ **Ejemplo INCORRECTO (violando DIP)**  \n"
        "```\n\n"
        "class MySQLDB:\n\n"
        "    def conectar(self):\n\n"
        "        print('Conectando a MySQL...')\n"
        "\n"
        "class App:\n\n"
        "    def __init__(self):\n\n"
        "        self.db = MySQLDB()\n"
        "```\n\n"
        "📌 **Problema:**  \n\n"
        "☠️ App está **acoplada** a MySQLDB. No podemos cambiar de base de datos fácilmente.  \n"
        "\n"
        "### ✅ **Ejemplo CORRECTO (aplicando DIP con inyección de dependencias)**  \n"
        "```\n\n"
        "class BaseDatos(ABC):\n\n"
        "    @abstractmethod\n\n"
        "    def conectar(self):\n\n"
        "        pass\n"
        "\n"
        "class MySQLDB(BaseDatos):\n\n"
        "    def conectar(self):\n\n"
        "        print('Conectando a MySQL...')\n"
        "\n"
        "class PostgreSQLDB(BaseDatos):\n\n"
        "    def conectar(self):\n\n"
        "        print('Conectando a PostgreSQL...')\n"
        "\n"
        "class App:\n\n"
        "    def __init__(self, db: BaseDatos):\n\n"
        "        self.db = db\n"
        "\n"
        "# Uso\n\n"
        "app = App(MySQLDB())  # Podemos cambiar a PostgreSQL sin modificar App.\n\n"
        "app.db.conectar()\n"
        "```\n\n"
        "📌 **Corrección:**  \n\n"
        "✔️ App no depende de una base de datos específica, usa una **abstracción**.  \n"
        "\n"
        "**🎯 Conclusión**  \n\n"
        "🚀 **SOLID mejora la mantenibilidad, escalabilidad y calidad del código en Python.**  \n\n"
        "🔹 **Aplica estos principios para escribir código más limpio y robusto.**  \n\n"
        "🔥 ¡Ahora tienes el conocimiento para aplicar SOLID en tus proyectos Python!\n"
    ),

    (
        "microservicios",
        "# 📌 Microservicios en Python  \n"
        "\n"
        "### ¿Qué son los microservicios?  \n\n"
        "Los *microservicios* son un enfoque arquitectónico para desarrollar aplicaciones como un conjunto de *servicios pequeños, independientes y comunicados entre sí*. Cada microservicio tiene una responsabilidad específica y funciona de manera autónoma.  \n"
        "\n"
        "🔹 **Características principales:**  \n\n"
        "✅ **Independencia**: Cada servicio opera de forma autónoma.  \n\n"
        "✅ **Escalabilidad**: Se pueden escalar individualmente.  \n\n"
        "✅ **Despliegue independiente**: Cada servicio se puede actualizar sin afectar a otros.  \n\n"
        "✅ **Comunicación entre servicios**: Generalmente mediante **APIs REST, gRPC o mensajería** (RabbitMQ, Kafka, Redis).  \n\n"
        "✅ **Flexibilidad tecnológica**: Diferentes microservicios pueden usar distintos lenguajes o bases de datos.  \n"
        "\n"
        "**📌 Microservicios en un entorno Python**  \n\n"
        "Python es una excelente opción para microservicios debido a su *sencillez y ecosistema*. Las herramientas más utilizadas son:  \n"
        "\n"
        "🔹 **Frameworks web:**  \n\n"
        "- [FastAPI](https://fastapi.tiangolo.com/) 🚀 (el más rápido)  \n\n"
        "- [Flask](https://flask.palletsprojects.com/) 🏗️ (ligero y flexible)  \n\n"
        "- [Django REST Framework (DRF)](https://www.django-rest-framework.org/) 🛠️ (ideal si usas Django)  \n"
        "\n"
        "🔹 **Comunicación entre microservicios:**  \n\n"
        "- **HTTP REST APIs** (con FastAPI, Flask, DRF).  \n\n"
        "- **Mensajería asíncrona** con **RabbitMQ, Kafka, Redis Pub/Sub**.  \n\n"
        "- **gRPC** (alta velocidad en comunicación binaria).  \n"
        "\n"
        "🔹 **Gestión de microservicios:**  \n\n"
        "- **Docker** (para contenerización).  \n\n"
        "- **Kubernetes** (para orquestación de servicios).  \n\n"
        "- **Consul o etcd** (para descubrimiento de servicios).  \n"
        "\n"
        "**📌 Ejemplo práctico de microservicio con Python y FastAPI**  \n\n"
        "### 🏗 **Caso de uso:**  \n\n"
        "Construiremos un **sistema de pedidos** con dos microservicios:  \n\n"
        "- **Microservicio de Usuarios** (users_service.py)  \n\n"
        "- **Microservicio de Pedidos** (orders_service.py)  \n"
        "\n"
        "Los servicios se comunicarán entre sí mediante **HTTP REST APIs**.\n"
        "\n"
        "### 1. Microservicio de Usuarios (users_service.py)\n\n"
        "Este servicio gestiona usuarios y expone un endpoint para obtener información de un usuario.  \n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "# Base de datos simulada\n\n"
        "users_db = {\n\n"
        "    1: {'id': 1, 'nombre': 'Alice'},\n\n"
        "    2: {'id': 2, 'nombre': 'Bob'}\n\n"
        "}\n"
        "\n"
        "@app.get('/usuarios/{user_id}')\n\n"
        "def obtener_usuario(user_id: int):\n\n"
        "    usuario = users_db.get(user_id)\n\n"
        "    if usuario:\n\n"
        "        return usuario\n\n"
        "    return {'error': 'Usuario no encontrado'}, 404\n"
        "\n"
        "# Ejecutar con: uvicorn users_service:app --reload --port 8001\n"
        "```\n\n"
        "📌 **Explicación:**  \n\n"
        "✔️ **Usamos FastAPI** para exponer un endpoint /usuarios/{user_id}.  \n\n"
        "✔️ **Simulamos una base de datos** en users_db.  \n\n"
        "✔️ Si el usuario existe, lo devolvemos en JSON.  \n"
        "\n"
        "### 2. Microservicio de Pedidos (orders_service.py)\n\n"
        "Este servicio gestiona pedidos y consulta el **microservicio de usuarios** para obtener información de los clientes.\n"
        "\n"
        "```\n\n"
        "from fastapi import FastAPI\n\n"
        "import requests  # Para comunicarnos con el otro microservicio\n"
        "\n"
        "app = FastAPI()\n"
        "\n"
        "# Base de datos simulada de pedidos\n\n"
        "orders_db = {\n\n"
        "    1: {'id': 1, 'user_id': 1, 'producto': 'Laptop'},\n\n"
        "    2: {'id': 2, 'user_id': 2, 'producto': 'Teléfono'}\n\n"
        "}\n"
        "\n"
        "USER_SERVICE_URL = 'http://127.0.0.1:8001/usuarios'  # URL del microservicio de usuarios\n"
        "\n"
        "@app.get('/pedidos/{order_id}')\n\n"
        "def obtener_pedido(order_id: int):\n\n"
        "    pedido = orders_db.get(order_id)\n\n"
        "    if not pedido:\n\n"
        "        return {'error': 'Pedido no encontrado'}, 404\n"
        "\n"
        "    # Llamamos al microservicio de usuarios\n\n"
        "    user_response = requests.get(f'{USER_SERVICE_URL}/{pedido['user_id']}')\n"
        "    \n"
        "    if user_response.status_code == 200:\n\n"
        "        pedido['cliente'] = user_response.json()\n\n"
        "    else:\n\n"
        "        pedido['cliente'] = {'error': 'Usuario no encontrado'}\n"
        "\n"
        "    return pedido\n"
        "\n"
        "# Ejecutar con: uvicorn orders_service:app --reload --port 8002\n"
        "```\n\n"
        "📌 **Explicación:**  \n\n"
        "✔️ Exponemos un endpoint /pedidos/{order_id} para consultar pedidos.  \n\n"
        "✔️ Buscamos en `orders_db` el pedido solicitado.  \n\n"
        "✔️ Llamamos al **microservicio de usuarios** (users_service) con requests.get().  \n\n"
        "✔️ Si el usuario existe, lo agregamos a la respuesta del pedido.  \n"
        "\n"
        "**📌 Probando los microservicios**\n\n"
        "** Iniciar ambos microservicios en terminales separadas**\n"
        "```\n\n"
        "uvicorn users_service:app --reload --port 8001\n"
        "```\n"
        "\n"
        "```\n\n"
        "uvicorn orders_service:app --reload --port 8002\n"
        "```\n"
        "\n"
        "** Probar el servicio de Usuarios**\n"
        "```\n\n"
        "curl http://127.0.0.1:8001/usuarios/1\n"
        "```\n\n"
        "**Respuesta esperada:**\n"
        "```\n\n"
        "{'id': 1, 'nombre': 'Alice'}\n"
        "```\n"
        "\n"
        "** Probar el servicio de Pedidos**\n"
        "```\n\n"
        "curl http://127.0.0.1:8002/pedidos/1\n"
        "```\n\n"
        "**Respuesta esperada:**\n"
        "```\n\n"
        "{\n\n"
        "    'id': 1,\n\n"
        "    'user_id': 1,\n\n"
        "    'producto': 'Laptop',\n\n"
        "    'cliente': {\n\n"
        "        'id': 1,\n\n"
        "        'nombre': 'Alice'\n\n"
        "    }\n\n"
        "}\n"
        "```\n\n"
        "📌 **¡Éxito!** El servicio de pedidos obtiene información del usuario llamando al otro microservicio.  \n"
        "\n"
        "**📌 Ventajas y Desventajas de Microservicios**\n\n"
        "🔹 **Ventajas:**  \n\n"
        "✅ Escalabilidad independiente de cada servicio.  \n\n"
        "✅ Despliegue modular y flexible.  \n\n"
        "✅ Menor acoplamiento (cada servicio se puede desarrollar y mantener por separado).  \n"
        "\n"
        "🔹 **Desventajas:**  \n\n"
        "❌ Mayor complejidad en la comunicación entre servicios.  \n\n"
        "❌ Necesidad de gestionar la orquestación con herramientas como **Kubernetes**.  \n\n"
        "❌ Requiere **observabilidad** con herramientas como **Prometheus y Grafana** para monitoreo.  \n"
        "\n"
        "**📌 Herramientas para Microservicios en Python**\n\n"
        "✔️ **FastAPI / Flask / Django REST Framework** → Para construir APIs.  \n\n"
        "✔️ **Docker & Kubernetes** → Para contenerización y despliegue.  \n\n"
        "✔️ **RabbitMQ / Kafka / Redis** → Para comunicación asíncrona entre servicios.  \n\n"
        "✔️ **PostgreSQL / MongoDB / Redis** → Bases de datos para almacenamiento.  \n\n"
        "✔️ **Celery** → Para tareas en segundo plano.  \n"
        "\n"
        "**🎯 Conclusión**\n\n"
        "🚀 **Los microservicios permiten crear aplicaciones escalables y modulares.**  \n\n"
        "🔥 Python, junto con **FastAPI**, Docker y Kubernetes, es ideal para implementarlos.  \n\n"
        "🔗 ¡Ahora tienes la base para diseñar tus propios microservicios en Python! 🚀\n"
    ),

    (
        "git",
        "# Comandos básicos de Git\n\n"
        "Inicializa un nuevo repositorio de Git en el directorio actual.\n"
        "```\ngit init\n```\n\n"
        "Clona un repositorio existente en una nueva carpeta\n"
        "```\ngit clone <url-del-repositorio>\n```\n\n"
        "Muestra el estado actual del repositorio, incluyendo archivos modificados, añadidos y eliminados.\n"
        "```\ngit status\n```\n\n"
        "Añade archivos al área de preparación (staging area).\n"
        "```\ngit add <archivo>\n"
        "git add .\n```\n\n"
        "Guarda los cambios en el historial del repositorio con un mensaje descriptivo.\n"
        "```\ngit commit -m 'Mensaje del commit'\n```\n\n"
        "Actualiza el repositorio local con los cambios del repositorio remoto.\n"
        "```\ngit pull <nombre-remoto> <nombre-rama>\n```\n\n"
        "Cambia a otra rama o restaura archivos en el directorio de trabajo.\n"
        "```\ngit checkout <nombre-rama>  # Cambia a una rama existente\n"
        "git checkout -b <nombre-rama>  # Crea y cambia a una nueva rama\n```\n\n"
        "Fusiona cambios de una rama en la rama actual.\n"
        "```\ngit merge <nombre-rama>'\n```\n\n"
        "Muestra el historial de commits del repositorio.\n"
        "```\ngit log\n```\n\n"
        "Gestiona las conexiones a repositorios remotos.\n"
        "```\ngit remote add <nombre-remoto> <url>  # Añade un nuevo repositorio\n"
        "git remote -v                         # Muestra los repositorios\n```\n\n"
        "Descarga los objetos y referencias de otro repositorio.\n"
        "```\ngit fetch <nombre-remoto>\n```\n\n"
        "Deshace commits y cambia el estado del HEAD.\n"
        "```\ngit reset --hard <commit>  # Restablece el repositorio al estado de un commit específico\n```\n\n"
        "Aplica commits de una rama sobre otra, reescribiendo el historial.\n"
        "```\ngit rebase <nombre-rama>\n```\n\n"
        "Guarda temporalmente los cambios no confirmados para limpiar el directorio de trabajo.\n"
        "```\ngit stash\n"
        "git stash pop  # Restaura los cambios guardados\n```\n\n"
    
    ),

    (
        "react",
        "### Instalar Create React App\n"
        "Create React App es una herramienta oficial para crear aplicaciones React.\n"
        "```\nnpm install -g create-react-app\n```\n\n"
        "### Crear un nuevo proyecto React\n"
        "```\nnpx create-react-app my-app\n```\n"
        "\n"
        "```\nnpm start\n```\n"
    
    ),

    (
        "RuXx",
        "### SeLiNa IA - By:   *RuXx* \n\n"
        "```\n"
        "           .---.        .-----------\n"
        "          /     \\  __  /    ------\n"
        "         / /     \\(..)/    -----\n"
        "        //////   ' \\/ `   ---\n"
        "       //// / // :    : ---\n"
        "      // /   /  /`    '--\n"
        "     //          //..\\\\\n"
        "    /       ====UU====UU====\n"
        "                '//||\\\\`\n"
        "```\n"
    
    ),

    (
        "angular",
        "**Crear un nuevo proyecto**\n"
        " Crea un nuevo proyecto Angular con una estructura básica.\n"
        "```\nng new mi-proyecto\n```\n"
        "\n"
        "**Servir la aplicación**\n"
        "Levanta un servidor de desarrollo en http://localhost:4200/.\n"
        "```\nng serve\n```\n"
        "\n"
        "**Generar un componente**\n"
        "Crea un nuevo componente con sus archivos (.html, .ts, .scss, .spec.ts).\n"
        "```\nng generate component nombre-componente\n```\n"
        "\n"
        "**Generar un servicio**\n"
        "Crea un nuevo servicio para manejar lógica de negocio o peticiones HTTP.\n"
        "```\nng generate service nombre-servicio\n```\n"
        "\n"
        "**Generar un módulo**\n"
        "Crea un nuevo módulo para organizar mejor la aplicación.\n"
        "```\nng generate module nombre-modulo\n```\n"
        "\n"
        "**Construir la aplicación para producción**\n"
        "Compila y optimiza la aplicación para producción.\n"
        "```\nng build --configuration=production\n```\n"
        "\n"
        "**Agregar una nueva ruta (lazy loading)**\n"
        "Crea un módulo y lo enlaza con RouterModule para carga diferida.\n"
        "```\nng generate module nombre --route=nombre --module=app\n```\n"
        "\n"
        "**listar todos los comandos disponibles**\n"
        "```\nng help\n```\n"

    
    ),

    (

        "entorno virtual",
        "Para crear un entorno virtual en Python:\n"
        "```\npython -m venv env\n```\n\n"
        "Para activarlo en CMD:\n"
        "```\nenv\\Scripts\\activate\n```"
    ),


    ]

    for prompt, response in prompts_responses:
        add_or_update_predefined_prompt(prompt, response)